{
  "total": 12,
  "workflows": [
    {
      "id": "001",
      "slug": "gnrez-des-vidos-virales-ia-avec-veo-3-et-tlchargez-les-sur-tiktok",
      "title_en": "Generate AI Viral Videos with VEO 3 and Upload to TikTok",
      "title_fr": "G√©n√©rez des vid√©os virales IA avec VEO 3 et t√©l√©chargez-les sur TikTok",
      "description_short_en": "Automate viral video creation with AI‚Äîgenerate, edit, and auto-upload stunning TikTok videos daily. Ideal for creators and marketers. Discover more!",
      "description_short_fr": "Automatisez la cr√©ation de vid√©os virales avec l'IA¬†: g√©n√©rez, modifiez et t√©l√©chargez automatiquement de superbes vid√©os TikTok quotidiennement. Id√©al pour les cr√©ateurs et les marketeurs. D√©couvrez-en davantage¬†!",
      "description_full_en": "Generate AI Viral Videos with VEO 3 and Upload to TikTok\n1. Workflow Overview\nThis workflow automates the creation of viral short-form videos optimized for TikTok using AI-generated concepts and the VEO 3 video generation API. It streamlines the entire content creation pipeline from ideation through video production to publishing on TikTok, enabling users to scale their content output with minimal manual intervention.\nThe workflow is logically divided into three main blocks:\n1.1 Daily Trigger & Idea Generation:\nAutomatically triggers daily to generate a creative video idea using OpenAI GPT-5 and LangChain AI tools, parses structured AI output, and saves metadata to Google Sheets.\n1.2 Video Script Generation & VEO 3 Video Creation:\nBased on the saved idea, an AI agent crafts a detailed video prompt. The prompt is formatted and sent to the VEO 3 API to generate a cinematic vertical video. It includes a wait period to allow rendering, then downloads the finished video.\n1.3 Video Upload & Status Update:\nThe downloaded video URL is stored in Google Sheets, uploaded to Blotato (a TikTok integration node), then posted to TikTok. The production status is updated to reflect completion.\nSupporting nodes include sticky notes with detailed instructions and documentation links.\n2. Block-by-Block Analysis\n2.1 Daily Trigger & Idea Generation\nOverview:\nThis block initiates the workflow on a daily schedule. It generates a creative \"before/after transformation\" video idea using AI, parses the structured output, and records the idea and metadata to a Google Sheet.\nNodes Involved:\nTrigger: Start Daily Content Generation\nTool: Inject Creative Perspective (Idea)\nLLM: Generate Raw Idea (GPT-5)\nGenerate Creative Video Idea (LangChain agent)\nParse AI Output (Idea, Environment, Sound)\nSave Idea & Metadata to Google Sheets\nNode Details:\nTrigger: Start Daily Content Generation\nType: Schedule Trigger\nRole: Automatically triggers the workflow daily (interval set to 1 day)\nInputs: None\nOutputs: Triggers \"Generate Creative Video Idea\" node\nEdge cases: Misconfigured scheduling or disabled workflow can prevent triggering\nTool: Inject Creative Perspective (Idea)\nType: LangChain Tool Node (Think Tool)\nRole: Provides AI with creative perspective to improve idea generation\nInputs: Trigger output\nOutputs: Connected to \"Generate Creative Video Idea\" for enhanced ideation\nEdge cases: AI tool failures or timeouts\nLLM: Generate Raw Idea (GPT-5)\nType: LangChain Chat OpenAI (GPT-5 mini)\nRole: Generates an initial raw before/after transformation idea using GPT-5\nConfiguration: Uses OpenAI API with GPT-5 mini model\nInputs: Invoked by \"Generate Creative Video Idea\"\nOutputs: Raw AI text passed forward\nEdge cases: API quota exceeded, auth errors, model response delays\nGenerate Creative Video Idea\nType: LangChain Agent Node\nRole: Processes raw idea, enriches it with structured rules and formatting for TikTok content\nConfiguration: Complex system message enforcing strict formatting and content rules (e.g., 12 hashtags, emoji, environment, sound prompt)\nInputs: Output from LLM and Think tool nodes\nOutputs: Structured JSON array with keys: Caption, Idea, Environment, Sound, Status\nEdge cases: Parsing errors if AI output does not conform to expected schema\nParse AI Output (Idea, Environment, Sound)\nType: LangChain Structured Output Parser\nRole: Parses the AI-generated JSON array into structured data for further processing\nInputs: AI output string from \"Generate Creative Video Idea\"\nOutputs: Parsed structured JSON with fields usable by downstream nodes\nEdge cases: JSON schema mismatch or malformed AI output\nSave Idea & Metadata to Google Sheets\nType: Google Sheets Node\nRole: Appends the generated idea and metadata (caption, status, prompts) to a Google Sheet for tracking\nConfiguration: Defined column mapping for idea, caption, production status, environment, sound\nInputs: Parsed AI output JSON\nOutputs: Triggers next block (\"Set Master Prompt\")\nEdge cases: Google Sheets API quota, auth expiration, network issues\n2.2 Video Script Generation & VEO 3 Video Creation\nOverview:\nGenerates a detailed video script prompt based on the saved idea metadata, formats it for VEO 3 API consumption, triggers video generation, waits for rendering, and downloads the final video.\nNodes Involved:\nSet Master Prompt\nAI Agent: Generate Video Script\nFormat Prompt\nGenerate Video with VEO3 (HTTP Request)\nWait for VEO3 Rendering\nDownload Video from VEO3\nNode Details:\nSet Master Prompt\nType: Set Node\nRole: Defines a comprehensive JSON master prompt schema describing cinematic video generation parameters such as description, style, camera, lighting, environment, motion, VFX, audio, ending, and format (aspect ratio 9:16)\nConfiguration: Static JSON string assigned to variable\njson_master\nplus model and aspect ratio keys\nInputs: Triggered after saving idea metadata\nOutputs: Passes master prompt to AI Agent node\nEdge cases: Syntax errors in JSON, missing fields affecting downstream processing\nAI Agent: Generate Video Script\nType: LangChain Agent Node\nRole: Uses the previously saved idea, environment, and sound prompts to generate a detailed VEO 3-compatible video prompt JSON with fields such as BEFORE scene, AFTER scene, TRANSITION, CAMERA, LIGHTING, PALETTE, STYLE, and SOUND\nConfiguration: System prompt enforcing strict JSON output with only two top-level keys:\ntitle\nand\nfinal_prompt\n(stringified JSON)\nInputs: Idea metadata + master prompt\nOutputs: Structured AI JSON object parsed by next node\nEdge cases: AI output formatting errors, token limit issues, API failures\nFormat Prompt\nType: Code Node (JavaScript)\nRole: Converts the AI agent‚Äôs JSON output into a single JSON string escaped properly to be used as the\nprompt\nparameter for VEO 3 API\nInputs: AI Agent output\nOutputs: Prepared HTTP request body fields (prompt, model, aspectRatio)\nEdge cases: JSON stringify errors, null inputs\nGenerate Video with VEO3\nType: HTTP Request Node\nRole: Sends POST request to VEO 3 API\nhttps://api.kie.ai/api/v1/veo/generate\nto start video generation with the crafted prompt\nConfiguration: Uses HTTP Header Authentication with Kie AI credentials\nInputs: Formatted prompt and model/aspect ratio settings\nOutputs: Returns a\ntaskId\nfor video rendering tracking\nEdge cases: API rate limits, auth token expiration, request timeouts\nWait for VEO3 Rendering\nType: Wait Node\nRole: Pauses workflow execution for 3 minutes to allow VEO 3 to process and render the video\nInputs: Triggered after video generation request\nOutputs: After wait, triggers download node\nEdge cases: Fixed wait time may be insufficient for longer renders\nDownload Video from VEO3\nType: HTTP Request Node\nRole: Queries\nhttps://api.kie.ai/api/v1/veo/record-info\nwith\ntaskId\nto retrieve rendering status and download URL of the generated video\nConfiguration: HTTP Header Authentication with Kie AI credentials\nInputs: taskId from generation response\nOutputs: Returns JSON containing final video URLs\nEdge cases: Video not ready yet, API errors, malformed responses\n2.3 Video Upload & Status Update\nOverview:\nStores the final video URL in Google Sheets, uploads the video to Blotato for TikTok, posts the video to TikTok, and updates the production status in Google Sheets to ‚ÄúDONE‚Äù.\nNodes Involved:\nURL Final Video (Google Sheets)\nUpload Video to BLOTATO\nTikTok (Blotato node)\nUpdate Status to \"DONE\" (Google Sheets)\nNode Details:\nURL Final Video\nType: Google Sheets Node\nRole: Updates the same row in Google Sheets with the final video URL and marks production as complete (‚Äúdone‚Äù)\nInputs: Video download response JSON\nOutputs: Triggers video upload node\nEdge cases: Sheet update conflicts, API limits\nUpload Video to BLOTATO\nType: Blotato Node (Community node)\nRole: Uploads the video media URL to Blotato platform, preparing it for TikTok posting\nConfiguration: Uses Blotato API credentials, resource set to \"media\"\nInputs: Final video URL\nOutputs: Provides media URL required by TikTok posting node\nEdge cases: Upload failures, network issues, incorrect credentials\nTikTok\nType: Blotato Node (TikTok integration)\nRole: Creates a TikTok post with the uploaded video and caption from Google Sheets, marking the post as AI-generated\nConfiguration: TikTok platform, account ID parameter, caption text pulled from saved idea metadata, media URL from previous node\nInputs: Uploaded media URL and caption\nOutputs: Triggers status update node\nEdge cases: TikTok API limits, authentication errors, content policy rejections\nUpdate Status to \"DONE\"\nType: Google Sheets Node\nRole: Updates the production status column in Google Sheets to ‚ÄúPublish‚Äù indicating completion of the entire workflow cycle\nInputs: Confirmation from TikTok post node\nOutputs: Workflow ends here for this iteration\nEdge cases: Sheet locking, API errors\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTrigger: Start Daily Content Generation\nSchedule Trigger\nInitiates daily workflow trigger\nNone\nGenerate Creative Video Idea\nTool: Inject Creative Perspective (Idea)\nLangChain Tool (Think)\nAdds creative perspective to AI idea\nTrigger: Start Daily Content Generation\nGenerate Creative Video Idea\nLLM: Generate Raw Idea (GPT-5)\nLangChain LLM Chat OpenAI\nGenerates raw AI idea using GPT-5\nGenerate Creative Video Idea\nGenerate Creative Video Idea\nGenerate Creative Video Idea\nLangChain Agent\nProduces structured video idea JSON\nTool: Inject Creative Perspective, LLM: Generate Raw Idea\nParse AI Output (Idea, Environment, Sound)\nParse AI Output (Idea, Environment, Sound)\nLangChain Output Parser Structured\nParses AI JSON output into structured data\nGenerate Creative Video Idea\nSave Idea & Metadata to Google Sheets\nSave Idea & Metadata to Google Sheets\nGoogle Sheets\nSaves generated idea and metadata\nParse AI Output\nSet Master Prompt\nSet Master Prompt\nSet Node\nDefines master prompt JSON schema\nSave Idea & Metadata to Google Sheets\nAI Agent: Generate Video Script\nAI Agent: Generate Video Script\nLangChain Agent\nGenerates detailed video script prompt\nSet Master Prompt, OpenAI Chat Model, Think, Structured Output Parser\nFormat Prompt\nFormat Prompt\nCode\nFormats prompt JSON string for API\nAI Agent: Generate Video Script\nGenerate Video with VEO3\nGenerate Video with VEO3\nHTTP Request\nCalls VEO 3 API to generate video\nFormat Prompt\nWait for VEO3 Rendering\nWait for VEO3 Rendering\nWait\nWaits fixed time for video rendering\nGenerate Video with VEO3\nDownload Video from VEO3\nDownload Video from VEO3\nHTTP Request\nRetrieves video URL after rendering\nWait for VEO3 Rendering\nURL Final Video\nURL Final Video\nGoogle Sheets\nUpdates Google Sheet with final video URL\nDownload Video from VEO3\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato Node\nUploads video to Blotato for TikTok\nURL Final Video\nTikTok\nTikTok\nBlotato Node\nPosts video to TikTok with caption\nUpload Video to BLOTATO\nUpdate Status to \"DONE\"\nUpdate Status to \"DONE\"\nGoogle Sheets\nMarks production status as complete\nTikTok\nNone\nSticky Note8\nSticky Note\nContains tutorial video, documentation link, and detailed setup instructions\nNone\nNone\nSee links for tutorial and setup:\nhttps://automatisation.notion.site/Generate-AI-Viral-Videos-with-VEO-3-and-Upload-to-TikTok-2703d6550fd980aa9ea1dd7867c1cccf?source=copy_link\nSticky Note\nSticky Note\nExplains workflow purpose and use case\nNone\nNone\nExplains entire workflow‚Äôs problem solving scope\nSticky Note7\nSticky Note\nMarks input idea section\nNone\nNone\nSticky Note9\nSticky Note\nMarks TikTok publish step\nNone\nNone\nSticky Note1\nSticky Note\nMarks VEO3 video generation step\nNone\nNone\n4. Reproducing the Workflow from Scratch\nCreate a Schedule Trigger node\nType: Schedule Trigger\nConfigure to trigger daily (interval: 1 day)\nName: \"Trigger: Start Daily Content Generation\"\nAdd LangChain Think Tool node\nType: LangChain Tool Think\nName: \"Tool: Inject Creative Perspective (Idea)\"\nConnect from Schedule Trigger node\nAdd LangChain Chat OpenAI node\nType: LangChain LLM Chat OpenAI\nModel: GPT-5 mini\nName: \"LLM: Generate Raw Idea (GPT-5)\"\nConnect from Think Tool node\nSet OpenAI credentials with valid API key\nAdd LangChain Agent node for idea generation\nName: \"Generate Creative Video Idea\"\nSet system message with detailed prompt enforcing strict output format (see Block 2.1)\nConnect inputs from LLM: Generate Raw Idea and Think Tool nodes\nAdd LangChain Output Parser Structured node\nName: \"Parse AI Output (Idea, Environment, Sound)\"\nConfigure JSON schema example matching expected AI output structure\nConnect from \"Generate Creative Video Idea\"\nAdd Google Sheets node (append)\nName: \"Save Idea & Metadata to Google Sheets\"\nConfigure document ID and sheet name\nMap columns: id (ROW()-1), idea, caption, production status, environment_prompt, sound_prompt\nConnect from \"Parse AI Output\"\nAdd Set node\nName: \"Set Master Prompt\"\nCreate JSON master prompt variable with detailed cinematic video schema (see Block 2.2)\nSet model to \"veo3_fast\" and aspectRatio to \"9:16\"\nConnect from \"Save Idea & Metadata to Google Sheets\"\nAdd LangChain Agent node for video script generation\nName: \"AI Agent: Generate Video Script\"\nUse system message enforcing output of JSON object with\ntitle\nand\nfinal_prompt\nkeys\nInputs: idea, environment_prompt, sound_prompt from Google Sheets; master prompt from Set node\nConnect from \"Set Master Prompt\" node\nProvide OpenAI GPT-4.1-mini credentials\nAdd Code node\nName: \"Format Prompt\"\nJavaScript code: stringify and escape the\nfinal_prompt\nfor API request (see Block 2.2)\nConnect from \"AI Agent: Generate Video Script\"\nAdd HTTP Request node\nName: \"Generate Video with VEO3\"\nMethod: POST\nURL:\nhttps://api.kie.ai/api/v1/veo/generate\nBody: JSON with keys\nprompt\n,\nmodel\n,\naspectRatio\nusing expressions from \"Format Prompt\"\nAuthentication: HTTP Header Auth with Kie AI API key\nConnect from \"Format Prompt\"\nAdd Wait node\nName: \"Wait for VEO3 Rendering\"\nDuration: 3 minutes\nConnect from \"Generate Video with VEO3\"\nAdd HTTP Request node\nName: \"Download Video from VEO3\"\nMethod: GET\nURL:\nhttps://api.kie.ai/api/v1/veo/record-info\nQuery Parameter:\ntaskId\nfrom previous node response\nAuthentication: HTTP Header Auth with Kie API key\nConnect from \"Wait for VEO3 Rendering\"\nAdd Google Sheets node (update)\nName: \"URL Final Video\"\nUpdates Google Sheet row with final video URL and status \"done\"\nMap columns accordingly\nConnect from \"Download Video from VEO3\"\nAdd Blotato node\nName: \"Upload Video to BLOTATO\"\nResource: media\nMedia URL: from Google Sheets final_output field\nCredentials: Blotato API key\nConnect from \"URL Final Video\"\nAdd Blotato TikTok node\nName: \"TikTok\"\nPlatform: TikTok\nAccount ID: your TikTok account identifier\nPost content text: caption from Google Sheets\nPost content media URLs: URL from Upload Video node\nSet option \"Is AI Generated\"\nCredentials: Blotato API key\nConnect from \"Upload Video to BLOTATO\"\nAdd Google Sheets node (append or update)\nName: \"Update Status to \"DONE\"\"\nUpdate production status to \"Publish\"\nConnect from \"TikTok\"\nAdd Sticky Notes\nAdd notes with setup instructions, tutorial links, and workflow explanations as per original workflow for documentation clarity.\n5. General Notes & Resources\nNote Content\nContext or Link\nüé• Watch This Tutorial on YouTube and access full documentation on Notion for detailed setup and usage instructions.\nYouTube:\nhttps://youtu.be/E-_8KZ_FSeY\nNotion Documentation:\nhttps://automatisation.notion.site/Generate-AI-Viral-Videos-with-VEO-3-and-Upload-to-TikTok-2703d6550fd980aa9ea1dd7867c1cccf?source=copy_link\nWorkflow automates entire viral video production pipeline from AI ideation, video generation with VEO 3, to TikTok publishing via Blotato, saving significant manual time and enabling content scaling.\nGeneral description and use case\nOpenAI API key setup instructions: obtain API key from\nhttps://platform.openai.com/api-keys\n, ensure billing is activated, and add the key to n8n credentials.\nOpenAI API Keys page and billing setup\nVEO 3 (Kie AI) integration requires API key creation on the Kie dashboard with base URL\nhttps://api.kie.ai/api/v1/veo/generate\n. Use HTTP header authentication in n8n.\nKie AI (VEO 3) API documentation\nBlotato node installation instructions for TikTok integration: install community node\n@blotato/n8n-nodes-blotato\n, obtain API key from Blotato, and configure in n8n credentials.\nBlotato Community Node and API key setup\nFor support or customization inquiries, contact Dr. Firas on LinkedIn or YouTube.\nLinkedIn:\nhttps://www.linkedin.com/in/dr-firas/\nYouTube:\nhttps://www.youtube.com/@DRFIRASS\nDisclaimer:\nThis text is exclusively derived from an n8n automated workflow. It fully complies with content policies and contains no illegal, offensive, or protected material. All processed data is legal and publicly available.\nCopied to clipboard",
      "description_full_fr": "Generate AI Viral Videos with VEO 3 and Upload to TikTok\n1. Workflow Overview\nThis workflow automates the creation of viral short-form videos optimized for TikTok using AI-generated concepts and the VEO 3 video generation API. It streamlines the entire content creation pipeline from ideation through video production to publishing on TikTok, enabling users to scale their content output with minimal manual intervention.\nThe workflow is logically divided into three main blocks:\n1.1 Daily Trigger & Idea Generation:\nAutomatically triggers daily to generate a creative video idea using OpenAI GPT-5 and LangChain AI tools, parses structured AI output, and saves metadata to Google Sheets.\n1.2 Video Script Generation & VEO 3 Video Creation:\nBased on the saved idea, an AI agent crafts a detailed video prompt. The prompt is formatted and sent to the VEO 3 API to generate a cinematic vertical video. It includes a wait period to allow rendering, then downloads the finished video.\n1.3 Video Upload & Status Update:\nThe downloaded video URL is stored in Google Sheets, uploaded to Blotato (a TikTok integration node), then posted to TikTok. The production status is updated to reflect completion.\nSupporting nodes include sticky notes with detailed instructions and documentation links.\n2. Block-by-Block Analysis\n2.1 Daily Trigger & Idea Generation\nOverview:\nThis block initiates the workflow on a daily schedule. It generates a creative \"before/after transformation\" video idea using AI, parses the structured output, and records the idea and metadata to a Google Sheet.\nNodes Involved:\nTrigger: Start Daily Content Generation\nTool: Inject Creative Perspective (Idea)\nLLM: Generate Raw Idea (GPT-5)\nGenerate Creative Video Idea (LangChain agent)\nParse AI Output (Idea, Environment, Sound)\nSave Idea & Metadata to Google Sheets\nNode Details:\nTrigger: Start Daily Content Generation\nType: Schedule Trigger\nRole: Automatically triggers the workflow daily (interval set to 1 day)\nInputs: None\nOutputs: Triggers \"Generate Creative Video Idea\" node\nEdge cases: Misconfigured scheduling or disabled workflow can prevent triggering\nTool: Inject Creative Perspective (Idea)\nType: LangChain Tool Node (Think Tool)\nRole: Provides AI with creative perspective to improve idea generation\nInputs: Trigger output\nOutputs: Connected to \"Generate Creative Video Idea\" for enhanced ideation\nEdge cases: AI tool failures or timeouts\nLLM: Generate Raw Idea (GPT-5)\nType: LangChain Chat OpenAI (GPT-5 mini)\nRole: Generates an initial raw before/after transformation idea using GPT-5\nConfiguration: Uses OpenAI API with GPT-5 mini model\nInputs: Invoked by \"Generate Creative Video Idea\"\nOutputs: Raw AI text passed forward\nEdge cases: API quota exceeded, auth errors, model response delays\nGenerate Creative Video Idea\nType: LangChain Agent Node\nRole: Processes raw idea, enriches it with structured rules and formatting for TikTok content\nConfiguration: Complex system message enforcing strict formatting and content rules (e.g., 12 hashtags, emoji, environment, sound prompt)\nInputs: Output from LLM and Think tool nodes\nOutputs: Structured JSON array with keys: Caption, Idea, Environment, Sound, Status\nEdge cases: Parsing errors if AI output does not conform to expected schema\nParse AI Output (Idea, Environment, Sound)\nType: LangChain Structured Output Parser\nRole: Parses the AI-generated JSON array into structured data for further processing\nInputs: AI output string from \"Generate Creative Video Idea\"\nOutputs: Parsed structured JSON with fields usable by downstream nodes\nEdge cases: JSON schema mismatch or malformed AI output\nSave Idea & Metadata to Google Sheets\nType: Google Sheets Node\nRole: Appends the generated idea and metadata (caption, status, prompts) to a Google Sheet for tracking\nConfiguration: Defined column mapping for idea, caption, production status, environment, sound\nInputs: Parsed AI output JSON\nOutputs: Triggers next block (\"Set Master Prompt\")\nEdge cases: Google Sheets API quota, auth expiration, network issues\n2.2 Video Script Generation & VEO 3 Video Creation\nOverview:\nGenerates a detailed video script prompt based on the saved idea metadata, formats it for VEO 3 API consumption, triggers video generation, waits for rendering, and downloads the final video.\nNodes Involved:\nSet Master Prompt\nAI Agent: Generate Video Script\nFormat Prompt\nGenerate Video with VEO3 (HTTP Request)\nWait for VEO3 Rendering\nDownload Video from VEO3\nNode Details:\nSet Master Prompt\nType: Set Node\nRole: Defines a comprehensive JSON master prompt schema describing cinematic video generation parameters such as description, style, camera, lighting, environment, motion, VFX, audio, ending, and format (aspect ratio 9:16)\nConfiguration: Static JSON string assigned to variable\njson_master\nplus model and aspect ratio keys\nInputs: Triggered after saving idea metadata\nOutputs: Passes master prompt to AI Agent node\nEdge cases: Syntax errors in JSON, missing fields affecting downstream processing\nAI Agent: Generate Video Script\nType: LangChain Agent Node\nRole: Uses the previously saved idea, environment, and sound prompts to generate a detailed VEO 3-compatible video prompt JSON with fields such as BEFORE scene, AFTER scene, TRANSITION, CAMERA, LIGHTING, PALETTE, STYLE, and SOUND\nConfiguration: System prompt enforcing strict JSON output with only two top-level keys:\ntitle\nand\nfinal_prompt\n(stringified JSON)\nInputs: Idea metadata + master prompt\nOutputs: Structured AI JSON object parsed by next node\nEdge cases: AI output formatting errors, token limit issues, API failures\nFormat Prompt\nType: Code Node (JavaScript)\nRole: Converts the AI agent‚Äôs JSON output into a single JSON string escaped properly to be used as the\nprompt\nparameter for VEO 3 API\nInputs: AI Agent output\nOutputs: Prepared HTTP request body fields (prompt, model, aspectRatio)\nEdge cases: JSON stringify errors, null inputs\nGenerate Video with VEO3\nType: HTTP Request Node\nRole: Sends POST request to VEO 3 API\nhttps://api.kie.ai/api/v1/veo/generate\nto start video generation with the crafted prompt\nConfiguration: Uses HTTP Header Authentication with Kie AI credentials\nInputs: Formatted prompt and model/aspect ratio settings\nOutputs: Returns a\ntaskId\nfor video rendering tracking\nEdge cases: API rate limits, auth token expiration, request timeouts\nWait for VEO3 Rendering\nType: Wait Node\nRole: Pauses workflow execution for 3 minutes to allow VEO 3 to process and render the video\nInputs: Triggered after video generation request\nOutputs: After wait, triggers download node\nEdge cases: Fixed wait time may be insufficient for longer renders\nDownload Video from VEO3\nType: HTTP Request Node\nRole: Queries\nhttps://api.kie.ai/api/v1/veo/record-info\nwith\ntaskId\nto retrieve rendering status and download URL of the generated video\nConfiguration: HTTP Header Authentication with Kie AI credentials\nInputs: taskId from generation response\nOutputs: Returns JSON containing final video URLs\nEdge cases: Video not ready yet, API errors, malformed responses\n2.3 Video Upload & Status Update\nOverview:\nStores the final video URL in Google Sheets, uploads the video to Blotato for TikTok, posts the video to TikTok, and updates the production status in Google Sheets to ‚ÄúDONE‚Äù.\nNodes Involved:\nURL Final Video (Google Sheets)\nUpload Video to BLOTATO\nTikTok (Blotato node)\nUpdate Status to \"DONE\" (Google Sheets)\nNode Details:\nURL Final Video\nType: Google Sheets Node\nRole: Updates the same row in Google Sheets with the final video URL and marks production as complete (‚Äúdone‚Äù)\nInputs: Video download response JSON\nOutputs: Triggers video upload node\nEdge cases: Sheet update conflicts, API limits\nUpload Video to BLOTATO\nType: Blotato Node (Community node)\nRole: Uploads the video media URL to Blotato platform, preparing it for TikTok posting\nConfiguration: Uses Blotato API credentials, resource set to \"media\"\nInputs: Final video URL\nOutputs: Provides media URL required by TikTok posting node\nEdge cases: Upload failures, network issues, incorrect credentials\nTikTok\nType: Blotato Node (TikTok integration)\nRole: Creates a TikTok post with the uploaded video and caption from Google Sheets, marking the post as AI-generated\nConfiguration: TikTok platform, account ID parameter, caption text pulled from saved idea metadata, media URL from previous node\nInputs: Uploaded media URL and caption\nOutputs: Triggers status update node\nEdge cases: TikTok API limits, authentication errors, content policy rejections\nUpdate Status to \"DONE\"\nType: Google Sheets Node\nRole: Updates the production status column in Google Sheets to ‚ÄúPublish‚Äù indicating completion of the entire workflow cycle\nInputs: Confirmation from TikTok post node\nOutputs: Workflow ends here for this iteration\nEdge cases: Sheet locking, API errors\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTrigger: Start Daily Content Generation\nSchedule Trigger\nInitiates daily workflow trigger\nNone\nGenerate Creative Video Idea\nTool: Inject Creative Perspective (Idea)\nLangChain Tool (Think)\nAdds creative perspective to AI idea\nTrigger: Start Daily Content Generation\nGenerate Creative Video Idea\nLLM: Generate Raw Idea (GPT-5)\nLangChain LLM Chat OpenAI\nGenerates raw AI idea using GPT-5\nGenerate Creative Video Idea\nGenerate Creative Video Idea\nGenerate Creative Video Idea\nLangChain Agent\nProduces structured video idea JSON\nTool: Inject Creative Perspective, LLM: Generate Raw Idea\nParse AI Output (Idea, Environment, Sound)\nParse AI Output (Idea, Environment, Sound)\nLangChain Output Parser Structured\nParses AI JSON output into structured data\nGenerate Creative Video Idea\nSave Idea & Metadata to Google Sheets\nSave Idea & Metadata to Google Sheets\nGoogle Sheets\nSaves generated idea and metadata\nParse AI Output\nSet Master Prompt\nSet Master Prompt\nSet Node\nDefines master prompt JSON schema\nSave Idea & Metadata to Google Sheets\nAI Agent: Generate Video Script\nAI Agent: Generate Video Script\nLangChain Agent\nGenerates detailed video script prompt\nSet Master Prompt, OpenAI Chat Model, Think, Structured Output Parser\nFormat Prompt\nFormat Prompt\nCode\nFormats prompt JSON string for API\nAI Agent: Generate Video Script\nGenerate Video with VEO3\nGenerate Video with VEO3\nHTTP Request\nCalls VEO 3 API to generate video\nFormat Prompt\nWait for VEO3 Rendering\nWait for VEO3 Rendering\nWait\nWaits fixed time for video rendering\nGenerate Video with VEO3\nDownload Video from VEO3\nDownload Video from VEO3\nHTTP Request\nRetrieves video URL after rendering\nWait for VEO3 Rendering\nURL Final Video\nURL Final Video\nGoogle Sheets\nUpdates Google Sheet with final video URL\nDownload Video from VEO3\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato Node\nUploads video to Blotato for TikTok\nURL Final Video\nTikTok\nTikTok\nBlotato Node\nPosts video to TikTok with caption\nUpload Video to BLOTATO\nUpdate Status to \"DONE\"\nUpdate Status to \"DONE\"\nGoogle Sheets\nMarks production status as complete\nTikTok\nNone\nSticky Note8\nSticky Note\nContains tutorial video, documentation link, and detailed setup instructions\nNone\nNone\nSee links for tutorial and setup:\nhttps://automatisation.notion.site/Generate-AI-Viral-Videos-with-VEO-3-and-Upload-to-TikTok-2703d6550fd980aa9ea1dd7867c1cccf?source=copy_link\nSticky Note\nSticky Note\nExplains workflow purpose and use case\nNone\nNone\nExplains entire workflow‚Äôs problem solving scope\nSticky Note7\nSticky Note\nMarks input idea section\nNone\nNone\nSticky Note9\nSticky Note\nMarks TikTok publish step\nNone\nNone\nSticky Note1\nSticky Note\nMarks VEO3 video generation step\nNone\nNone\n4. Reproducing the Workflow from Scratch\nCreate a Schedule Trigger node\nType: Schedule Trigger\nConfigure to trigger daily (interval: 1 day)\nName: \"Trigger: Start Daily Content Generation\"\nAdd LangChain Think Tool node\nType: LangChain Tool Think\nName: \"Tool: Inject Creative Perspective (Idea)\"\nConnect from Schedule Trigger node\nAdd LangChain Chat OpenAI node\nType: LangChain LLM Chat OpenAI\nModel: GPT-5 mini\nName: \"LLM: Generate Raw Idea (GPT-5)\"\nConnect from Think Tool node\nSet OpenAI credentials with valid API key\nAdd LangChain Agent node for idea generation\nName: \"Generate Creative Video Idea\"\nSet system message with detailed prompt enforcing strict output format (see Block 2.1)\nConnect inputs from LLM: Generate Raw Idea and Think Tool nodes\nAdd LangChain Output Parser Structured node\nName: \"Parse AI Output (Idea, Environment, Sound)\"\nConfigure JSON schema example matching expected AI output structure\nConnect from \"Generate Creative Video Idea\"\nAdd Google Sheets node (append)\nName: \"Save Idea & Metadata to Google Sheets\"\nConfigure document ID and sheet name\nMap columns: id (ROW()-1), idea, caption, production status, environment_prompt, sound_prompt\nConnect from \"Parse AI Output\"\nAdd Set node\nName: \"Set Master Prompt\"\nCreate JSON master prompt variable with detailed cinematic video schema (see Block 2.2)\nSet model to \"veo3_fast\" and aspectRatio to \"9:16\"\nConnect from \"Save Idea & Metadata to Google Sheets\"\nAdd LangChain Agent node for video script generation\nName: \"AI Agent: Generate Video Script\"\nUse system message enforcing output of JSON object with\ntitle\nand\nfinal_prompt\nkeys\nInputs: idea, environment_prompt, sound_prompt from Google Sheets; master prompt from Set node\nConnect from \"Set Master Prompt\" node\nProvide OpenAI GPT-4.1-mini credentials\nAdd Code node\nName: \"Format Prompt\"\nJavaScript code: stringify and escape the\nfinal_prompt\nfor API request (see Block 2.2)\nConnect from \"AI Agent: Generate Video Script\"\nAdd HTTP Request node\nName: \"Generate Video with VEO3\"\nMethod: POST\nURL:\nhttps://api.kie.ai/api/v1/veo/generate\nBody: JSON with keys\nprompt\n,\nmodel\n,\naspectRatio\nusing expressions from \"Format Prompt\"\nAuthentication: HTTP Header Auth with Kie AI API key\nConnect from \"Format Prompt\"\nAdd Wait node\nName: \"Wait for VEO3 Rendering\"\nDuration: 3 minutes\nConnect from \"Generate Video with VEO3\"\nAdd HTTP Request node\nName: \"Download Video from VEO3\"\nMethod: GET\nURL:\nhttps://api.kie.ai/api/v1/veo/record-info\nQuery Parameter:\ntaskId\nfrom previous node response\nAuthentication: HTTP Header Auth with Kie API key\nConnect from \"Wait for VEO3 Rendering\"\nAdd Google Sheets node (update)\nName: \"URL Final Video\"\nUpdates Google Sheet row with final video URL and status \"done\"\nMap columns accordingly\nConnect from \"Download Video from VEO3\"\nAdd Blotato node\nName: \"Upload Video to BLOTATO\"\nResource: media\nMedia URL: from Google Sheets final_output field\nCredentials: Blotato API key\nConnect from \"URL Final Video\"\nAdd Blotato TikTok node\nName: \"TikTok\"\nPlatform: TikTok\nAccount ID: your TikTok account identifier\nPost content text: caption from Google Sheets\nPost content media URLs: URL from Upload Video node\nSet option \"Is AI Generated\"\nCredentials: Blotato API key\nConnect from \"Upload Video to BLOTATO\"\nAdd Google Sheets node (append or update)\nName: \"Update Status to \"DONE\"\"\nUpdate production status to \"Publish\"\nConnect from \"TikTok\"\nAdd Sticky Notes\nAdd notes with setup instructions, tutorial links, and workflow explanations as per original workflow for documentation clarity.\n5. General Notes & Resources\nNote Content\nContext or Link\nüé• Watch This Tutorial on YouTube and access full documentation on Notion for detailed setup and usage instructions.\nYouTube:\nhttps://youtu.be/E-_8KZ_FSeY\nNotion Documentation:\nhttps://automatisation.notion.site/Generate-AI-Viral-Videos-with-VEO-3-and-Upload-to-TikTok-2703d6550fd980aa9ea1dd7867c1cccf?source=copy_link\nWorkflow automates entire viral video production pipeline from AI ideation, video generation with VEO 3, to TikTok publishing via Blotato, saving significant manual time and enabling content scaling.\nGeneral description and use case\nOpenAI API key setup instructions: obtain API key from\nhttps://platform.openai.com/api-keys\n, ensure billing is activated, and add the key to n8n credentials.\nOpenAI API Keys page and billing setup\nVEO 3 (Kie AI) integration requires API key creation on the Kie dashboard with base URL\nhttps://api.kie.ai/api/v1/veo/generate\n. Use HTTP header authentication in n8n.\nKie AI (VEO 3) API documentation\nBlotato node installation instructions for TikTok integration: install community node\n@blotato/n8n-nodes-blotato\n, obtain API key from Blotato, and configure in n8n credentials.\nBlotato Community Node and API key setup\nFor support or customization inquiries, contact Dr. Firas on LinkedIn or YouTube.\nLinkedIn:\nhttps://www.linkedin.com/in/dr-firas/\nYouTube:\nhttps://www.youtube.com/@DRFIRASS\nDisclaimer:\nThis text is exclusively derived from an n8n automated workflow. It fully complies with content policies and contains no illegal, offensive, or protected material. All processed data is legal and publicly available.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Dr. Firas",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/generate-ai-viral-videos-with-veo-3-and-upload-to-tiktok-8642",
      "nodes_count": 24
    },
    {
      "id": "002",
      "slug": "crez-automatiquement-des-vidos-tiktok-avec-les-avatars-veedio-ai-elevenlabs-et-gpt-4",
      "title_en": "Auto-Create TikTok Videos with VEED.io AI Avatars, ElevenLabs & GPT-4",
      "title_fr": "Cr√©ez automatiquement des vid√©os TikTok avec les avatars VEED.io AI, ElevenLabs et GPT-4",
      "description_short_en": "Auto-create viral TikTok videos with your AI avatar‚Äîno filming needed. Trend analysis, voiceover, captions & posting, all in one seamless workflow. Learn more!",
      "description_short_fr": "Cr√©ez automatiquement des vid√©os virales TikTok avec votre avatar IA, aucun tournage n'est n√©cessaire. Analyse des tendances, voix off, sous-titres et publication, le tout dans un seul flux de travail transparent. Apprendre encore plus!",
      "description_full_en": "Auto-Create TikTok Videos with VEED.io AI Avatars, ElevenLabs & GPT-4\n1. Workflow Overview\nThis workflow automates the creation and publishing of viral TikTok videos using a photo and theme input sent via Telegram. It leverages AI technologies including Perplexity for trend research, GPT-4 for script and caption generation, ElevenLabs for voice synthesis, and FAL.ai (VEED.io) for video creation from images and audio. Finally, it publishes the generated content across multiple social platforms and logs the data in Google Sheets.\nThe workflow is logically grouped into these blocks:\n1.1 Input Reception:\nReceives photo and caption/theme via Telegram.\n1.2 Trend Research:\nUses Perplexity API to identify trending topics related to the input theme.\n1.3 Script Generation:\nGPT-4 creates a short viral TikTok script based on trends.\n1.4 Voice Synthesis:\nElevenLabs converts the script text to natural speech audio.\n1.5 Audio and Image Upload:\nUploads audio and photo to public URLs for processing.\n1.6 Video Generation:\nFAL.ai generates a talking video using the photo and synthesized audio.\n1.7 Caption Generation:\nGPT-4 composes an engaging TikTok caption with hashtags.\n1.8 Data Logging:\nSaves all media URLs, captions, and status to Google Sheets for tracking.\n1.9 Publishing:\nPublishes the video and caption to TikTok and other social media using the Blotato node.\n1.10 Status Update:\nMarks the workflow run as DONE in the Google Sheet.\n1.11 User Guidance:\nSticky notes provide setup instructions and explanations.\n2. Block-by-Block Analysis\n1.1 Input Reception\nOverview:\nStarts the workflow by triggering on incoming Telegram messages containing a photo and optional caption/theme.\nNodes Involved:\nTelegram Trigger\nWorkflow Configuration\nExtract Photo and Theme\nGet Photo File from Telegram\nNode Details:\nTelegram Trigger\nType: Telegram Trigger\nRole: Listens for new Telegram messages (photo with caption or text) to start workflow.\nConfiguration: Triggers on \"message\" updates only. Uses Telegram API credentials.\nInputs: Telegram messages\nOutputs: Message JSON including photo file IDs and captions\nEdge Cases: Missing photo or caption leads to empty variables; no trigger if message is not a photo or text.\nWorkflow Configuration\nType: Set\nRole: Sets essential API keys and configuration variables (ElevenLabs API key, voice ID, FAL.ai API key, script max duration, Perplexity model).\nConfiguration: Static assignment of credentials and parameters to workflow context.\nInputs: Trigger output\nOutputs: JSON with configuration variables\nEdge Cases: Missing or invalid API keys will cause downstream API calls to fail.\nExtract Photo and Theme\nType: Set\nRole: Extracts the Telegram photo file ID and theme (caption or text) from the incoming message.\nConfiguration:\nphotoUrl: last photo file_id if any, else empty string\ntheme: message caption or text or defaults to \"viral content\"\nInputs: Workflow Configuration output\nOutputs: JSON with photoUrl and theme\nEdge Cases: No photo attached results in empty photoUrl; empty theme defaults to \"viral content\".\nGet Photo File from Telegram\nType: Telegram\nRole: Downloads the actual photo file from Telegram servers using the file ID.\nConfiguration: Uses photoUrl extracted above as fileId parameter.\nInputs: Extract Photo and Theme output\nOutputs: Binary photo file data\nEdge Cases: Telegram API failures, invalid file ID, or missing photo cause download failure.\n1.2 Trend Research\nOverview:\nQueries Perplexity API to find top 3 current viral TikTok trends related to the photo caption/theme.\nNodes Involved:\nBuild Public Image URL\nSearch Trends with Perplexity\nNode Details:\nBuild Public Image URL\nType: HTTP Request (POST multipart-form-data)\nRole: Uploads the downloaded photo binary to tmpfiles.org to get a public URL.\nConfiguration: Uploads photo binary under \"data\" field.\nInputs: Get Photo File from Telegram output (binary photo)\nOutputs: JSON containing public URL for the image\nEdge Cases: Upload failures or temporary URL downtime.\nSearch Trends with Perplexity\nType: Perplexity API\nRole: Performs AI-powered search for top 3 viral trends on TikTok related to the photo‚Äôs theme.\nConfiguration:\nModel: dynamically set from Workflow Configuration (e.g., \"sonar\")\nPrompt: Finds top 3 viral trends, hashtags, content styles related to caption.\nInputs: Build Public Image URL output (uses caption from Extract Photo and Theme)\nOutputs: JSON with trends as string content in response\nEdge Cases: API rate limits, invalid API key, or no relevant trends found.\n1.3 Script Generation\nOverview:\nGenerates a concise, engaging TikTok script (max 30 seconds) based on the trends found.\nNodes Involved:\nGenerate Script with GPT-4\nNode Details:\nGenerate Script with GPT-4\nType: OpenAI API (GPT-4) via LangChain node\nRole: Creates a viral TikTok script using the trend data and theme.\nConfiguration:\nModel: \"gpt-4o-mini\" (GPT-4 optimized)\nPrompt instructs to create a max 30-second script with a hook, conversational style optimized for voice synthesis.\nInputs: Search Trends with Perplexity output (trends content) and Extract Photo and Theme (theme)\nOutputs: JSON with generated script text\nEdge Cases: API quota exceeded, prompt failures, or nonsensical script output.\n1.4 Voice Synthesis\nOverview:\nConverts the generated script text into natural sounding speech audio (MP3) via ElevenLabs API.\nNodes Involved:\nElevenLabs Voice Synthesis\nConvert .mpga to .mp3\nUpload Audio to Public URL\nNode Details:\nElevenLabs Voice Synthesis\nType: HTTP Request (POST)\nRole: Sends script text to ElevenLabs TTS API to generate voice audio.\nConfiguration:\nURL composed dynamically with voice ID from Workflow Configuration\nJSON body includes text, model id \"eleven_multilingual_v2\", voice stability and similarity settings\nHeaders include xi-api-key for authentication\nInputs: Generate Script with GPT-4 output (script text)\nOutputs: Binary audio in MPGA format (audio/mpeg)\nEdge Cases: API key invalid, network timeout, audio format issues.\nConvert .mpga to .mp3\nType: Code\nRole: Renames binary audio file extension from .mpga to .mp3 and sets MIME type.\nConfiguration: JavaScript code updates binary property name and metadata.\nInputs: ElevenLabs Voice Synthesis binary audio\nOutputs: Binary audio renamed as .mp3\nEdge Cases: Missing binary data causes no conversion.\nUpload Audio to Public URL\nType: HTTP Request (POST multipart-form-data)\nRole: Uploads the mp3 audio file to tmpfiles.org to get a public URL.\nConfiguration: Form data includes the mp3 binary under \"file\".\nInputs: Convert .mpga to .mp3 output (binary audio_mp3)\nOutputs: JSON with public audio URL\nEdge Cases: Upload failure or URL expiration.\n1.5 Video Generation\nOverview:\nGenerates a lip-synced talking video using the uploaded photo and audio via FAL.ai (VEED Fabric 1.0 model).\nNodes Involved:\nFAL.ai Video Generation\nWait for VEED\nDownload VEED Video\nNode Details:\nFAL.ai Video Generation\nType: HTTP Request (POST)\nRole: Sends a request to FAL.ai endpoint to generate video with image and audio URLs.\nConfiguration:\nJSON body includes public image and audio URLs (converted to tmpfiles.org download links), resolution set to 480p\nAuthorization header uses FAL API key from Workflow Configuration\nInputs: Upload Audio to Public URL output (audio URL) and Build Public Image URL (image URL)\nOutputs: JSON response with request_id for video generation\nEdge Cases: API errors, invalid URLs, or processing delays.\nWait for VEED\nType: Wait\nRole: Pauses workflow for 10 minutes to allow video processing to complete asynchronously.\nConfiguration: Wait duration set to 10 minutes\nInputs: FAL.ai Video Generation output\nOutputs: Passes data forward after delay\nEdge Cases: Fixed wait time may be inefficient if processing is faster/slower.\nDownload VEED Video\nType: HTTP Request (GET)\nRole: Retrieves the generated video file from FAL.ai using the request_id.\nConfiguration:\nURL dynamically built with request_id from previous node\nAuthorization header with FAL API key\nInputs: Wait for VEED output\nOutputs: JSON containing video URL\nEdge Cases: Video not ready, 404 errors, or API failures.\n1.6 Caption Generation\nOverview:\nCreates an engaging TikTok caption optimized for algorithms, including trending hashtags.\nNodes Involved:\nGenerate Caption with GPT-4\nNode Details:\nGenerate Caption with GPT-4\nType: OpenAI API (GPT-4) via LangChain node\nRole: Generates a catchy caption based on the theme and discovered trends.\nConfiguration:\nModel: \"gpt-4o-mini\"\nPrompt requests a catchy hook, 5-8 trending hashtags, concise and engaging text optimized for TikTok.\nInputs: Download VEED Video output (to confirm video is ready), Extract Photo and Theme, Search Trends with Perplexity (trends)\nOutputs: Caption text JSON\nEdge Cases: API quota, prompt failure, or irrelevant captions.\n1.7 Data Logging\nOverview:\nSaves the idea, caption, media URLs, and workflow status into a Google Sheets document for tracking.\nNodes Involved:\nSave to Google Sheets\nUpdate Status to \"DONE\"\nNode Details:\nSave to Google Sheets\nType: Google Sheets node\nRole: Appends new row with the TikTok idea (caption), generated caption text, audio/image/video URLs.\nConfiguration:\nDocument ID and Sheet Name dynamically set\nMapping fields: IDEA, CAPTION, URL AUDIO, URL IMAGE, URL VIDEO\nInputs: Generate Caption with GPT-4 output\nOutputs: Confirmation of row addition with data\nEdge Cases: Google API auth failures, quota exceeded, or invalid sheet format.\nUpdate Status to \"DONE\"\nType: Google Sheets node\nRole: Updates the STATUS field to \"DONE\" for the processed video entry.\nConfiguration:\nMatches rows based on URL VIDEO\nAppends or updates existing rows\nInputs: Merge node output (after publishing)\nOutputs: Confirmation of update\nEdge Cases: Mismatched URL keys, Google API errors.\n1.8 Publishing\nOverview:\nUploads the generated video and caption to TikTok and multiple other social media platforms via the Blotato community node.\nNodes Involved:\nSend a video (Telegram)\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nThreads\nBluesky\nPinterest\nMerge1\nNode Details:\nSend a video (Telegram)\nType: Telegram\nRole: Sends the generated video back to the user on Telegram chat.\nConfiguration: Uses chat ID from Telegram Trigger node and video URL from Google Sheets data.\nInputs: Save to Google Sheets output\nOutputs: Confirmation of video sent\nEdge Cases: Telegram API limits or invalid chat ID.\nUpload Video to BLOTATO\nType: Blotato Node (Community)\nRole: Uploads video to Blotato platform for social media publishing.\nConfiguration: Uses video URL from Google Sheets data.\nInputs: Save to Google Sheets output\nOutputs: Media ID for publishing nodes\nEdge Cases: Blotato API auth errors or upload failures.\nSocial Media Publishing Nodes (Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest)\nType: Blotato Node (Community)\nRole: Publishes the video with caption to respective platform using Blotato API.\nConfiguration:\nPlatform specified (e.g., \"tiktok\")\nAccount ID selected from cached accounts\nCaption text from Google Sheets\nMedia URL from Upload Video to BLOTATO node\nInputs: Upload Video to BLOTATO output\nOutputs: Post confirmation\nEdge Cases: Credential expiry, platform posting limits, content policy rejection.\nMerge1\nType: Merge\nRole: Combines outputs from all social media publishing nodes to continue workflow.\nConfiguration: Choose branch mode with 9 inputs\nInputs: All social publishing nodes\nOutputs: Combined data for status update\nEdge Cases: Partial publishing failures or node errors.\n1.9 User Guidance\nOverview:\nSticky notes provide detailed setup instructions and explanations for each step of the workflow including API key configuration, Telegram bot setup, AI processing, voice/video generation, publishing, and usage flow.\nNodes Involved:\nSetup Guide - Start Here\nStep 1 - Telegram Setup\nStep 2 - API Keys Configuration\nStep 3 - AI Processing\nStep 4 - Voice & Video Generation\nStep 5 - Publishing\nHow It Works\nNode Details:\nAll are sticky note nodes with detailed textual instructions and helpful links for setting up the workflow and credentials. They guide users through:\nCreating Telegram bot and setting up trigger.\nConfiguring all required API keys (ElevenLabs, FAL.ai, OpenAI, Perplexity, Google Sheets).\nAI nodes usage and models.\nVoice and video generation details.\nPublishing via Blotato node community plugin with supported platforms.\nOverall workflow operation and expected results.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nStart workflow on Telegram message\n-\nWorkflow Configuration\n# üì± STEP 1: TELEGRAM BOT SETUP (detailed setup instructions)\nWorkflow Configuration\nSet\nStores API keys and config variables\nTelegram Trigger\nExtract Photo and Theme\n# üîë STEP 2: API KEYS CONFIGURATION (API keys setup instructions)\nExtract Photo and Theme\nSet\nExtract photo file ID and theme\nWorkflow Configuration\nGet Photo File from Telegram\nGet Photo File from Telegram\nTelegram\nDownloads photo from Telegram\nExtract Photo and Theme\nBuild Public Image URL\nBuild Public Image URL\nHTTP Request\nUploads photo to public URL\nGet Photo File from Telegram\nSearch Trends with Perplexity\nSearch Trends with Perplexity\nPerplexity API\nFinds viral TikTok trends\nBuild Public Image URL\nGenerate Script with GPT-4\n# ü§ñ STEP 3: AI PROCESSING SETUP (Perplexity and OpenAI details)\nGenerate Script with GPT-4\nOpenAI (LangChain)\nCreates TikTok script\nSearch Trends with Perplexity\nElevenLabs Voice Synthesis\nElevenLabs Voice Synthesis\nHTTP Request\nConverts script text to speech\nGenerate Script with GPT-4\nConvert .mpga to .mp3\n# üé¨ STEP 4: VOICE & VIDEO GENERATION (ElevenLabs and FAL.ai APIs explanation)\nConvert .mpga to .mp3\nCode\nRenames audio binary to .mp3\nElevenLabs Voice Synthesis\nUpload Audio to Public URL\nUpload Audio to Public URL\nHTTP Request\nUploads audio file to public URL\nConvert .mpga to .mp3\nFAL.ai Video Generation\nFAL.ai Video Generation\nHTTP Request\nRequests talking video generation\nUpload Audio to Public URL\nWait for VEED\nWait for VEED\nWait\nWaits for video processing\nFAL.ai Video Generation\nDownload VEED Video\nDownload VEED Video\nHTTP Request\nDownloads generated video\nWait for VEED\nGenerate Caption with GPT-4\nGenerate Caption with GPT-4\nOpenAI (LangChain)\nCreates TikTok caption\nDownload VEED Video\nSave to Google Sheets\nSave to Google Sheets\nGoogle Sheets\nLogs idea, caption, media URLs\nGenerate Caption with GPT-4\nSend a video, Upload Video to BLOTATO\nSend a video\nTelegram\nSends generated video on Telegram\nSave to Google Sheets\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato Node\nUploads video for social publishing\nSave to Google Sheets\nSocial media publishing nodes\n# üì§ STEP 5: PUBLISHING & TRACKING (Blotato installation and publishing instructions)\nTiktok\nBlotato Node\nPublishes video to TikTok\nUpload Video to BLOTATO\nMerge1\nLinkedin\nBlotato Node\nPublishes video to LinkedIn\nUpload Video to BLOTATO\nMerge1\nFacebook\nBlotato Node\nPublishes video to Facebook\nUpload Video to BLOTATO\nMerge1\nInstagram\nBlotato Node\nPublishes video to Instagram\nUpload Video to BLOTATO\nMerge1\nTwitter (X)\nBlotato Node\nPublishes video to Twitter (X)\nUpload Video to BLOTATO\nMerge1\nYoutube\nBlotato Node\nPublishes video to YouTube\nUpload Video to BLOTATO\nMerge1\nThreads\nBlotato Node\nPublishes video to Threads\nUpload Video to BLOTATO\nMerge1\nBluesky\nBlotato Node\nPublishes video to Bluesky\nUpload Video to BLOTATO\nMerge1\nPinterest\nBlotato Node\nPublishes video to Pinterest\nUpload Video to BLOTATO\nMerge1\nMerge1\nMerge\nCombines all social publishing outputs\nAll social publishing nodes\nUpdate Status to \"DONE\"\nUpdate Status to \"DONE\"\nGoogle Sheets\nUpdates Google Sheet status to DONE\nMerge1\n-\nSetup Guide - Start Here\nSticky Note\nProvides full setup guide\n-\n-\nContains full setup guide, tutorial links, and contact info.\nStep 1 - Telegram Setup\nSticky Note\nTelegram bot setup instructions\n-\n-\nDetailed Telegram bot creation and trigger node instructions.\nStep 2 - API Keys Configuration\nSticky Note\nAPI keys configuration instructions\n-\n-\nInstructions to set ElevenLabs, FAL.ai, and other API keys.\nStep 3 - AI Processing\nSticky Note\nAI nodes setup guidance\n-\n-\nDetails on Perplexity, OpenAI, and FAL.ai API usage.\nStep 4 - Voice & Video Generation\nSticky Note\nVoice and video generation overview\n-\n-\nExplains ElevenLabs and FAL.ai nodes, no config needed.\nStep 5 - Publishing\nSticky Note\nPublishing & tracking instructions\n-\n-\nBlotato node installation and publishing setup instructions with links.\nHow It Works\nSticky Note\nWorkflow flow summary\n-\n-\nStepwise functional overview with timing and usage example.\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger Node\nType: Telegram Trigger\nSet to trigger on \"message\" updates (photo or text).\nAdd Telegram API credentials (Bot token).\nActivate webhook.\nAdd Workflow Configuration Node (Set)\nCreate a \"Set\" node to store:\nelevenLabsApiKey\n(string)\nelevenLabsVoiceId\n(string)\nfalApiKey\n(string)\nscriptMaxDuration\n(number, default 30)\nperplexityModel\n(string, e.g., \"sonar\")\nNo input required; connects from Telegram Trigger.\nAdd Extract Photo and Theme Node (Set)\nExtract last photo file_id from incoming message JSON:\n{{$json.message.photo ? $json.message.photo[$json.message.photo.length - 1].file_id : ''}}\nExtract theme from caption or text or default \"viral content\":\n{{$json.message.caption || $json.message.text || 'viral content'}}\nConnect from Workflow Configuration node.\nAdd Get Photo File from Telegram Node\nType: Telegram\nResource: File\nParameter:\nfileId\nset to\n{{$json.photoUrl}}\nUse Telegram API credentials\nConnect from Extract Photo and Theme.\nAdd Build Public Image URL Node (HTTP Request)\nMethod: POST\nURL:\nhttps://tmpfiles.org/api/v1/upload\nBody: multipart-form-data, field name \"data\" with binary photo file from previous node\nResponse format: JSON expected\nConnect from Get Photo File from Telegram.\nAdd Search Trends with Perplexity Node\nUse Perplexity API node with API key credentials\nModel: set from Workflow Configuration node (e.g.,\n{{$node[\"Workflow Configuration\"].json.perplexityModel}}\n)\nMessage prompt: \"Find top 3 current viral trends related to: {{caption}}...\" (use caption from Extract Photo and Theme)\nConnect from Build Public Image URL.\nAdd Generate Script with GPT-4 Node (OpenAI)\nUse OpenAI API credentials\nModel: \"gpt-4o-mini\"\nPrompt: Create viral 30-second TikTok script based on trends and theme, with hook and optimized for voice synthesis.\nConnect from Search Trends with Perplexity.\nAdd ElevenLabs Voice Synthesis Node (HTTP Request)\nPOST to\nhttps://api.elevenlabs.io/v1/text-to-speech/{voiceId}\nwhere voiceId from Workflow Configuration\nBody JSON:\n{text: script text, model_id: \"eleven_multilingual_v2\", voice_settings: {...}}\nHeaders: xi-api-key from Workflow Configuration, Content-Type\napplication/json\n, Accept\naudio/mpeg\nConnect from Generate Script with GPT-4.\nAdd Convert .mpga to .mp3 Node (Code)\nJavaScript code to rename binary audio file extension from .mpga to .mp3 and set MIME type\nConnect from ElevenLabs Voice Synthesis.\nAdd Upload Audio to Public URL Node (HTTP Request)\nPOST to\nhttps://tmpfiles.org/api/v1/upload\nmultipart-form-data with \"file\" field from previous node binary audio_mp3\nResponse: JSON\nConnect from Convert .mpga to .mp3.\nAdd FAL.ai Video Generation Node (HTTP Request)\nPOST to\nhttps://queue.fal.run/veed/fabric-1.0\nHeader Authorization with FAL API key from Workflow Configuration\nBody JSON with:\nimage_url: public image URL replacing tmpfiles.org link to download link\naudio_url: public audio URL replacing tmpfiles.org link to download link\nresolution: \"480p\"\nConnect from Upload Audio to Public URL.\nAdd Wait for VEED Node (Wait)\nWait 10 minutes for video generation\nConnect from FAL.ai Video Generation.\nAdd Download VEED Video Node (HTTP Request)\nGET to\nhttps://queue.fal.run/veed/fabric-1.0/requests/{request_id}\nfrom previous node response\nHeader Authorization with FAL API key\nConnect from Wait for VEED.\nAdd Generate Caption with GPT-4 Node (OpenAI)\nUse OpenAI API credentials\nModel: \"gpt-4o-mini\"\nPrompt: Create engaging caption with trending hashtags based on theme and trends\nConnect from Download VEED Video.\nAdd Save to Google Sheets Node\nGoogle Sheets OAuth2 credential setup\nDocument ID and Sheet Name configured\nAppend row with columns: IDEA (caption), CAPTION (generated caption), URL AUDIO, URL IMAGE, URL VIDEO\nConnect from Generate Caption with GPT-4.\nAdd Send a video Node (Telegram)\nOperation: Send Video\nChat ID from Telegram Trigger message chat id\nFile URL from Google Sheets URL VIDEO column\nConnect from Save to Google Sheets.\nAdd Upload Video to BLOTATO Node\nUse Blotato API credentials\nUpload video URL from Google Sheets URL VIDEO\nConnect from Save to Google Sheets.\nAdd Social Media Publishing Nodes (Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest)\nUse Blotato API credentials\nPlatform set accordingly\nAccount IDs selected from dashboard\nCaption text from Google Sheets CAPTION\nMedia URL from Upload Video to BLOTATO\nAll connect from Upload Video to BLOTATO node.\nAdd Merge Node (Merge1)\nMode: Choose Branch\nInputs: all social publishing nodes (9 inputs)\nConnect all social publishing nodes outputs to Merge1.\nAdd Update Status to \"DONE\" Node (Google Sheets)\nGoogle Sheets OAuth2 configured\nAppend or update row matching on URL VIDEO column\nSet STATUS field to \"DONE\"\nConnect from Merge1 output.\nAdd Sticky Notes\nAdd multiple sticky notes for guidance:\nSetup Guide - Start Here\nStep 1 - Telegram Setup\nStep 2 - API Keys Configuration\nStep 3 - AI Processing Setup\nStep 4 - Voice & Video Generation\nStep 5 - Publishing & Tracking\nHow It Works (workflow summary)\n5. General Notes & Resources\nNote Content\nContext or Link\nWorkflow transforms photo + theme sent via Telegram into viral TikTok videos automatically.\nGeneral workflow purpose.\nSetup guide video on YouTube:\nhttps://youtu.be/YykmUeGVb9U\nSetup Guide sticky note.\nGoogle Sheets setup tutorial:\nhttps://youtu.be/fDzVmdw7bNU\nAPI keys and credentials configuration instructions.\nSample Google Sheets data template:\nSheet Link\nGoogle Sheets data format for logging.\nBlotato node and API:\nhttps://blotato.com/?ref=firas\nUsed for multi-platform social media publishing.\nContact for support and consulting: LinkedIn -\nhttps://www.linkedin.com/in/dr-firas/\nSupport channels provided in sticky notes.\nContact for support and consulting: YouTube -\nhttps://www.youtube.com/@DRFIRASS\nSupport channels provided in sticky notes.\nDisclaimer:\nThe text provided is exclusively extracted from an automated workflow created with n8n, complying strictly with content policies and containing no illegal, offensive, or protected elements. All processed data is legal and public.\nCopied to clipboard",
      "description_full_fr": "Auto-Create TikTok Videos with VEED.io AI Avatars, ElevenLabs & GPT-4\n1. Workflow Overview\nThis workflow automates the creation and publishing of viral TikTok videos using a photo and theme input sent via Telegram. It leverages AI technologies including Perplexity for trend research, GPT-4 for script and caption generation, ElevenLabs for voice synthesis, and FAL.ai (VEED.io) for video creation from images and audio. Finally, it publishes the generated content across multiple social platforms and logs the data in Google Sheets.\nThe workflow is logically grouped into these blocks:\n1.1 Input Reception:\nReceives photo and caption/theme via Telegram.\n1.2 Trend Research:\nUses Perplexity API to identify trending topics related to the input theme.\n1.3 Script Generation:\nGPT-4 creates a short viral TikTok script based on trends.\n1.4 Voice Synthesis:\nElevenLabs converts the script text to natural speech audio.\n1.5 Audio and Image Upload:\nUploads audio and photo to public URLs for processing.\n1.6 Video Generation:\nFAL.ai generates a talking video using the photo and synthesized audio.\n1.7 Caption Generation:\nGPT-4 composes an engaging TikTok caption with hashtags.\n1.8 Data Logging:\nSaves all media URLs, captions, and status to Google Sheets for tracking.\n1.9 Publishing:\nPublishes the video and caption to TikTok and other social media using the Blotato node.\n1.10 Status Update:\nMarks the workflow run as DONE in the Google Sheet.\n1.11 User Guidance:\nSticky notes provide setup instructions and explanations.\n2. Block-by-Block Analysis\n1.1 Input Reception\nOverview:\nStarts the workflow by triggering on incoming Telegram messages containing a photo and optional caption/theme.\nNodes Involved:\nTelegram Trigger\nWorkflow Configuration\nExtract Photo and Theme\nGet Photo File from Telegram\nNode Details:\nTelegram Trigger\nType: Telegram Trigger\nRole: Listens for new Telegram messages (photo with caption or text) to start workflow.\nConfiguration: Triggers on \"message\" updates only. Uses Telegram API credentials.\nInputs: Telegram messages\nOutputs: Message JSON including photo file IDs and captions\nEdge Cases: Missing photo or caption leads to empty variables; no trigger if message is not a photo or text.\nWorkflow Configuration\nType: Set\nRole: Sets essential API keys and configuration variables (ElevenLabs API key, voice ID, FAL.ai API key, script max duration, Perplexity model).\nConfiguration: Static assignment of credentials and parameters to workflow context.\nInputs: Trigger output\nOutputs: JSON with configuration variables\nEdge Cases: Missing or invalid API keys will cause downstream API calls to fail.\nExtract Photo and Theme\nType: Set\nRole: Extracts the Telegram photo file ID and theme (caption or text) from the incoming message.\nConfiguration:\nphotoUrl: last photo file_id if any, else empty string\ntheme: message caption or text or defaults to \"viral content\"\nInputs: Workflow Configuration output\nOutputs: JSON with photoUrl and theme\nEdge Cases: No photo attached results in empty photoUrl; empty theme defaults to \"viral content\".\nGet Photo File from Telegram\nType: Telegram\nRole: Downloads the actual photo file from Telegram servers using the file ID.\nConfiguration: Uses photoUrl extracted above as fileId parameter.\nInputs: Extract Photo and Theme output\nOutputs: Binary photo file data\nEdge Cases: Telegram API failures, invalid file ID, or missing photo cause download failure.\n1.2 Trend Research\nOverview:\nQueries Perplexity API to find top 3 current viral TikTok trends related to the photo caption/theme.\nNodes Involved:\nBuild Public Image URL\nSearch Trends with Perplexity\nNode Details:\nBuild Public Image URL\nType: HTTP Request (POST multipart-form-data)\nRole: Uploads the downloaded photo binary to tmpfiles.org to get a public URL.\nConfiguration: Uploads photo binary under \"data\" field.\nInputs: Get Photo File from Telegram output (binary photo)\nOutputs: JSON containing public URL for the image\nEdge Cases: Upload failures or temporary URL downtime.\nSearch Trends with Perplexity\nType: Perplexity API\nRole: Performs AI-powered search for top 3 viral trends on TikTok related to the photo‚Äôs theme.\nConfiguration:\nModel: dynamically set from Workflow Configuration (e.g., \"sonar\")\nPrompt: Finds top 3 viral trends, hashtags, content styles related to caption.\nInputs: Build Public Image URL output (uses caption from Extract Photo and Theme)\nOutputs: JSON with trends as string content in response\nEdge Cases: API rate limits, invalid API key, or no relevant trends found.\n1.3 Script Generation\nOverview:\nGenerates a concise, engaging TikTok script (max 30 seconds) based on the trends found.\nNodes Involved:\nGenerate Script with GPT-4\nNode Details:\nGenerate Script with GPT-4\nType: OpenAI API (GPT-4) via LangChain node\nRole: Creates a viral TikTok script using the trend data and theme.\nConfiguration:\nModel: \"gpt-4o-mini\" (GPT-4 optimized)\nPrompt instructs to create a max 30-second script with a hook, conversational style optimized for voice synthesis.\nInputs: Search Trends with Perplexity output (trends content) and Extract Photo and Theme (theme)\nOutputs: JSON with generated script text\nEdge Cases: API quota exceeded, prompt failures, or nonsensical script output.\n1.4 Voice Synthesis\nOverview:\nConverts the generated script text into natural sounding speech audio (MP3) via ElevenLabs API.\nNodes Involved:\nElevenLabs Voice Synthesis\nConvert .mpga to .mp3\nUpload Audio to Public URL\nNode Details:\nElevenLabs Voice Synthesis\nType: HTTP Request (POST)\nRole: Sends script text to ElevenLabs TTS API to generate voice audio.\nConfiguration:\nURL composed dynamically with voice ID from Workflow Configuration\nJSON body includes text, model id \"eleven_multilingual_v2\", voice stability and similarity settings\nHeaders include xi-api-key for authentication\nInputs: Generate Script with GPT-4 output (script text)\nOutputs: Binary audio in MPGA format (audio/mpeg)\nEdge Cases: API key invalid, network timeout, audio format issues.\nConvert .mpga to .mp3\nType: Code\nRole: Renames binary audio file extension from .mpga to .mp3 and sets MIME type.\nConfiguration: JavaScript code updates binary property name and metadata.\nInputs: ElevenLabs Voice Synthesis binary audio\nOutputs: Binary audio renamed as .mp3\nEdge Cases: Missing binary data causes no conversion.\nUpload Audio to Public URL\nType: HTTP Request (POST multipart-form-data)\nRole: Uploads the mp3 audio file to tmpfiles.org to get a public URL.\nConfiguration: Form data includes the mp3 binary under \"file\".\nInputs: Convert .mpga to .mp3 output (binary audio_mp3)\nOutputs: JSON with public audio URL\nEdge Cases: Upload failure or URL expiration.\n1.5 Video Generation\nOverview:\nGenerates a lip-synced talking video using the uploaded photo and audio via FAL.ai (VEED Fabric 1.0 model).\nNodes Involved:\nFAL.ai Video Generation\nWait for VEED\nDownload VEED Video\nNode Details:\nFAL.ai Video Generation\nType: HTTP Request (POST)\nRole: Sends a request to FAL.ai endpoint to generate video with image and audio URLs.\nConfiguration:\nJSON body includes public image and audio URLs (converted to tmpfiles.org download links), resolution set to 480p\nAuthorization header uses FAL API key from Workflow Configuration\nInputs: Upload Audio to Public URL output (audio URL) and Build Public Image URL (image URL)\nOutputs: JSON response with request_id for video generation\nEdge Cases: API errors, invalid URLs, or processing delays.\nWait for VEED\nType: Wait\nRole: Pauses workflow for 10 minutes to allow video processing to complete asynchronously.\nConfiguration: Wait duration set to 10 minutes\nInputs: FAL.ai Video Generation output\nOutputs: Passes data forward after delay\nEdge Cases: Fixed wait time may be inefficient if processing is faster/slower.\nDownload VEED Video\nType: HTTP Request (GET)\nRole: Retrieves the generated video file from FAL.ai using the request_id.\nConfiguration:\nURL dynamically built with request_id from previous node\nAuthorization header with FAL API key\nInputs: Wait for VEED output\nOutputs: JSON containing video URL\nEdge Cases: Video not ready, 404 errors, or API failures.\n1.6 Caption Generation\nOverview:\nCreates an engaging TikTok caption optimized for algorithms, including trending hashtags.\nNodes Involved:\nGenerate Caption with GPT-4\nNode Details:\nGenerate Caption with GPT-4\nType: OpenAI API (GPT-4) via LangChain node\nRole: Generates a catchy caption based on the theme and discovered trends.\nConfiguration:\nModel: \"gpt-4o-mini\"\nPrompt requests a catchy hook, 5-8 trending hashtags, concise and engaging text optimized for TikTok.\nInputs: Download VEED Video output (to confirm video is ready), Extract Photo and Theme, Search Trends with Perplexity (trends)\nOutputs: Caption text JSON\nEdge Cases: API quota, prompt failure, or irrelevant captions.\n1.7 Data Logging\nOverview:\nSaves the idea, caption, media URLs, and workflow status into a Google Sheets document for tracking.\nNodes Involved:\nSave to Google Sheets\nUpdate Status to \"DONE\"\nNode Details:\nSave to Google Sheets\nType: Google Sheets node\nRole: Appends new row with the TikTok idea (caption), generated caption text, audio/image/video URLs.\nConfiguration:\nDocument ID and Sheet Name dynamically set\nMapping fields: IDEA, CAPTION, URL AUDIO, URL IMAGE, URL VIDEO\nInputs: Generate Caption with GPT-4 output\nOutputs: Confirmation of row addition with data\nEdge Cases: Google API auth failures, quota exceeded, or invalid sheet format.\nUpdate Status to \"DONE\"\nType: Google Sheets node\nRole: Updates the STATUS field to \"DONE\" for the processed video entry.\nConfiguration:\nMatches rows based on URL VIDEO\nAppends or updates existing rows\nInputs: Merge node output (after publishing)\nOutputs: Confirmation of update\nEdge Cases: Mismatched URL keys, Google API errors.\n1.8 Publishing\nOverview:\nUploads the generated video and caption to TikTok and multiple other social media platforms via the Blotato community node.\nNodes Involved:\nSend a video (Telegram)\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nThreads\nBluesky\nPinterest\nMerge1\nNode Details:\nSend a video (Telegram)\nType: Telegram\nRole: Sends the generated video back to the user on Telegram chat.\nConfiguration: Uses chat ID from Telegram Trigger node and video URL from Google Sheets data.\nInputs: Save to Google Sheets output\nOutputs: Confirmation of video sent\nEdge Cases: Telegram API limits or invalid chat ID.\nUpload Video to BLOTATO\nType: Blotato Node (Community)\nRole: Uploads video to Blotato platform for social media publishing.\nConfiguration: Uses video URL from Google Sheets data.\nInputs: Save to Google Sheets output\nOutputs: Media ID for publishing nodes\nEdge Cases: Blotato API auth errors or upload failures.\nSocial Media Publishing Nodes (Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest)\nType: Blotato Node (Community)\nRole: Publishes the video with caption to respective platform using Blotato API.\nConfiguration:\nPlatform specified (e.g., \"tiktok\")\nAccount ID selected from cached accounts\nCaption text from Google Sheets\nMedia URL from Upload Video to BLOTATO node\nInputs: Upload Video to BLOTATO output\nOutputs: Post confirmation\nEdge Cases: Credential expiry, platform posting limits, content policy rejection.\nMerge1\nType: Merge\nRole: Combines outputs from all social media publishing nodes to continue workflow.\nConfiguration: Choose branch mode with 9 inputs\nInputs: All social publishing nodes\nOutputs: Combined data for status update\nEdge Cases: Partial publishing failures or node errors.\n1.9 User Guidance\nOverview:\nSticky notes provide detailed setup instructions and explanations for each step of the workflow including API key configuration, Telegram bot setup, AI processing, voice/video generation, publishing, and usage flow.\nNodes Involved:\nSetup Guide - Start Here\nStep 1 - Telegram Setup\nStep 2 - API Keys Configuration\nStep 3 - AI Processing\nStep 4 - Voice & Video Generation\nStep 5 - Publishing\nHow It Works\nNode Details:\nAll are sticky note nodes with detailed textual instructions and helpful links for setting up the workflow and credentials. They guide users through:\nCreating Telegram bot and setting up trigger.\nConfiguring all required API keys (ElevenLabs, FAL.ai, OpenAI, Perplexity, Google Sheets).\nAI nodes usage and models.\nVoice and video generation details.\nPublishing via Blotato node community plugin with supported platforms.\nOverall workflow operation and expected results.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nStart workflow on Telegram message\n-\nWorkflow Configuration\n# üì± STEP 1: TELEGRAM BOT SETUP (detailed setup instructions)\nWorkflow Configuration\nSet\nStores API keys and config variables\nTelegram Trigger\nExtract Photo and Theme\n# üîë STEP 2: API KEYS CONFIGURATION (API keys setup instructions)\nExtract Photo and Theme\nSet\nExtract photo file ID and theme\nWorkflow Configuration\nGet Photo File from Telegram\nGet Photo File from Telegram\nTelegram\nDownloads photo from Telegram\nExtract Photo and Theme\nBuild Public Image URL\nBuild Public Image URL\nHTTP Request\nUploads photo to public URL\nGet Photo File from Telegram\nSearch Trends with Perplexity\nSearch Trends with Perplexity\nPerplexity API\nFinds viral TikTok trends\nBuild Public Image URL\nGenerate Script with GPT-4\n# ü§ñ STEP 3: AI PROCESSING SETUP (Perplexity and OpenAI details)\nGenerate Script with GPT-4\nOpenAI (LangChain)\nCreates TikTok script\nSearch Trends with Perplexity\nElevenLabs Voice Synthesis\nElevenLabs Voice Synthesis\nHTTP Request\nConverts script text to speech\nGenerate Script with GPT-4\nConvert .mpga to .mp3\n# üé¨ STEP 4: VOICE & VIDEO GENERATION (ElevenLabs and FAL.ai APIs explanation)\nConvert .mpga to .mp3\nCode\nRenames audio binary to .mp3\nElevenLabs Voice Synthesis\nUpload Audio to Public URL\nUpload Audio to Public URL\nHTTP Request\nUploads audio file to public URL\nConvert .mpga to .mp3\nFAL.ai Video Generation\nFAL.ai Video Generation\nHTTP Request\nRequests talking video generation\nUpload Audio to Public URL\nWait for VEED\nWait for VEED\nWait\nWaits for video processing\nFAL.ai Video Generation\nDownload VEED Video\nDownload VEED Video\nHTTP Request\nDownloads generated video\nWait for VEED\nGenerate Caption with GPT-4\nGenerate Caption with GPT-4\nOpenAI (LangChain)\nCreates TikTok caption\nDownload VEED Video\nSave to Google Sheets\nSave to Google Sheets\nGoogle Sheets\nLogs idea, caption, media URLs\nGenerate Caption with GPT-4\nSend a video, Upload Video to BLOTATO\nSend a video\nTelegram\nSends generated video on Telegram\nSave to Google Sheets\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato Node\nUploads video for social publishing\nSave to Google Sheets\nSocial media publishing nodes\n# üì§ STEP 5: PUBLISHING & TRACKING (Blotato installation and publishing instructions)\nTiktok\nBlotato Node\nPublishes video to TikTok\nUpload Video to BLOTATO\nMerge1\nLinkedin\nBlotato Node\nPublishes video to LinkedIn\nUpload Video to BLOTATO\nMerge1\nFacebook\nBlotato Node\nPublishes video to Facebook\nUpload Video to BLOTATO\nMerge1\nInstagram\nBlotato Node\nPublishes video to Instagram\nUpload Video to BLOTATO\nMerge1\nTwitter (X)\nBlotato Node\nPublishes video to Twitter (X)\nUpload Video to BLOTATO\nMerge1\nYoutube\nBlotato Node\nPublishes video to YouTube\nUpload Video to BLOTATO\nMerge1\nThreads\nBlotato Node\nPublishes video to Threads\nUpload Video to BLOTATO\nMerge1\nBluesky\nBlotato Node\nPublishes video to Bluesky\nUpload Video to BLOTATO\nMerge1\nPinterest\nBlotato Node\nPublishes video to Pinterest\nUpload Video to BLOTATO\nMerge1\nMerge1\nMerge\nCombines all social publishing outputs\nAll social publishing nodes\nUpdate Status to \"DONE\"\nUpdate Status to \"DONE\"\nGoogle Sheets\nUpdates Google Sheet status to DONE\nMerge1\n-\nSetup Guide - Start Here\nSticky Note\nProvides full setup guide\n-\n-\nContains full setup guide, tutorial links, and contact info.\nStep 1 - Telegram Setup\nSticky Note\nTelegram bot setup instructions\n-\n-\nDetailed Telegram bot creation and trigger node instructions.\nStep 2 - API Keys Configuration\nSticky Note\nAPI keys configuration instructions\n-\n-\nInstructions to set ElevenLabs, FAL.ai, and other API keys.\nStep 3 - AI Processing\nSticky Note\nAI nodes setup guidance\n-\n-\nDetails on Perplexity, OpenAI, and FAL.ai API usage.\nStep 4 - Voice & Video Generation\nSticky Note\nVoice and video generation overview\n-\n-\nExplains ElevenLabs and FAL.ai nodes, no config needed.\nStep 5 - Publishing\nSticky Note\nPublishing & tracking instructions\n-\n-\nBlotato node installation and publishing setup instructions with links.\nHow It Works\nSticky Note\nWorkflow flow summary\n-\n-\nStepwise functional overview with timing and usage example.\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger Node\nType: Telegram Trigger\nSet to trigger on \"message\" updates (photo or text).\nAdd Telegram API credentials (Bot token).\nActivate webhook.\nAdd Workflow Configuration Node (Set)\nCreate a \"Set\" node to store:\nelevenLabsApiKey\n(string)\nelevenLabsVoiceId\n(string)\nfalApiKey\n(string)\nscriptMaxDuration\n(number, default 30)\nperplexityModel\n(string, e.g., \"sonar\")\nNo input required; connects from Telegram Trigger.\nAdd Extract Photo and Theme Node (Set)\nExtract last photo file_id from incoming message JSON:\n{{$json.message.photo ? $json.message.photo[$json.message.photo.length - 1].file_id : ''}}\nExtract theme from caption or text or default \"viral content\":\n{{$json.message.caption || $json.message.text || 'viral content'}}\nConnect from Workflow Configuration node.\nAdd Get Photo File from Telegram Node\nType: Telegram\nResource: File\nParameter:\nfileId\nset to\n{{$json.photoUrl}}\nUse Telegram API credentials\nConnect from Extract Photo and Theme.\nAdd Build Public Image URL Node (HTTP Request)\nMethod: POST\nURL:\nhttps://tmpfiles.org/api/v1/upload\nBody: multipart-form-data, field name \"data\" with binary photo file from previous node\nResponse format: JSON expected\nConnect from Get Photo File from Telegram.\nAdd Search Trends with Perplexity Node\nUse Perplexity API node with API key credentials\nModel: set from Workflow Configuration node (e.g.,\n{{$node[\"Workflow Configuration\"].json.perplexityModel}}\n)\nMessage prompt: \"Find top 3 current viral trends related to: {{caption}}...\" (use caption from Extract Photo and Theme)\nConnect from Build Public Image URL.\nAdd Generate Script with GPT-4 Node (OpenAI)\nUse OpenAI API credentials\nModel: \"gpt-4o-mini\"\nPrompt: Create viral 30-second TikTok script based on trends and theme, with hook and optimized for voice synthesis.\nConnect from Search Trends with Perplexity.\nAdd ElevenLabs Voice Synthesis Node (HTTP Request)\nPOST to\nhttps://api.elevenlabs.io/v1/text-to-speech/{voiceId}\nwhere voiceId from Workflow Configuration\nBody JSON:\n{text: script text, model_id: \"eleven_multilingual_v2\", voice_settings: {...}}\nHeaders: xi-api-key from Workflow Configuration, Content-Type\napplication/json\n, Accept\naudio/mpeg\nConnect from Generate Script with GPT-4.\nAdd Convert .mpga to .mp3 Node (Code)\nJavaScript code to rename binary audio file extension from .mpga to .mp3 and set MIME type\nConnect from ElevenLabs Voice Synthesis.\nAdd Upload Audio to Public URL Node (HTTP Request)\nPOST to\nhttps://tmpfiles.org/api/v1/upload\nmultipart-form-data with \"file\" field from previous node binary audio_mp3\nResponse: JSON\nConnect from Convert .mpga to .mp3.\nAdd FAL.ai Video Generation Node (HTTP Request)\nPOST to\nhttps://queue.fal.run/veed/fabric-1.0\nHeader Authorization with FAL API key from Workflow Configuration\nBody JSON with:\nimage_url: public image URL replacing tmpfiles.org link to download link\naudio_url: public audio URL replacing tmpfiles.org link to download link\nresolution: \"480p\"\nConnect from Upload Audio to Public URL.\nAdd Wait for VEED Node (Wait)\nWait 10 minutes for video generation\nConnect from FAL.ai Video Generation.\nAdd Download VEED Video Node (HTTP Request)\nGET to\nhttps://queue.fal.run/veed/fabric-1.0/requests/{request_id}\nfrom previous node response\nHeader Authorization with FAL API key\nConnect from Wait for VEED.\nAdd Generate Caption with GPT-4 Node (OpenAI)\nUse OpenAI API credentials\nModel: \"gpt-4o-mini\"\nPrompt: Create engaging caption with trending hashtags based on theme and trends\nConnect from Download VEED Video.\nAdd Save to Google Sheets Node\nGoogle Sheets OAuth2 credential setup\nDocument ID and Sheet Name configured\nAppend row with columns: IDEA (caption), CAPTION (generated caption), URL AUDIO, URL IMAGE, URL VIDEO\nConnect from Generate Caption with GPT-4.\nAdd Send a video Node (Telegram)\nOperation: Send Video\nChat ID from Telegram Trigger message chat id\nFile URL from Google Sheets URL VIDEO column\nConnect from Save to Google Sheets.\nAdd Upload Video to BLOTATO Node\nUse Blotato API credentials\nUpload video URL from Google Sheets URL VIDEO\nConnect from Save to Google Sheets.\nAdd Social Media Publishing Nodes (Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest)\nUse Blotato API credentials\nPlatform set accordingly\nAccount IDs selected from dashboard\nCaption text from Google Sheets CAPTION\nMedia URL from Upload Video to BLOTATO\nAll connect from Upload Video to BLOTATO node.\nAdd Merge Node (Merge1)\nMode: Choose Branch\nInputs: all social publishing nodes (9 inputs)\nConnect all social publishing nodes outputs to Merge1.\nAdd Update Status to \"DONE\" Node (Google Sheets)\nGoogle Sheets OAuth2 configured\nAppend or update row matching on URL VIDEO column\nSet STATUS field to \"DONE\"\nConnect from Merge1 output.\nAdd Sticky Notes\nAdd multiple sticky notes for guidance:\nSetup Guide - Start Here\nStep 1 - Telegram Setup\nStep 2 - API Keys Configuration\nStep 3 - AI Processing Setup\nStep 4 - Voice & Video Generation\nStep 5 - Publishing & Tracking\nHow It Works (workflow summary)\n5. General Notes & Resources\nNote Content\nContext or Link\nWorkflow transforms photo + theme sent via Telegram into viral TikTok videos automatically.\nGeneral workflow purpose.\nSetup guide video on YouTube:\nhttps://youtu.be/YykmUeGVb9U\nSetup Guide sticky note.\nGoogle Sheets setup tutorial:\nhttps://youtu.be/fDzVmdw7bNU\nAPI keys and credentials configuration instructions.\nSample Google Sheets data template:\nSheet Link\nGoogle Sheets data format for logging.\nBlotato node and API:\nhttps://blotato.com/?ref=firas\nUsed for multi-platform social media publishing.\nContact for support and consulting: LinkedIn -\nhttps://www.linkedin.com/in/dr-firas/\nSupport channels provided in sticky notes.\nContact for support and consulting: YouTube -\nhttps://www.youtube.com/@DRFIRASS\nSupport channels provided in sticky notes.\nDisclaimer:\nThe text provided is exclusively extracted from an automated workflow created with n8n, complying strictly with content policies and containing no illegal, offensive, or protected elements. All processed data is legal and public.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Dr. Firas",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/auto-create-tiktok-videos-with-veedio-ai-avatars-elevenlabs-gpt-4-10000",
      "nodes_count": 35
    },
    {
      "id": "003",
      "slug": "gnrez-des-vidos-ia-amusantes-avec-sora-2-et-publiez-automatiquement-sur-tiktok",
      "title_en": "Generate Funny AI Videos with Sora 2 and Auto-Publish to TikTok",
      "title_fr": "G√©n√©rez des vid√©os IA amusantes avec Sora 2 et publiez automatiquement sur TikTok",
      "description_short_en": "Automate AI-powered video creation and TikTok publishing with seamless integration, centralized control, and scalable social media management. Learn more.",
      "description_short_fr": "Automatisez la cr√©ation vid√©o bas√©e sur l'IA et la publication TikTok avec une int√©gration transparente, un contr√¥le centralis√© et une gestion √©volutive des m√©dias sociaux. Apprendre encore plus.",
      "description_full_en": "Generate Funny AI Videos with Sora 2 and Auto-Publish to TikTok\n1. Workflow Overview\nThis workflow automates the generation, processing, and publishing of AI-generated videos with audio using the OpenAI Sora 2 model, saving them to Google Drive, creating optimized video titles with GPT-5, and automatically uploading the final videos to TikTok via Postiz. It is designed to be triggered by a form submission, making it suitable for content creators or social media managers who want to streamline their video production and distribution process.\nLogical Blocks:\n1.1 Input Reception:\nCaptures user input (video prompt and duration) via a form trigger.\n1.2 AI Video Generation:\nSends the prompt to Sora 2 API to generate a video, then polls for completion.\n1.3 Video Retrieval:\nOnce the video is ready, fetches the video URL and downloads the video file.\n1.4 Title Generation:\nUses GPT-5 to generate an SEO-optimized YouTube-style title based on the prompt.\n1.5 Video Upload to TikTok:\nUploads the video to Postiz platform and schedules it for publishing on TikTok.\n1.6 Supporting Notes and Configuration:\nContains sticky notes with instructions for API key setup and workflow usage.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nThis block receives input data from a user form, specifically the video prompt and duration, serving as the workflow‚Äôs entry point.\nNodes Involved:\nOn form submission\nNode Details:\nOn form submission\nType: Form Trigger\nRole: Entry point to receive user inputs \"PROMPT\" (text) and \"DURATION\" (number).\nConfiguration:\nForm title: \"Generate AI Videos (with audio)\"\nForm fields: PROMPT (required), DURATION (required)\nWebhook ID configured for external trigger\nInputs: External HTTP form submission\nOutputs: JSON containing PROMPT and DURATION\nEdge Cases: Missing required fields; malformed input; webhook unavailability.\n2.2 AI Video Generation\nOverview:\nThis block sends the video prompt and duration to the Sora 2 API to create the video, then waits and polls the API for completion status.\nNodes Involved:\nCreate Video\nWait 60 sec.\nGet status\nCompleted?\nNode Details:\nCreate Video\nType: HTTP Request\nRole: Sends POST request to Sora 2 endpoint to initiate video generation.\nConfiguration:\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/text-to-video\nMethod: POST\nBody: JSON with prompt and duration combined from form inputs\nAuthentication: Header Auth with API key (\"Authorization: Key YOURAPIKEY\")\nHeaders: Content-Type application/json\nInputs: JSON from form submission\nOutputs: JSON containing request_id for video generation\nEdge Cases: API key invalid, request limits, malformed prompt, network errors.\nWait 60 sec.\nType: Wait node\nRole: Pauses workflow for 60 seconds before polling status.\nConfiguration: Fixed 60-second wait\nInputs: Triggered after Create Video\nOutputs: Triggers Get status node\nEdge Cases: Time delays may cause workflow timeouts in low-resource environments.\nGet status\nType: HTTP Request\nRole: Polls the Sora 2 API to check the current status of video generation using request_id.\nConfiguration:\nURL template:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{request_id}}/status\nAuthentication: Header Auth with API key\nInputs: request_id from Create Video output\nOutputs: JSON with status field\nEdge Cases: API downtime, invalid request_id, response delays.\nCompleted?\nType: If node\nRole: Checks if the video generation status equals \"COMPLETED\" to proceed or wait longer.\nConfiguration: Condition on the \"status\" field\nInputs: Output from Get status\nOutputs:\nTrue: Continue to Get Url Video node\nFalse: Loop back to Wait 60 sec. node to poll again\nEdge Cases: Status values other than \"COMPLETED\" or unexpected API responses.\n2.3 Video Retrieval\nOverview:\nAfter video generation completes, this block obtains the video URL and downloads the video file.\nNodes Involved:\nGet Url Video\nGenerate title\nGet File Video\nNode Details:\nGet Url Video\nType: HTTP Request\nRole: Retrieves detailed video request information including video URL by request_id.\nConfiguration:\nURL template:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{request_id}}\nAuthentication: Header Auth with separate credential (note: uses \"Youtube Transcript Extractor API 1\" credential, likely a generic API key)\nInputs: request_id from Completed? node\nOutputs: JSON containing video metadata including video URL\nEdge Cases: API access errors, credential mismatch, missing video URL.\nGenerate title\nType: OpenAI (LangChain) node\nRole: Generates an SEO-optimized YouTube title using GPT-5 based on the original prompt.\nConfiguration:\nModel: gpt-4o-mini (GPT-5 equivalent or advanced variant)\nPrompt content: Input prompt text from original user input\nSystem message: Instructions to create catchy, SEO-friendly titles up to 60 characters, in the prompt‚Äôs language.\nInputs: PROMPT from Get Url Video or original form submission\nOutputs: Text response with generated title\nEdge Cases: API rate limits, prompt truncation, off-topic title generation.\nGet File Video\nType: HTTP Request\nRole: Downloads the actual video file from the video URL obtained.\nConfiguration:\nURL: Dynamic, taken from Get Url Video node output JSON path video.url\nMethod: GET\nNo authentication required\nInputs: video URL from Get Url Video\nOutputs: Binary video data ready for upload\nEdge Cases: Broken or inaccessible video URL, network timeouts, large file sizes.\n2.4 Video Upload to TikTok\nOverview:\nUploads the downloaded video file to Postiz (a social media publishing platform) and schedules it for TikTok publishing with the generated title.\nNodes Involved:\nUpload Video to Postiz\nTikTok\nNode Details:\nUpload Video to Postiz\nType: HTTP Request\nRole: Uploads the binary video file to Postiz storage.\nConfiguration:\nURL:\nhttps://api.postiz.com/public/v1/upload\nMethod: POST\nContent-Type: multipart/form-data\nBody: Binary data attached as \"file\" parameter\nAuthentication: Header Auth with Postiz API key\nInputs: Binary video from Get File Video\nOutputs: JSON with uploaded file ID and path\nEdge Cases: File size limits, authentication failure, network errors.\nTikTok\nType: Postiz node (custom)\nRole: Posts the uploaded video to TikTok with the generated title and scheduling.\nConfiguration:\nDate: Current date/time (dynamic)\nPost content:\nImage ID and path from Upload Video to Postiz response\nContent: Generated title from Generate title node\nIntegrationId: TikTok channel ID (to be set by user)\nShortLink: true (generate shortened links if applicable)\nCredentials: Postiz account API key\nInputs: Uploaded video metadata and generated title\nOutputs: Confirmation of post scheduling or publishing\nEdge Cases: Invalid channel ID, API quota limits, scheduling conflicts.\n2.5 Supporting Notes and Configuration\nOverview:\nProvides user guidance and setup instructions through sticky notes.\nNodes Involved:\nSticky Note3\nSticky Note5\nSticky Note6\nSticky Note7\nSticky Note8\nSticky Note (unnamed)\nNode Details:\nSticky Note3\nContent: Workflow description and overview, highlighting the use of Sora 2, Google Drive, GPT-5, TikTok, and form-based input.\nContext: General introduction\nSticky Note5\nContent: Instructions for workflow triggering (manual or scheduled every 5 minutes).\nContext: Scheduling recommendations\nSticky Note6\nContent: Instructions for obtaining the Fal.ai API key and setting HTTP header authentication in nodes.\nContext: API key setup\nSticky Note7\nContent: Reminder to set the API key in the respective node.\nContext: API key application\nSticky Note8\nContent: Postiz account creation, API key setup, channel connection, and obtaining ChannelId for TikTok.\nContext: TikTok publishing setup\nSticky Note (near TikTok node)\nContent: Reminder to set ChannelId in TikTok node.\nContext: TikTok integration detail\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nOn form submission\nForm Trigger\nReceives video prompt and duration\nCreate Video\nCreate Video\nHTTP Request\nSends prompt/duration to Sora 2\nOn form submission\nWait 60 sec.\nSet API Key created in Step 2\nWait 60 sec.\nWait\nWaits before polling status\nCreate Video\nGet status\nGet status\nHTTP Request\nPolls for video generation status\nWait 60 sec.\nCompleted?\nCompleted?\nIf\nChecks if video generation is done\nGet status\nGet Url Video / Wait 60 sec.\nGet Url Video\nHTTP Request\nGets video URL and metadata\nCompleted?\nGenerate title\nGenerate title\nOpenAI (LangChain)\nCreates SEO-friendly video title\nGet Url Video\nGet File Video\nGet File Video\nHTTP Request\nDownloads video file\nGenerate title\nUpload Video to Postiz\nUpload Video to Postiz\nHTTP Request\nUploads video to Postiz storage\nGet File Video\nTikTok\nTikTok\nPostiz\nPosts video to TikTok channel\nUpload Video to Postiz\nSet ChannelId Step 3\nSticky Note3\nSticky Note\nWorkflow overview and description\n# Generate AI Videos (with audio), using Sora 2 and Upload to TikTok...\nSticky Note5\nSticky Note\nScheduling instructions\n## STEP 3 - MAIN FLOW...\nSticky Note6\nSticky Note\nAPI key acquisition instructions\n## STEP 1 - GET API KEY (YOURAPIKEY)...\nSticky Note7\nSticky Note\nAPI key reminder\nSet API Key created in Step 2\nSticky Note8\nSticky Note\nPostiz and TikTok integration guide\n## STEP 2 - Upload video on TikTok...\nSticky Note (unnamed near TikTok)\nSticky Note\nTikTok ChannelId reminder\nSet ChannelId Step 3\n4. Reproducing the Workflow from Scratch\nCreate the Form Trigger Node\nType: Form Trigger\nName: On form submission\nConfigure form titled \"Generate AI Videos (with audio)\"\nAdd two required fields: \"PROMPT\" (text) and \"DURATION\" (number)\nSave and note webhook URL for external trigger\nCreate HTTP Request Node to Generate Video\nType: HTTP Request\nName: Create Video\nMethod: POST\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/text-to-video\nAuthentication: HTTP Header Auth\nHeader Name: Authorization\nHeader Value: Key YOURAPIKEY (replace with actual Fal.ai API key)\nHeaders: Content-Type: application/json\nBody (JSON):\n{\n  \"prompt\": \"{{ $json.PROMPT }}. Duration of the video: {{ $json.DURATION }}\"\n}\nConnect input from On form submission node\nCreate Wait Node\nType: Wait\nName: Wait 60 sec.\nTime: 60 seconds\nConnect input from Create Video node output\nCreate HTTP Request Node to Get Status\nType: HTTP Request\nName: Get status\nMethod: GET\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{\n$('Create Video').item.json.request_id }}/status\nAuthentication: HTTP Header Auth\nUse the same Fal.ai API key credentials as Create Video node\nConnect input from Wait 60 sec. node output\nCreate If Node to Check Completion\nType: If\nName: Completed?\nCondition: Check if\n{{ $json.status }}\nequals \"COMPLETED\"\nConnect input from Get status node output\nTrue output connects to next block (Get Url Video)\nFalse output loops back to Wait 60 sec. node (to poll again)\nCreate HTTP Request Node to Get Video URL\nType: HTTP Request\nName: Get Url Video\nMethod: GET\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{\n$json.request_id }}\nAuthentication: HTTP Header Auth\nUse appropriate API key (can reuse Fal.ai key or corresponding credential)\nConnect true output from Completed? node\nCreate OpenAI LangChain Node to Generate Title\nType: OpenAI (LangChain)\nName: Generate title\nModel: gpt-4o-mini (or GPT-5 equivalent)\nMessages:\nUser content: Input prompt from original prompt (\n{{ $('Get new video').item.json.PROMPT }}\n)\nSystem content: Instructions for YouTube SEO title generation (as per workflow)\nConnect input from Get Url Video node\nCreate HTTP Request Node to Download Video File\nType: HTTP Request\nName: Get File Video\nMethod: GET\nURL:\n={{ $('Get Url Video').item.json.video.url }}\nConnect input from Generate title node\nCreate HTTP Request Node to Upload Video to Postiz\nType: HTTP Request\nName: Upload Video to Postiz\nMethod: POST\nURL:\nhttps://api.postiz.com/public/v1/upload\nAuthentication: HTTP Header Auth\nHeader Name: Authorization\nHeader Value: Postiz API key (from Postiz account)\nContent-Type: multipart/form-data\nBody: form binary data, parameter name \"file\", input from Get File Video binary data\nConnect input from Get File Video node\nCreate Postiz Node to Post on TikTok\nType: Postiz (custom node)\nName: TikTok\nCredentials: Postiz API key\nParameters:\nDate: Current timestamp (use expression for now)\nPost content:\nImage: Use ID and path from Upload Video to Postiz response\nContent: Generated title from Generate title node\nIntegrationId: Set to your TikTok channel ID from Postiz\nShortLink: true\nConnect input from Upload Video to Postiz node\nAdd Sticky Notes as per need\nAdd sticky notes to explain API key setup (Fal.ai and Postiz)\nAdd notes for scheduling triggers and TikTok integration steps\nOptional: Configure Scheduling\nAdd a Schedule Trigger node if periodic automatic execution is needed, recommended every 5 minutes\n5. General Notes & Resources\nNote Content\nContext or Link\nCreate an account on\nFal.ai\nand obtain API Key for Sora 2 video generation.\nAPI key acquisition instructions\nCreate an account on\nPostiz\nwith a free 7-day trial for TikTok.\nPostiz account and TikTok channel integration setup\nPostiz allows connecting social accounts and obtaining ChannelId for scheduling posts.\nPostiz TikTok integration instructions\nWorkflow requires self-hosted n8n due to community nodes compatibility.\nCompatibility notice\nSchedule trigger recommended at 5-minute intervals for batch processing or repeated runs.\nScheduling advice\nDisclaimer:\nThe text provided is generated strictly from an automated n8n workflow. It complies fully with content policies and contains no illegal, offensive, or protected content. All data handled is legal and public.\nCopied to clipboard",
      "description_full_fr": "Generate Funny AI Videos with Sora 2 and Auto-Publish to TikTok\n1. Workflow Overview\nThis workflow automates the generation, processing, and publishing of AI-generated videos with audio using the OpenAI Sora 2 model, saving them to Google Drive, creating optimized video titles with GPT-5, and automatically uploading the final videos to TikTok via Postiz. It is designed to be triggered by a form submission, making it suitable for content creators or social media managers who want to streamline their video production and distribution process.\nLogical Blocks:\n1.1 Input Reception:\nCaptures user input (video prompt and duration) via a form trigger.\n1.2 AI Video Generation:\nSends the prompt to Sora 2 API to generate a video, then polls for completion.\n1.3 Video Retrieval:\nOnce the video is ready, fetches the video URL and downloads the video file.\n1.4 Title Generation:\nUses GPT-5 to generate an SEO-optimized YouTube-style title based on the prompt.\n1.5 Video Upload to TikTok:\nUploads the video to Postiz platform and schedules it for publishing on TikTok.\n1.6 Supporting Notes and Configuration:\nContains sticky notes with instructions for API key setup and workflow usage.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nThis block receives input data from a user form, specifically the video prompt and duration, serving as the workflow‚Äôs entry point.\nNodes Involved:\nOn form submission\nNode Details:\nOn form submission\nType: Form Trigger\nRole: Entry point to receive user inputs \"PROMPT\" (text) and \"DURATION\" (number).\nConfiguration:\nForm title: \"Generate AI Videos (with audio)\"\nForm fields: PROMPT (required), DURATION (required)\nWebhook ID configured for external trigger\nInputs: External HTTP form submission\nOutputs: JSON containing PROMPT and DURATION\nEdge Cases: Missing required fields; malformed input; webhook unavailability.\n2.2 AI Video Generation\nOverview:\nThis block sends the video prompt and duration to the Sora 2 API to create the video, then waits and polls the API for completion status.\nNodes Involved:\nCreate Video\nWait 60 sec.\nGet status\nCompleted?\nNode Details:\nCreate Video\nType: HTTP Request\nRole: Sends POST request to Sora 2 endpoint to initiate video generation.\nConfiguration:\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/text-to-video\nMethod: POST\nBody: JSON with prompt and duration combined from form inputs\nAuthentication: Header Auth with API key (\"Authorization: Key YOURAPIKEY\")\nHeaders: Content-Type application/json\nInputs: JSON from form submission\nOutputs: JSON containing request_id for video generation\nEdge Cases: API key invalid, request limits, malformed prompt, network errors.\nWait 60 sec.\nType: Wait node\nRole: Pauses workflow for 60 seconds before polling status.\nConfiguration: Fixed 60-second wait\nInputs: Triggered after Create Video\nOutputs: Triggers Get status node\nEdge Cases: Time delays may cause workflow timeouts in low-resource environments.\nGet status\nType: HTTP Request\nRole: Polls the Sora 2 API to check the current status of video generation using request_id.\nConfiguration:\nURL template:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{request_id}}/status\nAuthentication: Header Auth with API key\nInputs: request_id from Create Video output\nOutputs: JSON with status field\nEdge Cases: API downtime, invalid request_id, response delays.\nCompleted?\nType: If node\nRole: Checks if the video generation status equals \"COMPLETED\" to proceed or wait longer.\nConfiguration: Condition on the \"status\" field\nInputs: Output from Get status\nOutputs:\nTrue: Continue to Get Url Video node\nFalse: Loop back to Wait 60 sec. node to poll again\nEdge Cases: Status values other than \"COMPLETED\" or unexpected API responses.\n2.3 Video Retrieval\nOverview:\nAfter video generation completes, this block obtains the video URL and downloads the video file.\nNodes Involved:\nGet Url Video\nGenerate title\nGet File Video\nNode Details:\nGet Url Video\nType: HTTP Request\nRole: Retrieves detailed video request information including video URL by request_id.\nConfiguration:\nURL template:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{request_id}}\nAuthentication: Header Auth with separate credential (note: uses \"Youtube Transcript Extractor API 1\" credential, likely a generic API key)\nInputs: request_id from Completed? node\nOutputs: JSON containing video metadata including video URL\nEdge Cases: API access errors, credential mismatch, missing video URL.\nGenerate title\nType: OpenAI (LangChain) node\nRole: Generates an SEO-optimized YouTube title using GPT-5 based on the original prompt.\nConfiguration:\nModel: gpt-4o-mini (GPT-5 equivalent or advanced variant)\nPrompt content: Input prompt text from original user input\nSystem message: Instructions to create catchy, SEO-friendly titles up to 60 characters, in the prompt‚Äôs language.\nInputs: PROMPT from Get Url Video or original form submission\nOutputs: Text response with generated title\nEdge Cases: API rate limits, prompt truncation, off-topic title generation.\nGet File Video\nType: HTTP Request\nRole: Downloads the actual video file from the video URL obtained.\nConfiguration:\nURL: Dynamic, taken from Get Url Video node output JSON path video.url\nMethod: GET\nNo authentication required\nInputs: video URL from Get Url Video\nOutputs: Binary video data ready for upload\nEdge Cases: Broken or inaccessible video URL, network timeouts, large file sizes.\n2.4 Video Upload to TikTok\nOverview:\nUploads the downloaded video file to Postiz (a social media publishing platform) and schedules it for TikTok publishing with the generated title.\nNodes Involved:\nUpload Video to Postiz\nTikTok\nNode Details:\nUpload Video to Postiz\nType: HTTP Request\nRole: Uploads the binary video file to Postiz storage.\nConfiguration:\nURL:\nhttps://api.postiz.com/public/v1/upload\nMethod: POST\nContent-Type: multipart/form-data\nBody: Binary data attached as \"file\" parameter\nAuthentication: Header Auth with Postiz API key\nInputs: Binary video from Get File Video\nOutputs: JSON with uploaded file ID and path\nEdge Cases: File size limits, authentication failure, network errors.\nTikTok\nType: Postiz node (custom)\nRole: Posts the uploaded video to TikTok with the generated title and scheduling.\nConfiguration:\nDate: Current date/time (dynamic)\nPost content:\nImage ID and path from Upload Video to Postiz response\nContent: Generated title from Generate title node\nIntegrationId: TikTok channel ID (to be set by user)\nShortLink: true (generate shortened links if applicable)\nCredentials: Postiz account API key\nInputs: Uploaded video metadata and generated title\nOutputs: Confirmation of post scheduling or publishing\nEdge Cases: Invalid channel ID, API quota limits, scheduling conflicts.\n2.5 Supporting Notes and Configuration\nOverview:\nProvides user guidance and setup instructions through sticky notes.\nNodes Involved:\nSticky Note3\nSticky Note5\nSticky Note6\nSticky Note7\nSticky Note8\nSticky Note (unnamed)\nNode Details:\nSticky Note3\nContent: Workflow description and overview, highlighting the use of Sora 2, Google Drive, GPT-5, TikTok, and form-based input.\nContext: General introduction\nSticky Note5\nContent: Instructions for workflow triggering (manual or scheduled every 5 minutes).\nContext: Scheduling recommendations\nSticky Note6\nContent: Instructions for obtaining the Fal.ai API key and setting HTTP header authentication in nodes.\nContext: API key setup\nSticky Note7\nContent: Reminder to set the API key in the respective node.\nContext: API key application\nSticky Note8\nContent: Postiz account creation, API key setup, channel connection, and obtaining ChannelId for TikTok.\nContext: TikTok publishing setup\nSticky Note (near TikTok node)\nContent: Reminder to set ChannelId in TikTok node.\nContext: TikTok integration detail\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nOn form submission\nForm Trigger\nReceives video prompt and duration\nCreate Video\nCreate Video\nHTTP Request\nSends prompt/duration to Sora 2\nOn form submission\nWait 60 sec.\nSet API Key created in Step 2\nWait 60 sec.\nWait\nWaits before polling status\nCreate Video\nGet status\nGet status\nHTTP Request\nPolls for video generation status\nWait 60 sec.\nCompleted?\nCompleted?\nIf\nChecks if video generation is done\nGet status\nGet Url Video / Wait 60 sec.\nGet Url Video\nHTTP Request\nGets video URL and metadata\nCompleted?\nGenerate title\nGenerate title\nOpenAI (LangChain)\nCreates SEO-friendly video title\nGet Url Video\nGet File Video\nGet File Video\nHTTP Request\nDownloads video file\nGenerate title\nUpload Video to Postiz\nUpload Video to Postiz\nHTTP Request\nUploads video to Postiz storage\nGet File Video\nTikTok\nTikTok\nPostiz\nPosts video to TikTok channel\nUpload Video to Postiz\nSet ChannelId Step 3\nSticky Note3\nSticky Note\nWorkflow overview and description\n# Generate AI Videos (with audio), using Sora 2 and Upload to TikTok...\nSticky Note5\nSticky Note\nScheduling instructions\n## STEP 3 - MAIN FLOW...\nSticky Note6\nSticky Note\nAPI key acquisition instructions\n## STEP 1 - GET API KEY (YOURAPIKEY)...\nSticky Note7\nSticky Note\nAPI key reminder\nSet API Key created in Step 2\nSticky Note8\nSticky Note\nPostiz and TikTok integration guide\n## STEP 2 - Upload video on TikTok...\nSticky Note (unnamed near TikTok)\nSticky Note\nTikTok ChannelId reminder\nSet ChannelId Step 3\n4. Reproducing the Workflow from Scratch\nCreate the Form Trigger Node\nType: Form Trigger\nName: On form submission\nConfigure form titled \"Generate AI Videos (with audio)\"\nAdd two required fields: \"PROMPT\" (text) and \"DURATION\" (number)\nSave and note webhook URL for external trigger\nCreate HTTP Request Node to Generate Video\nType: HTTP Request\nName: Create Video\nMethod: POST\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/text-to-video\nAuthentication: HTTP Header Auth\nHeader Name: Authorization\nHeader Value: Key YOURAPIKEY (replace with actual Fal.ai API key)\nHeaders: Content-Type: application/json\nBody (JSON):\n{\n  \"prompt\": \"{{ $json.PROMPT }}. Duration of the video: {{ $json.DURATION }}\"\n}\nConnect input from On form submission node\nCreate Wait Node\nType: Wait\nName: Wait 60 sec.\nTime: 60 seconds\nConnect input from Create Video node output\nCreate HTTP Request Node to Get Status\nType: HTTP Request\nName: Get status\nMethod: GET\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{\n$('Create Video').item.json.request_id }}/status\nAuthentication: HTTP Header Auth\nUse the same Fal.ai API key credentials as Create Video node\nConnect input from Wait 60 sec. node output\nCreate If Node to Check Completion\nType: If\nName: Completed?\nCondition: Check if\n{{ $json.status }}\nequals \"COMPLETED\"\nConnect input from Get status node output\nTrue output connects to next block (Get Url Video)\nFalse output loops back to Wait 60 sec. node (to poll again)\nCreate HTTP Request Node to Get Video URL\nType: HTTP Request\nName: Get Url Video\nMethod: GET\nURL:\nhttps://queue.fal.run/fal-ai/sora-2/requests/{{\n$json.request_id }}\nAuthentication: HTTP Header Auth\nUse appropriate API key (can reuse Fal.ai key or corresponding credential)\nConnect true output from Completed? node\nCreate OpenAI LangChain Node to Generate Title\nType: OpenAI (LangChain)\nName: Generate title\nModel: gpt-4o-mini (or GPT-5 equivalent)\nMessages:\nUser content: Input prompt from original prompt (\n{{ $('Get new video').item.json.PROMPT }}\n)\nSystem content: Instructions for YouTube SEO title generation (as per workflow)\nConnect input from Get Url Video node\nCreate HTTP Request Node to Download Video File\nType: HTTP Request\nName: Get File Video\nMethod: GET\nURL:\n={{ $('Get Url Video').item.json.video.url }}\nConnect input from Generate title node\nCreate HTTP Request Node to Upload Video to Postiz\nType: HTTP Request\nName: Upload Video to Postiz\nMethod: POST\nURL:\nhttps://api.postiz.com/public/v1/upload\nAuthentication: HTTP Header Auth\nHeader Name: Authorization\nHeader Value: Postiz API key (from Postiz account)\nContent-Type: multipart/form-data\nBody: form binary data, parameter name \"file\", input from Get File Video binary data\nConnect input from Get File Video node\nCreate Postiz Node to Post on TikTok\nType: Postiz (custom node)\nName: TikTok\nCredentials: Postiz API key\nParameters:\nDate: Current timestamp (use expression for now)\nPost content:\nImage: Use ID and path from Upload Video to Postiz response\nContent: Generated title from Generate title node\nIntegrationId: Set to your TikTok channel ID from Postiz\nShortLink: true\nConnect input from Upload Video to Postiz node\nAdd Sticky Notes as per need\nAdd sticky notes to explain API key setup (Fal.ai and Postiz)\nAdd notes for scheduling triggers and TikTok integration steps\nOptional: Configure Scheduling\nAdd a Schedule Trigger node if periodic automatic execution is needed, recommended every 5 minutes\n5. General Notes & Resources\nNote Content\nContext or Link\nCreate an account on\nFal.ai\nand obtain API Key for Sora 2 video generation.\nAPI key acquisition instructions\nCreate an account on\nPostiz\nwith a free 7-day trial for TikTok.\nPostiz account and TikTok channel integration setup\nPostiz allows connecting social accounts and obtaining ChannelId for scheduling posts.\nPostiz TikTok integration instructions\nWorkflow requires self-hosted n8n due to community nodes compatibility.\nCompatibility notice\nSchedule trigger recommended at 5-minute intervals for batch processing or repeated runs.\nScheduling advice\nDisclaimer:\nThe text provided is generated strictly from an automated n8n workflow. It complies fully with content policies and contains no illegal, offensive, or protected content. All data handled is legal and public.\nCopied to clipboard\n\n",
      "category": "Marketing",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Davide",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/generate-funny-ai-videos-with-sora-2-and-auto-publish-to-tiktok-10212",
      "nodes_count": 16
    },
    {
      "id": "004",
      "slug": "gnrez-des-vidos-virales-ia-avec-nanobanana-et-veo3-partages-sur-les-rseaux-sociaux-via-blotato",
      "title_en": "Generate AI viral videos with NanoBanana & VEO3, shared on socials via Blotato",
      "title_fr": "G√©n√©rez des vid√©os virales IA avec NanoBanana et VEO3, partag√©es sur les r√©seaux sociaux via Blotato",
      "description_short_en": "Automate viral video creation with NanoBanana & AI‚Äîedit, script, publish, and track across all major social platforms in minutes. Learn more now!",
      "description_short_fr": "Automatisez la cr√©ation de vid√©os virales avec NanoBanana et l'IA¬†: √©ditez, scriptez, publiez et suivez sur toutes les principales plateformes sociales en quelques minutes. Apprenez-en davantage maintenant¬†!",
      "description_full_en": "Generate AI viral videos with NanoBanana & VEO3, shared on socials via Blotato\n1. Workflow Overview\nThis workflow automates the creation, enhancement, and multi-platform sharing of AI-generated viral videos by leveraging NanoBanana for image editing, VEO3 for video generation, and Blotato for social media distribution. It is designed for content creators and marketers aiming to produce engaging UGC-style video ads from Telegram-submitted ideas and images, streamline captioning, and publish seamlessly across multiple social networks.\nThe workflow is logically divided into five functional blocks:\n1.1 Input Reception:\nCollects user-submitted video ideas and images from Telegram.\n1.2 Image Processing & Prompt Generation:\nAnalyzes the reference image, generates a refined image prompt, and enhances the image using NanoBanana.\n1.3 Video Script & Generation:\nCreates a structured video script prompt via OpenAI, formats it, and triggers video generation through VEO3.\n1.4 Caption Refinement & Logging:\nRewrites video captions using GPT-4o and logs all relevant metadata and status updates into Google Sheets.\n1.5 Multi-Platform Auto-Posting:\nUploads the generated video to Blotato and automatically posts it on various social platforms, followed by status updates and final Telegram notifications.\n2. Block-by-Block Analysis\n1.1 Input Reception\nOverview:\nReceives video idea submissions from Telegram users, retrieves the associated image file, and uploads it to Google Drive while logging the initial data in Google Sheets.\nNodes Involved:\nTelegram Trigger: Receive Video Idea\nTelegram: Get Image File\nGoogle Drive: Upload Image\nGoogle Sheets: Log Image & Caption\nSet: Bot Token (Placeholder)\nTelegram API: Get File URL\nNode Details:\nTelegram Trigger: Receive Video Idea\nType:\nTelegram Trigger\nRole:\nEntry point; listens for incoming messages with video ideas and images.\nConfig:\nListens to all message updates.\nInputs:\nTelegram messages with photo and caption.\nOutputs:\nPasses message JSON to downstream nodes.\nEdge Cases:\nMissing photo or caption; Telegram API downtime.\nTelegram: Get Image File\nType:\nTelegram API node\nRole:\nDownloads the third-size photo file from Telegram message.\nConfig:\nUses photo[2].file_id from the trigger.\nInputs:\nPhoto file ID from Telegram trigger.\nOutputs:\nRaw file data for upload.\nEdge Cases:\nFile not found or expired; API rate limits.\nGoogle Drive: Upload Image\nType:\nGoogle Drive node\nRole:\nUploads the downloaded image to a specified Google Drive folder.\nConfig:\nUses unique photo file ID as filename; public folder required.\nInputs:\nImage file from Telegram node.\nOutputs:\nProvides publicly accessible webContentLink for image.\nEdge Cases:\nPermission errors; folder not public.\nGoogle Sheets: Log Image & Caption\nType:\nGoogle Sheets (append/update)\nRole:\nLogs image metadata, caption, and initial status \"EN COURS\" in a Google Sheet.\nConfig:\nMatches rows by \"IMAGE NAME\" (file unique ID).\nInputs:\nImage URL, caption, image name from previous nodes.\nOutputs:\nConfirms log success.\nEdge Cases:\nSheet permissions; data mismatch.\nSet: Bot Token (Placeholder)\nType:\nSet node\nRole:\nPlaceholder for Telegram bot token, used dynamically downstream.\nConfig:\nEmpty token string, must be set in production.\nInputs:\nNone from previous nodes, set manually.\nOutputs:\nSupplies token for HTTP request.\nEdge Cases:\nMissing or invalid bot token breaks Telegram API calls.\nTelegram API: Get File URL\nType:\nHTTP Request\nRole:\nRetrieves the file path URL from Telegram API for the image (fourth photo size).\nConfig:\nUses bot token and photo[3].file_id.\nInputs:\nBot token and photo file ID from Set and Telegram trigger nodes.\nOutputs:\nFile path URL used for image analysis.\nEdge Cases:\nTelegram API errors; invalid token.\n1.2 Image Processing & Prompt Generation\nOverview:\nUses OpenAI Vision to analyze the uploaded image, updates the Google Sheet with descriptions, generates a natural UGC-style image prompt, and edits the image with NanoBanana AI.\nNodes Involved:\nOpenAI Vision: Analyze Reference Image\nGoogle Sheets: Update Image Description\nGenerate Image Prompt (Langchain Agent)\nNanoBanana: Create Image\nWait for Image Edit\nDownload Edited Image\nGoogle Sheets: Read Video Parameters (CONFIG)\nSet Master Prompt\nNode Details:\nOpenAI Vision: Analyze Reference Image\nType:\nOpenAI Vision API via Langchain node\nRole:\nAnalyzes the image and outputs YAML-formatted descriptive metadata for prompt generation.\nConfig:\nUses image URL from Telegram API getFile call.\nInputs:\nPublic image URL.\nOutputs:\nYAML description of image content (product/character).\nEdge Cases:\nImage URL invalid; API limits.\nGoogle Sheets: Update Image Description\nType:\nGoogle Sheets append/update\nRole:\nUpdates the image description field in the Google Sheet with the YAML output.\nConfig:\nMatches by \"IMAGE NAME\".\nInputs:\nYAML content from OpenAI Vision and IMAGE NAME.\nOutputs:\nConfirmation of update.\nEdge Cases:\nSheet write access issues.\nGenerate Image Prompt\nType:\nLangchain Agent\nRole:\nGenerates a concise, structured UGC-style image prompt JSON based on user caption and image description.\nConfig:\nSystem message enforces styling rules (casual, realistic, handheld camera cues).\nInputs:\nCaption and image description from Google Sheets.\nOutputs:\nJSON with single key\nimage_prompt\n.\nEdge Cases:\nOutput parsing failures; invalid JSON.\nNanoBanana: Create Image\nType:\nHTTP Request to NanoBanana API\nRole:\nSends the generated image prompt and original image URL to NanoBanana for AI-based image editing.\nConfig:\nUses HTTP header auth; prompt string escaped correctly.\nInputs:\nImage prompt JSON and Google Drive image URL.\nOutputs:\nResponse with editing task info including response_url.\nEdge Cases:\nAPI errors; authentication failures.\nWait for Image Edit\nType:\nWait node\nRole:\nPauses workflow for 20 seconds to allow NanoBanana to complete image editing.\nConfig:\nFixed 20-second wait.\nInputs:\nTriggered from NanoBanana response.\nOutputs:\nPasses after waiting.\nEdge Cases:\nInsufficient wait time causing premature requests.\nDownload Edited Image\nType:\nHTTP Request\nRole:\nDownloads the edited image from NanoBanana after wait.\nConfig:\nUses response_url from NanoBanana's output.\nInputs:\nURL from NanoBanana.\nOutputs:\nEdited image data including image URL(s).\nEdge Cases:\nURL expired; download failure.\nGoogle Sheets: Read Video Parameters (CONFIG)\nType:\nGoogle Sheets read\nRole:\nRetrieves video generation parameters (e.g., model type) from configuration spreadsheet.\nConfig:\nReads fixed sheet and document IDs.\nInputs:\nTriggered after edited image download.\nOutputs:\nJSON object containing video parameters.\nEdge Cases:\nConfig sheet missing or inaccessible.\nSet Master Prompt\nType:\nSet node\nRole:\nDefines the master structured schema for video prompt generation (JSON schema with detailed fields for scene, camera, lighting, etc.).\nConfig:\nContains a detailed JSON object as a string used by downstream AI agents.\nInputs:\nParameterized from Google Sheets output.\nOutputs:\nProvides standardized prompt template.\nEdge Cases:\nSchema syntax errors.\n1.3 Video Script & Generation\nOverview:\nGenerates a video script prompt using OpenAI GPT-4.1-mini and Langchain, formats the prompt, triggers video generation with VEO3, waits for rendering, and downloads the final video.\nNodes Involved:\nOpenAI Chat Model\nStructured Output Parser\nAI Agent: Generate Video Script\nFormat Prompt (Code node)\nGenerate Video with VEO3 (HTTP Request)\nWait for VEO3 Rendering\nDownload Video from VEO3\nNode Details:\nOpenAI Chat Model\nType:\nLangchain OpenAI Chat\nRole:\nRuns GPT-4.1-mini model to assist in creating AI video script prompts.\nConfig:\nUses system message with master prompt JSON from Set Master Prompt.\nInputs:\nMaster prompt schema and user inputs.\nOutputs:\nRaw AI output for parsing.\nEdge Cases:\nAPI quota exhaustion; model unavailability.\nStructured Output Parser\nType:\nLangchain Output Parser\nRole:\nParses raw AI output to structured JSON (e.g., title and full prompt).\nConfig:\nUses example JSON schema with\ntitle\nand\nfinal_prompt\nkeys.\nInputs:\nAI chat output.\nOutputs:\nParsed JSON for further use.\nEdge Cases:\nParsing failures due to malformed AI response.\nAI Agent: Generate Video Script\nType:\nLangchain Agent\nRole:\nGenerates a user-generated content style video prompt JSON object for VEO3 video generation.\nConfig:\nSystem message enforces strict JSON output, casual style, one object with\ntitle\nand\nfinal_prompt\n.\nInputs:\nCaption and image analysis, master prompt schema.\nOutputs:\nJSON with video prompt details.\nEdge Cases:\nInconsistent output format breaking downstream nodes.\nFormat Prompt\nType:\nCode node (JavaScript)\nRole:\nStringifies and escapes the final prompt JSON for VEO3 API compatibility.\nConfig:\nWraps final prompt as stringified JSON with model and aspectRatio parameters.\nInputs:\nParsed final_prompt JSON.\nOutputs:\nRequest body JSON for VEO3 API.\nEdge Cases:\nJSON stringification errors.\nGenerate Video with VEO3\nType:\nHTTP Request\nRole:\nCalls VEO3 API to generate video based on prompt and edited image.\nConfig:\nUses API key via HTTP header auth; POST with prompt, model, aspect ratio, and image URLs.\nInputs:\nFormatted prompt and video parameters.\nOutputs:\nTask ID for video rendering.\nEdge Cases:\nAPI rate limits; invalid parameters.\nWait for VEO3 Rendering\nType:\nWait node\nRole:\nWaits 20 seconds for VEO3 to complete video rendering.\nConfig:\nFixed 20-second delay.\nInputs:\nTask ID from video generation.\nOutputs:\nPasses to video download node.\nEdge Cases:\nRendering delay longer than wait time.\nDownload Video from VEO3\nType:\nHTTP Request\nRole:\nRetrieves the rendered video URL(s) from VEO3 using task ID.\nConfig:\nGET request with taskId query.\nInputs:\nTask ID from previous node.\nOutputs:\nFinal video URLs for distribution.\nEdge Cases:\nTask not completed; invalid taskId.\n1.4 Caption Refinement & Logging\nOverview:\nRefines the video caption using GPT-4o, saves final metadata and status in Google Sheets, and sends the video URL back to the Telegram user.\nNodes Involved:\nRewrite Caption with GPT-4o\nSave Caption Video to Google Sheets\nSend Video URL via Telegram\nSend Final Video Preview\nUpdate Status to \"DONE\"\nTelegram: Send notification\nNode Details:\nRewrite Caption with GPT-4o\nType:\nLangchain OpenAI node\nRole:\nRewrites the TikTok-style caption to be under 200 characters, following strict output rules.\nConfig:\nUses GPT-4o model; prompt includes video idea caption and video title.\nInputs:\nCaption and title from Telegram and AI Agent nodes.\nOutputs:\nConcise caption text.\nEdge Cases:\nCaption exceeding length; API errors.\nSave Caption Video to Google Sheets\nType:\nGoogle Sheets append/update\nRole:\nLogs finalized video metadata including title, caption, video URL, and status \"CREATE\".\nConfig:\nMatches row by \"IMAGE NAME\".\nInputs:\nCaption text, video title, and final video URL.\nOutputs:\nConfirmation of save.\nEdge Cases:\nSheet access errors.\nSend Video URL via Telegram\nType:\nTelegram node\nRole:\nSends the generated video URL back to the user's Telegram chat.\nConfig:\nText message containing video URL.\nInputs:\nFinal video URL and chat ID from Telegram trigger.\nOutputs:\nConfirmation of send.\nEdge Cases:\nTelegram API errors or invalid chat ID.\nSend Final Video Preview\nType:\nTelegram node\nRole:\nSends the final video as a video file preview to Telegram chat.\nConfig:\nUses video URL from Google Sheets.\nInputs:\nChat ID and video URL.\nOutputs:\nConfirmation of video sent.\nEdge Cases:\nVideo URL inaccessible; Telegram file size limits.\nUpdate Status to \"DONE\"\nType:\nGoogle Sheets append/update\nRole:\nUpdates the status field to \"Published\" for the processed video.\nConfig:\nMatches by \"IMAGE NAME\" (unique file ID).\nInputs:\nStatus update data.\nOutputs:\nConfirmation.\nEdge Cases:\nConcurrent updates; sheet conflicts.\nTelegram: Send notification\nType:\nTelegram node\nRole:\nSends a simple \"Published\" notification message to the Telegram user chat.\nConfig:\nText message with static \"Published\".\nInputs:\nChat ID from Telegram trigger.\nOutputs:\nConfirmation.\nEdge Cases:\nTelegram downtime.\n1.5 Multi-Platform Auto-Posting\nOverview:\nUploads the final video to Blotato and posts simultaneously across multiple social media platforms using Blotato nodes.\nNodes Involved:\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nThreads\nBluesky\nPinterest\nMerge\nNode Details:\nUpload Video to BLOTATO\nType:\nBlotato media upload node\nRole:\nUploads video file URL to Blotato media library for further posting.\nConfig:\nUses video URL from VEO3 download node.\nInputs:\nVideo URL from \"Download Video from VEO3\".\nOutputs:\nMedia URL for social posting nodes.\nCredentials:\nBlotato API credentials required.\nEdge Cases:\nUpload failure; API limits.\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nType:\nBlotato social post nodes\nRole:\nEach node posts the video with the caption text on its respective platform using Blotato.\nConfig:\nPlatforms configured with respective account IDs; captions sourced dynamically from Google Sheets (\"CAPTION VIDEO\"); media URLs from Blotato upload.\nInputs:\nMedia URL and caption text.\nOutputs:\nPost success/failure responses.\nCredentials:\nShared Blotato API credentials.\nEdge Cases:\nPlatform-specific posting restrictions; quota limits; media format issues.\nMerge\nType:\nMerge node (chooseBranch mode)\nRole:\nCollects outputs from all platform posting nodes to proceed to status update.\nConfig:\nWaits for any one branch to finish among nine inputs.\nInputs:\nAll social post nodes as inputs.\nOutputs:\nSingle merged output to update status.\nEdge Cases:\nPartial failures; node timeout.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger: Receive Video Idea\nTelegram Trigger\nEntry - receive video idea from user\n-\nTelegram: Get Image File, Set: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Collect Idea & Image\nTelegram: Get Image File\nTelegram\nDownloads image from Telegram\nTelegram Trigger: Receive Video Idea\nGoogle Drive: Upload Image\n# üìë STEP 1 ‚Äî Collect Idea & Image\nGoogle Drive: Upload Image\nGoogle Drive\nUploads image to Google Drive\nTelegram: Get Image File\nGoogle Sheets: Log Image & Caption\n# üìë STEP 1 ‚Äî Collect Idea & Image\nGoogle Sheets: Log Image & Caption\nGoogle Sheets\nLogs image and caption metadata\nGoogle Drive: Upload Image\nSet: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Collect Idea & Image\nSet: Bot Token (Placeholder)\nSet\nSets Telegram bot token placeholder\nGoogle Sheets: Log Image & Caption, Telegram Trigger: Receive Video Idea\nTelegram API: Get File URL\n# üìë STEP 1 ‚Äî Collect Idea & Image\nTelegram API: Get File URL\nHTTP Request\nGets Telegram file URL for image\nSet: Bot Token (Placeholder)\nOpenAI Vision: Analyze Reference Image\n# üìë STEP 1 ‚Äî Collect Idea & Image\nOpenAI Vision: Analyze Reference Image\nLangchain OpenAI\nAnalyzes image and outputs YAML\nTelegram API: Get File URL\nGoogle Sheets: Update Image Description\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGoogle Sheets: Update Image Description\nGoogle Sheets\nUpdates image description in sheet\nOpenAI Vision: Analyze Reference Image\nGenerate Image Prompt\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGenerate Image Prompt\nLangchain Agent\nCreates UGC-style image prompt JSON\nGoogle Sheets: Update Image Description\nNanoBanana: Create Image\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nNanoBanana: Create Image\nHTTP Request (Fal.ai API)\nSends prompt and image for AI editing\nGenerate Image Prompt\nWait for Image Edit\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nWait for Image Edit\nWait\nWaits 20 seconds for image editing\nNanoBanana: Create Image\nDownload Edited Image\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nDownload Edited Image\nHTTP Request\nDownloads edited image\nWait for Image Edit\nGoogle Sheets: Read Video Parameters (CONFIG)\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGoogle Sheets: Read Video Parameters (CONFIG)\nGoogle Sheets\nReads video generation config\nDownload Edited Image\nSet Master Prompt\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nSet Master Prompt\nSet\nDefines master schema for video prompt\nGoogle Sheets: Read Video Parameters (CONFIG)\nAI Agent: Generate Video Script\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nOpenAI Chat Model\nLangchain OpenAI Chat\nBase LLM model for video script prompt\nSet Master Prompt\nStructured Output Parser\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nStructured Output Parser\nLangchain Output Parser\nParses AI chat output into JSON\nOpenAI Chat Model\nAI Agent: Generate Video Script\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nAI Agent: Generate Video Script\nLangchain Agent\nGenerates structured video prompt JSON\nStructured Output Parser, Think\nFormat Prompt\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nFormat Prompt\nCode\nPrepares JSON string prompt for API\nAI Agent: Generate Video Script\nGenerate Video with VEO3\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nGenerate Video with VEO3\nHTTP Request\nCalls VEO3 API to generate video\nFormat Prompt\nWait for VEO3 Rendering\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nWait for VEO3 Rendering\nWait\nWaits 20 seconds for video rendering\nGenerate Video with VEO3\nDownload Video from VEO3\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nDownload Video from VEO3\nHTTP Request\nDownloads final video URLs\nWait for VEO3 Rendering\nRewrite Caption with GPT-4o\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nRewrite Caption with GPT-4o\nLangchain OpenAI\nRewrites caption under 200 chars\nDownload Video from VEO3\nSave Caption Video to Google Sheets\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nSave Caption Video to Google Sheets\nGoogle Sheets\nLogs final caption, title, video URL\nRewrite Caption with GPT-4o\nSend Video URL via Telegram\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nSend Video URL via Telegram\nTelegram\nSends video URL text to Telegram chat\nSave Caption Video to Google Sheets\nSend Final Video Preview\nSend Final Video Preview\nTelegram\nSends video file preview to Telegram\nSend Video URL via Telegram\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato\nUploads video to Blotato media library\nSend Final Video Preview\nTiktok, Linkedin, Facebook, Instagram, etc.\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTiktok\nBlotato\nPosts video on TikTok\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nLinkedin\nBlotato\nPosts video on LinkedIn\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nFacebook\nBlotato\nPosts video on Facebook\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nInstagram\nBlotato\nPosts video on Instagram\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTwitter (X)\nBlotato\nPosts video on Twitter (X)\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nYoutube\nBlotato\nPosts video on YouTube (private)\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nThreads\nBlotato\nPosts video on Threads\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nBluesky\nBlotato\nPosts video on Bluesky\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nPinterest\nBlotato\nPosts video on Pinterest board\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nMerge\nMerge\nAggregates all social post outputs\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nUpdate Status to \"DONE\"\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nUpdate Status to \"DONE\"\nGoogle Sheets\nUpdates status to ‚ÄúPublished‚Äù\nMerge\nTelegram: Send notification\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTelegram: Send notification\nTelegram\nSends \"Published\" notification\nUpdate Status to \"DONE\"\n-\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nThink\nLangchain Tool Think\nTool helper for AI agent\nOpenAI Chat Model\nAI Agent: Generate Video Script\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger: Receive Video Idea\nType: Telegram Trigger\nCredentials: Connect your Telegram bot.\nParameters: Listen for message updates.\nAdd Telegram Get Image File node\nType: Telegram\nOperation: Get file using photo[2].file_id from trigger.\nConnect from Telegram Trigger.\nAdd Google Drive Upload node\nType: Google Drive\nUpload the downloaded image file.\nUse photo[2].file_unique_id as file name.\nConfigure target folder (must be public).\nConnect from Telegram Get Image File.\nAdd Google Sheets Log Image & Caption node\nType: Google Sheets Append/Update\nLog IMAGE NAME, IMAGE URL (Google Drive webContentLink), CAPTION, STATUS=\"EN COURS\".\nMatch rows by IMAGE NAME.\nConnect from Google Drive Upload node.\nAdd Set node for Bot Token (Placeholder)\nSet a variable YOUR_BOT_TOKEN (empty string placeholder).\nConnect from Google Sheets Log node and Telegram Trigger node (parallel).\nAdd HTTP Request node to get Telegram file path\nURL:\nhttps://api.telegram.org/bot{{YOUR_BOT_TOKEN}}/getFile?file_id={{photo[3].file_id}}\nConnect from Set Bot Token node.\nAdd OpenAI Vision node\nType: Langchain OpenAI (image analysis)\nInput image URL: Constructed from Telegram file path result.\nOutputs YAML description.\nConnect from Telegram API Get File URL node.\nAdd Google Sheets Update Image Description node\nAppend/update IMAGE DESCRIPTION with YAML from OpenAI Vision.\nMatch by IMAGE NAME.\nConnect from OpenAI Vision node.\nAdd Langchain Agent node Generate Image Prompt\nInput: CAPTION and IMAGE DESCRIPTION.\nSystem prompt: UGC Image Prompt Builder (as per detailed system message).\nOutput: Single JSON key\nimage_prompt\n.\nConnect from Google Sheets Update Image Description node.\nAdd HTTP Request node NanoBanana: Create Image\nPOST to NanoBanana API with JSON body containing prompt and Google Drive image URL.\nUse HTTP Header Auth (Fal.ai credentials).\nConnect from Generate Image Prompt node.\nAdd Wait node (20s) for image editing\nConnect from NanoBanana Create Image node.\nAdd HTTP Request node Download Edited Image\nGET request to NanoBanana response_url.\nConnect from Wait node.\nAdd Google Sheets Read Video Parameters (CONFIG) node\nReads video generation config parameters.\nConnect from Download Edited Image node.\nAdd Set Master Prompt node\nSet the detailed JSON schema for video prompt.\nConnect from Google Sheets Read Video Parameters node.\nAdd Langchain OpenAI Chat Model node\nModel: GPT-4.1-mini\nConnect from Set Master Prompt node.\nAdd Structured Output Parser node\nParses AI chat output to structured JSON with\ntitle\nand\nfinal_prompt\n.\nConnect from OpenAI Chat Model node.\nAdd Langchain Agent AI Agent: Generate Video Script node\nSystem prompt: Structured Video Ad Prompt Generator (as defined).\nInputs: caption, image description, master prompt schema.\nConnect from Structured Output Parser.\nAdd Code node Format Prompt\nStringify and escape final_prompt JSON to prepare for API.\nConnect from AI Agent Generate Video Script node.\nAdd HTTP Request Generate Video with VEO3 node\nPOST to VEO3 API with prompt, model, aspectRatio, image URLs.\nUse HTTP Header Auth (Kie AI credentials).\nConnect from Format Prompt node.\nAdd Wait node (20s) for VEO3 rendering\nConnect from Generate Video with VEO3 node.\nAdd HTTP Request Download Video from VEO3 node\nGET with taskId from video generation node.\nConnect from Wait for VEO3 Rendering node.\nAdd Langchain OpenAI Rewrite Caption with GPT-4o node\nRewrites caption text to ‚â§200 chars.\nConnect from Download Video from VEO3 node.\nAdd Google Sheets Save Caption Video node\nAppend/update with STATUS=\"CREATE\", video title, caption, final video URL.\nMatch by IMAGE NAME.\nConnect from Rewrite Caption node.\nAdd Telegram Send Video URL node\nSends text message with video URL to Telegram chat.\nConnect from Save Caption Video node.\nAdd Telegram Send Final Video Preview node\nSends video file preview to Telegram chat.\nConnect from Telegram Send Video URL node.\nAdd Blotato Upload Video node\nUpload final video URL to Blotato media library.\nConnect from Telegram Send Final Video Preview node.\nAdd Blotato social posting nodes for Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nConfigure each with correct account IDs and platform.\nUse caption from Google Sheets and media URL from Blotato upload.\nConnect all from Upload Video to BLOTATO node.\nAdd Merge node (chooseBranch mode, 9 inputs)\nAggregates outputs from all social posting nodes.\nConnect all social nodes to Merge node.\nAdd Google Sheets Update Status to \"DONE\" node\nUpdates status to \"Published\" for the image/video entry.\nConnect from Merge node.\nAdd Telegram Send Notification node\nSends \"Published\" message to Telegram user.\nConnect from Update Status to \"DONE\" node.\n5. General Notes & Resources\nNote Content\nContext or Link\nFull tutorial video and branding image provided by Dr. Firas.\nYouTube Tutorial\nFull documentation with setup instructions, API configs, and customization tips available on Notion.\nNotion Documentation\nRequirements include a Blotato Pro plan, API key generation, enabling verified community nodes in n8n, and public Google Drive folder.\nBlotato\n, Google Sheets template shared in workflow notes.\nWorkflow uses verified community nodes from Blotato and OpenAI credentials; ensure proper credential setup.\nCredential management recommended in n8n docs.\nDisclaimer:\nThe provided text is exclusively derived from an automated n8n workflow. It strictly follows content policies and contains no illegal or protected elements. All data processed is legal and public.\nCopied to clipboard",
      "description_full_fr": "Generate AI viral videos with NanoBanana & VEO3, shared on socials via Blotato\n1. Workflow Overview\nThis workflow automates the creation, enhancement, and multi-platform sharing of AI-generated viral videos by leveraging NanoBanana for image editing, VEO3 for video generation, and Blotato for social media distribution. It is designed for content creators and marketers aiming to produce engaging UGC-style video ads from Telegram-submitted ideas and images, streamline captioning, and publish seamlessly across multiple social networks.\nThe workflow is logically divided into five functional blocks:\n1.1 Input Reception:\nCollects user-submitted video ideas and images from Telegram.\n1.2 Image Processing & Prompt Generation:\nAnalyzes the reference image, generates a refined image prompt, and enhances the image using NanoBanana.\n1.3 Video Script & Generation:\nCreates a structured video script prompt via OpenAI, formats it, and triggers video generation through VEO3.\n1.4 Caption Refinement & Logging:\nRewrites video captions using GPT-4o and logs all relevant metadata and status updates into Google Sheets.\n1.5 Multi-Platform Auto-Posting:\nUploads the generated video to Blotato and automatically posts it on various social platforms, followed by status updates and final Telegram notifications.\n2. Block-by-Block Analysis\n1.1 Input Reception\nOverview:\nReceives video idea submissions from Telegram users, retrieves the associated image file, and uploads it to Google Drive while logging the initial data in Google Sheets.\nNodes Involved:\nTelegram Trigger: Receive Video Idea\nTelegram: Get Image File\nGoogle Drive: Upload Image\nGoogle Sheets: Log Image & Caption\nSet: Bot Token (Placeholder)\nTelegram API: Get File URL\nNode Details:\nTelegram Trigger: Receive Video Idea\nType:\nTelegram Trigger\nRole:\nEntry point; listens for incoming messages with video ideas and images.\nConfig:\nListens to all message updates.\nInputs:\nTelegram messages with photo and caption.\nOutputs:\nPasses message JSON to downstream nodes.\nEdge Cases:\nMissing photo or caption; Telegram API downtime.\nTelegram: Get Image File\nType:\nTelegram API node\nRole:\nDownloads the third-size photo file from Telegram message.\nConfig:\nUses photo[2].file_id from the trigger.\nInputs:\nPhoto file ID from Telegram trigger.\nOutputs:\nRaw file data for upload.\nEdge Cases:\nFile not found or expired; API rate limits.\nGoogle Drive: Upload Image\nType:\nGoogle Drive node\nRole:\nUploads the downloaded image to a specified Google Drive folder.\nConfig:\nUses unique photo file ID as filename; public folder required.\nInputs:\nImage file from Telegram node.\nOutputs:\nProvides publicly accessible webContentLink for image.\nEdge Cases:\nPermission errors; folder not public.\nGoogle Sheets: Log Image & Caption\nType:\nGoogle Sheets (append/update)\nRole:\nLogs image metadata, caption, and initial status \"EN COURS\" in a Google Sheet.\nConfig:\nMatches rows by \"IMAGE NAME\" (file unique ID).\nInputs:\nImage URL, caption, image name from previous nodes.\nOutputs:\nConfirms log success.\nEdge Cases:\nSheet permissions; data mismatch.\nSet: Bot Token (Placeholder)\nType:\nSet node\nRole:\nPlaceholder for Telegram bot token, used dynamically downstream.\nConfig:\nEmpty token string, must be set in production.\nInputs:\nNone from previous nodes, set manually.\nOutputs:\nSupplies token for HTTP request.\nEdge Cases:\nMissing or invalid bot token breaks Telegram API calls.\nTelegram API: Get File URL\nType:\nHTTP Request\nRole:\nRetrieves the file path URL from Telegram API for the image (fourth photo size).\nConfig:\nUses bot token and photo[3].file_id.\nInputs:\nBot token and photo file ID from Set and Telegram trigger nodes.\nOutputs:\nFile path URL used for image analysis.\nEdge Cases:\nTelegram API errors; invalid token.\n1.2 Image Processing & Prompt Generation\nOverview:\nUses OpenAI Vision to analyze the uploaded image, updates the Google Sheet with descriptions, generates a natural UGC-style image prompt, and edits the image with NanoBanana AI.\nNodes Involved:\nOpenAI Vision: Analyze Reference Image\nGoogle Sheets: Update Image Description\nGenerate Image Prompt (Langchain Agent)\nNanoBanana: Create Image\nWait for Image Edit\nDownload Edited Image\nGoogle Sheets: Read Video Parameters (CONFIG)\nSet Master Prompt\nNode Details:\nOpenAI Vision: Analyze Reference Image\nType:\nOpenAI Vision API via Langchain node\nRole:\nAnalyzes the image and outputs YAML-formatted descriptive metadata for prompt generation.\nConfig:\nUses image URL from Telegram API getFile call.\nInputs:\nPublic image URL.\nOutputs:\nYAML description of image content (product/character).\nEdge Cases:\nImage URL invalid; API limits.\nGoogle Sheets: Update Image Description\nType:\nGoogle Sheets append/update\nRole:\nUpdates the image description field in the Google Sheet with the YAML output.\nConfig:\nMatches by \"IMAGE NAME\".\nInputs:\nYAML content from OpenAI Vision and IMAGE NAME.\nOutputs:\nConfirmation of update.\nEdge Cases:\nSheet write access issues.\nGenerate Image Prompt\nType:\nLangchain Agent\nRole:\nGenerates a concise, structured UGC-style image prompt JSON based on user caption and image description.\nConfig:\nSystem message enforces styling rules (casual, realistic, handheld camera cues).\nInputs:\nCaption and image description from Google Sheets.\nOutputs:\nJSON with single key\nimage_prompt\n.\nEdge Cases:\nOutput parsing failures; invalid JSON.\nNanoBanana: Create Image\nType:\nHTTP Request to NanoBanana API\nRole:\nSends the generated image prompt and original image URL to NanoBanana for AI-based image editing.\nConfig:\nUses HTTP header auth; prompt string escaped correctly.\nInputs:\nImage prompt JSON and Google Drive image URL.\nOutputs:\nResponse with editing task info including response_url.\nEdge Cases:\nAPI errors; authentication failures.\nWait for Image Edit\nType:\nWait node\nRole:\nPauses workflow for 20 seconds to allow NanoBanana to complete image editing.\nConfig:\nFixed 20-second wait.\nInputs:\nTriggered from NanoBanana response.\nOutputs:\nPasses after waiting.\nEdge Cases:\nInsufficient wait time causing premature requests.\nDownload Edited Image\nType:\nHTTP Request\nRole:\nDownloads the edited image from NanoBanana after wait.\nConfig:\nUses response_url from NanoBanana's output.\nInputs:\nURL from NanoBanana.\nOutputs:\nEdited image data including image URL(s).\nEdge Cases:\nURL expired; download failure.\nGoogle Sheets: Read Video Parameters (CONFIG)\nType:\nGoogle Sheets read\nRole:\nRetrieves video generation parameters (e.g., model type) from configuration spreadsheet.\nConfig:\nReads fixed sheet and document IDs.\nInputs:\nTriggered after edited image download.\nOutputs:\nJSON object containing video parameters.\nEdge Cases:\nConfig sheet missing or inaccessible.\nSet Master Prompt\nType:\nSet node\nRole:\nDefines the master structured schema for video prompt generation (JSON schema with detailed fields for scene, camera, lighting, etc.).\nConfig:\nContains a detailed JSON object as a string used by downstream AI agents.\nInputs:\nParameterized from Google Sheets output.\nOutputs:\nProvides standardized prompt template.\nEdge Cases:\nSchema syntax errors.\n1.3 Video Script & Generation\nOverview:\nGenerates a video script prompt using OpenAI GPT-4.1-mini and Langchain, formats the prompt, triggers video generation with VEO3, waits for rendering, and downloads the final video.\nNodes Involved:\nOpenAI Chat Model\nStructured Output Parser\nAI Agent: Generate Video Script\nFormat Prompt (Code node)\nGenerate Video with VEO3 (HTTP Request)\nWait for VEO3 Rendering\nDownload Video from VEO3\nNode Details:\nOpenAI Chat Model\nType:\nLangchain OpenAI Chat\nRole:\nRuns GPT-4.1-mini model to assist in creating AI video script prompts.\nConfig:\nUses system message with master prompt JSON from Set Master Prompt.\nInputs:\nMaster prompt schema and user inputs.\nOutputs:\nRaw AI output for parsing.\nEdge Cases:\nAPI quota exhaustion; model unavailability.\nStructured Output Parser\nType:\nLangchain Output Parser\nRole:\nParses raw AI output to structured JSON (e.g., title and full prompt).\nConfig:\nUses example JSON schema with\ntitle\nand\nfinal_prompt\nkeys.\nInputs:\nAI chat output.\nOutputs:\nParsed JSON for further use.\nEdge Cases:\nParsing failures due to malformed AI response.\nAI Agent: Generate Video Script\nType:\nLangchain Agent\nRole:\nGenerates a user-generated content style video prompt JSON object for VEO3 video generation.\nConfig:\nSystem message enforces strict JSON output, casual style, one object with\ntitle\nand\nfinal_prompt\n.\nInputs:\nCaption and image analysis, master prompt schema.\nOutputs:\nJSON with video prompt details.\nEdge Cases:\nInconsistent output format breaking downstream nodes.\nFormat Prompt\nType:\nCode node (JavaScript)\nRole:\nStringifies and escapes the final prompt JSON for VEO3 API compatibility.\nConfig:\nWraps final prompt as stringified JSON with model and aspectRatio parameters.\nInputs:\nParsed final_prompt JSON.\nOutputs:\nRequest body JSON for VEO3 API.\nEdge Cases:\nJSON stringification errors.\nGenerate Video with VEO3\nType:\nHTTP Request\nRole:\nCalls VEO3 API to generate video based on prompt and edited image.\nConfig:\nUses API key via HTTP header auth; POST with prompt, model, aspect ratio, and image URLs.\nInputs:\nFormatted prompt and video parameters.\nOutputs:\nTask ID for video rendering.\nEdge Cases:\nAPI rate limits; invalid parameters.\nWait for VEO3 Rendering\nType:\nWait node\nRole:\nWaits 20 seconds for VEO3 to complete video rendering.\nConfig:\nFixed 20-second delay.\nInputs:\nTask ID from video generation.\nOutputs:\nPasses to video download node.\nEdge Cases:\nRendering delay longer than wait time.\nDownload Video from VEO3\nType:\nHTTP Request\nRole:\nRetrieves the rendered video URL(s) from VEO3 using task ID.\nConfig:\nGET request with taskId query.\nInputs:\nTask ID from previous node.\nOutputs:\nFinal video URLs for distribution.\nEdge Cases:\nTask not completed; invalid taskId.\n1.4 Caption Refinement & Logging\nOverview:\nRefines the video caption using GPT-4o, saves final metadata and status in Google Sheets, and sends the video URL back to the Telegram user.\nNodes Involved:\nRewrite Caption with GPT-4o\nSave Caption Video to Google Sheets\nSend Video URL via Telegram\nSend Final Video Preview\nUpdate Status to \"DONE\"\nTelegram: Send notification\nNode Details:\nRewrite Caption with GPT-4o\nType:\nLangchain OpenAI node\nRole:\nRewrites the TikTok-style caption to be under 200 characters, following strict output rules.\nConfig:\nUses GPT-4o model; prompt includes video idea caption and video title.\nInputs:\nCaption and title from Telegram and AI Agent nodes.\nOutputs:\nConcise caption text.\nEdge Cases:\nCaption exceeding length; API errors.\nSave Caption Video to Google Sheets\nType:\nGoogle Sheets append/update\nRole:\nLogs finalized video metadata including title, caption, video URL, and status \"CREATE\".\nConfig:\nMatches row by \"IMAGE NAME\".\nInputs:\nCaption text, video title, and final video URL.\nOutputs:\nConfirmation of save.\nEdge Cases:\nSheet access errors.\nSend Video URL via Telegram\nType:\nTelegram node\nRole:\nSends the generated video URL back to the user's Telegram chat.\nConfig:\nText message containing video URL.\nInputs:\nFinal video URL and chat ID from Telegram trigger.\nOutputs:\nConfirmation of send.\nEdge Cases:\nTelegram API errors or invalid chat ID.\nSend Final Video Preview\nType:\nTelegram node\nRole:\nSends the final video as a video file preview to Telegram chat.\nConfig:\nUses video URL from Google Sheets.\nInputs:\nChat ID and video URL.\nOutputs:\nConfirmation of video sent.\nEdge Cases:\nVideo URL inaccessible; Telegram file size limits.\nUpdate Status to \"DONE\"\nType:\nGoogle Sheets append/update\nRole:\nUpdates the status field to \"Published\" for the processed video.\nConfig:\nMatches by \"IMAGE NAME\" (unique file ID).\nInputs:\nStatus update data.\nOutputs:\nConfirmation.\nEdge Cases:\nConcurrent updates; sheet conflicts.\nTelegram: Send notification\nType:\nTelegram node\nRole:\nSends a simple \"Published\" notification message to the Telegram user chat.\nConfig:\nText message with static \"Published\".\nInputs:\nChat ID from Telegram trigger.\nOutputs:\nConfirmation.\nEdge Cases:\nTelegram downtime.\n1.5 Multi-Platform Auto-Posting\nOverview:\nUploads the final video to Blotato and posts simultaneously across multiple social media platforms using Blotato nodes.\nNodes Involved:\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nThreads\nBluesky\nPinterest\nMerge\nNode Details:\nUpload Video to BLOTATO\nType:\nBlotato media upload node\nRole:\nUploads video file URL to Blotato media library for further posting.\nConfig:\nUses video URL from VEO3 download node.\nInputs:\nVideo URL from \"Download Video from VEO3\".\nOutputs:\nMedia URL for social posting nodes.\nCredentials:\nBlotato API credentials required.\nEdge Cases:\nUpload failure; API limits.\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nType:\nBlotato social post nodes\nRole:\nEach node posts the video with the caption text on its respective platform using Blotato.\nConfig:\nPlatforms configured with respective account IDs; captions sourced dynamically from Google Sheets (\"CAPTION VIDEO\"); media URLs from Blotato upload.\nInputs:\nMedia URL and caption text.\nOutputs:\nPost success/failure responses.\nCredentials:\nShared Blotato API credentials.\nEdge Cases:\nPlatform-specific posting restrictions; quota limits; media format issues.\nMerge\nType:\nMerge node (chooseBranch mode)\nRole:\nCollects outputs from all platform posting nodes to proceed to status update.\nConfig:\nWaits for any one branch to finish among nine inputs.\nInputs:\nAll social post nodes as inputs.\nOutputs:\nSingle merged output to update status.\nEdge Cases:\nPartial failures; node timeout.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger: Receive Video Idea\nTelegram Trigger\nEntry - receive video idea from user\n-\nTelegram: Get Image File, Set: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Collect Idea & Image\nTelegram: Get Image File\nTelegram\nDownloads image from Telegram\nTelegram Trigger: Receive Video Idea\nGoogle Drive: Upload Image\n# üìë STEP 1 ‚Äî Collect Idea & Image\nGoogle Drive: Upload Image\nGoogle Drive\nUploads image to Google Drive\nTelegram: Get Image File\nGoogle Sheets: Log Image & Caption\n# üìë STEP 1 ‚Äî Collect Idea & Image\nGoogle Sheets: Log Image & Caption\nGoogle Sheets\nLogs image and caption metadata\nGoogle Drive: Upload Image\nSet: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Collect Idea & Image\nSet: Bot Token (Placeholder)\nSet\nSets Telegram bot token placeholder\nGoogle Sheets: Log Image & Caption, Telegram Trigger: Receive Video Idea\nTelegram API: Get File URL\n# üìë STEP 1 ‚Äî Collect Idea & Image\nTelegram API: Get File URL\nHTTP Request\nGets Telegram file URL for image\nSet: Bot Token (Placeholder)\nOpenAI Vision: Analyze Reference Image\n# üìë STEP 1 ‚Äî Collect Idea & Image\nOpenAI Vision: Analyze Reference Image\nLangchain OpenAI\nAnalyzes image and outputs YAML\nTelegram API: Get File URL\nGoogle Sheets: Update Image Description\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGoogle Sheets: Update Image Description\nGoogle Sheets\nUpdates image description in sheet\nOpenAI Vision: Analyze Reference Image\nGenerate Image Prompt\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGenerate Image Prompt\nLangchain Agent\nCreates UGC-style image prompt JSON\nGoogle Sheets: Update Image Description\nNanoBanana: Create Image\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nNanoBanana: Create Image\nHTTP Request (Fal.ai API)\nSends prompt and image for AI editing\nGenerate Image Prompt\nWait for Image Edit\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nWait for Image Edit\nWait\nWaits 20 seconds for image editing\nNanoBanana: Create Image\nDownload Edited Image\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nDownload Edited Image\nHTTP Request\nDownloads edited image\nWait for Image Edit\nGoogle Sheets: Read Video Parameters (CONFIG)\n# üìë STEP 2 ‚Äî Create Image with NanoBanana\nGoogle Sheets: Read Video Parameters (CONFIG)\nGoogle Sheets\nReads video generation config\nDownload Edited Image\nSet Master Prompt\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nSet Master Prompt\nSet\nDefines master schema for video prompt\nGoogle Sheets: Read Video Parameters (CONFIG)\nAI Agent: Generate Video Script\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nOpenAI Chat Model\nLangchain OpenAI Chat\nBase LLM model for video script prompt\nSet Master Prompt\nStructured Output Parser\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nStructured Output Parser\nLangchain Output Parser\nParses AI chat output into JSON\nOpenAI Chat Model\nAI Agent: Generate Video Script\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nAI Agent: Generate Video Script\nLangchain Agent\nGenerates structured video prompt JSON\nStructured Output Parser, Think\nFormat Prompt\n# üìë STEP 3 ‚Äî Generate Video Ad Script\nFormat Prompt\nCode\nPrepares JSON string prompt for API\nAI Agent: Generate Video Script\nGenerate Video with VEO3\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nGenerate Video with VEO3\nHTTP Request\nCalls VEO3 API to generate video\nFormat Prompt\nWait for VEO3 Rendering\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nWait for VEO3 Rendering\nWait\nWaits 20 seconds for video rendering\nGenerate Video with VEO3\nDownload Video from VEO3\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nDownload Video from VEO3\nHTTP Request\nDownloads final video URLs\nWait for VEO3 Rendering\nRewrite Caption with GPT-4o\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nRewrite Caption with GPT-4o\nLangchain OpenAI\nRewrites caption under 200 chars\nDownload Video from VEO3\nSave Caption Video to Google Sheets\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nSave Caption Video to Google Sheets\nGoogle Sheets\nLogs final caption, title, video URL\nRewrite Caption with GPT-4o\nSend Video URL via Telegram\n# üìë STEP 4 ‚Äî Generate Video with VEO3\nSend Video URL via Telegram\nTelegram\nSends video URL text to Telegram chat\nSave Caption Video to Google Sheets\nSend Final Video Preview\nSend Final Video Preview\nTelegram\nSends video file preview to Telegram\nSend Video URL via Telegram\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato\nUploads video to Blotato media library\nSend Final Video Preview\nTiktok, Linkedin, Facebook, Instagram, etc.\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTiktok\nBlotato\nPosts video on TikTok\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nLinkedin\nBlotato\nPosts video on LinkedIn\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nFacebook\nBlotato\nPosts video on Facebook\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nInstagram\nBlotato\nPosts video on Instagram\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTwitter (X)\nBlotato\nPosts video on Twitter (X)\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nYoutube\nBlotato\nPosts video on YouTube (private)\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nThreads\nBlotato\nPosts video on Threads\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nBluesky\nBlotato\nPosts video on Bluesky\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nPinterest\nBlotato\nPosts video on Pinterest board\nUpload Video to BLOTATO\nMerge\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nMerge\nMerge\nAggregates all social post outputs\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nUpdate Status to \"DONE\"\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nUpdate Status to \"DONE\"\nGoogle Sheets\nUpdates status to ‚ÄúPublished‚Äù\nMerge\nTelegram: Send notification\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nTelegram: Send notification\nTelegram\nSends \"Published\" notification\nUpdate Status to \"DONE\"\n-\n# üìë STEP 5 ‚Äî Auto-Post to All Platforms\nThink\nLangchain Tool Think\nTool helper for AI agent\nOpenAI Chat Model\nAI Agent: Generate Video Script\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger: Receive Video Idea\nType: Telegram Trigger\nCredentials: Connect your Telegram bot.\nParameters: Listen for message updates.\nAdd Telegram Get Image File node\nType: Telegram\nOperation: Get file using photo[2].file_id from trigger.\nConnect from Telegram Trigger.\nAdd Google Drive Upload node\nType: Google Drive\nUpload the downloaded image file.\nUse photo[2].file_unique_id as file name.\nConfigure target folder (must be public).\nConnect from Telegram Get Image File.\nAdd Google Sheets Log Image & Caption node\nType: Google Sheets Append/Update\nLog IMAGE NAME, IMAGE URL (Google Drive webContentLink), CAPTION, STATUS=\"EN COURS\".\nMatch rows by IMAGE NAME.\nConnect from Google Drive Upload node.\nAdd Set node for Bot Token (Placeholder)\nSet a variable YOUR_BOT_TOKEN (empty string placeholder).\nConnect from Google Sheets Log node and Telegram Trigger node (parallel).\nAdd HTTP Request node to get Telegram file path\nURL:\nhttps://api.telegram.org/bot{{YOUR_BOT_TOKEN}}/getFile?file_id={{photo[3].file_id}}\nConnect from Set Bot Token node.\nAdd OpenAI Vision node\nType: Langchain OpenAI (image analysis)\nInput image URL: Constructed from Telegram file path result.\nOutputs YAML description.\nConnect from Telegram API Get File URL node.\nAdd Google Sheets Update Image Description node\nAppend/update IMAGE DESCRIPTION with YAML from OpenAI Vision.\nMatch by IMAGE NAME.\nConnect from OpenAI Vision node.\nAdd Langchain Agent node Generate Image Prompt\nInput: CAPTION and IMAGE DESCRIPTION.\nSystem prompt: UGC Image Prompt Builder (as per detailed system message).\nOutput: Single JSON key\nimage_prompt\n.\nConnect from Google Sheets Update Image Description node.\nAdd HTTP Request node NanoBanana: Create Image\nPOST to NanoBanana API with JSON body containing prompt and Google Drive image URL.\nUse HTTP Header Auth (Fal.ai credentials).\nConnect from Generate Image Prompt node.\nAdd Wait node (20s) for image editing\nConnect from NanoBanana Create Image node.\nAdd HTTP Request node Download Edited Image\nGET request to NanoBanana response_url.\nConnect from Wait node.\nAdd Google Sheets Read Video Parameters (CONFIG) node\nReads video generation config parameters.\nConnect from Download Edited Image node.\nAdd Set Master Prompt node\nSet the detailed JSON schema for video prompt.\nConnect from Google Sheets Read Video Parameters node.\nAdd Langchain OpenAI Chat Model node\nModel: GPT-4.1-mini\nConnect from Set Master Prompt node.\nAdd Structured Output Parser node\nParses AI chat output to structured JSON with\ntitle\nand\nfinal_prompt\n.\nConnect from OpenAI Chat Model node.\nAdd Langchain Agent AI Agent: Generate Video Script node\nSystem prompt: Structured Video Ad Prompt Generator (as defined).\nInputs: caption, image description, master prompt schema.\nConnect from Structured Output Parser.\nAdd Code node Format Prompt\nStringify and escape final_prompt JSON to prepare for API.\nConnect from AI Agent Generate Video Script node.\nAdd HTTP Request Generate Video with VEO3 node\nPOST to VEO3 API with prompt, model, aspectRatio, image URLs.\nUse HTTP Header Auth (Kie AI credentials).\nConnect from Format Prompt node.\nAdd Wait node (20s) for VEO3 rendering\nConnect from Generate Video with VEO3 node.\nAdd HTTP Request Download Video from VEO3 node\nGET with taskId from video generation node.\nConnect from Wait for VEO3 Rendering node.\nAdd Langchain OpenAI Rewrite Caption with GPT-4o node\nRewrites caption text to ‚â§200 chars.\nConnect from Download Video from VEO3 node.\nAdd Google Sheets Save Caption Video node\nAppend/update with STATUS=\"CREATE\", video title, caption, final video URL.\nMatch by IMAGE NAME.\nConnect from Rewrite Caption node.\nAdd Telegram Send Video URL node\nSends text message with video URL to Telegram chat.\nConnect from Save Caption Video node.\nAdd Telegram Send Final Video Preview node\nSends video file preview to Telegram chat.\nConnect from Telegram Send Video URL node.\nAdd Blotato Upload Video node\nUpload final video URL to Blotato media library.\nConnect from Telegram Send Final Video Preview node.\nAdd Blotato social posting nodes for Tiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube, Threads, Bluesky, Pinterest\nConfigure each with correct account IDs and platform.\nUse caption from Google Sheets and media URL from Blotato upload.\nConnect all from Upload Video to BLOTATO node.\nAdd Merge node (chooseBranch mode, 9 inputs)\nAggregates outputs from all social posting nodes.\nConnect all social nodes to Merge node.\nAdd Google Sheets Update Status to \"DONE\" node\nUpdates status to \"Published\" for the image/video entry.\nConnect from Merge node.\nAdd Telegram Send Notification node\nSends \"Published\" message to Telegram user.\nConnect from Update Status to \"DONE\" node.\n5. General Notes & Resources\nNote Content\nContext or Link\nFull tutorial video and branding image provided by Dr. Firas.\nYouTube Tutorial\nFull documentation with setup instructions, API configs, and customization tips available on Notion.\nNotion Documentation\nRequirements include a Blotato Pro plan, API key generation, enabling verified community nodes in n8n, and public Google Drive folder.\nBlotato\n, Google Sheets template shared in workflow notes.\nWorkflow uses verified community nodes from Blotato and OpenAI credentials; ensure proper credential setup.\nCredential management recommended in n8n docs.\nDisclaimer:\nThe provided text is exclusively derived from an automated n8n workflow. It strictly follows content policies and contains no illegal or protected elements. All data processed is legal and public.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Dr. Firas",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/generate-ai-viral-videos-with-nanobanana-veo3-shared-on-socials-via-blotato-8270",
      "nodes_count": 47
    },
    {
      "id": "005",
      "slug": "suivi-nutritionnel-et-enregistreur-de-repas-avec-telegram-gemini-ai-et-google-sheets",
      "title_en": "Nutrition Tracker & Meal Logger with Telegram, Gemini AI and Google Sheets",
      "title_fr": "Suivi nutritionnel et enregistreur de repas avec Telegram, Gemini AI et Google Sheets",
      "description_short_en": "AI-powered nutrition assistant for Telegram: log meals with text, voice, or photos, set goals, and get personalized daily reports‚ÄîGoogle Sheets integration.",
      "description_short_fr": "Assistant nutritionnel aliment√© par l'IA pour Telegram¬†: enregistrez vos repas avec du texte, de la voix ou des photos, d√©finissez des objectifs et obtenez des rapports quotidiens personnalis√©s¬†‚Äì¬†int√©gration de Google Sheets.",
      "description_full_en": "Nutrition Tracker & Meal Logger with Telegram, Gemini AI and Google Sheets\n1. Workflow Overview\nThis workflow implements a\nNutrition Tracker & Meal Logger\nthat allows users to interact via Telegram to log meals, receive nutritional analysis, and track their nutrition goals. It integrates\nTelegram\n,\nGoogle Sheets\nfor data storage, and\nGoogle Gemini AI\nfor processing and understanding text, voice, and images.\nThe workflow is logically divided into the following blocks:\n1.1 User Input Capture and Routing\nHandles incoming Telegram messages (text, voice, images), routes them based on content type for further processing.\n1.2 User Registration Validation and Management\nChecks if users are registered, and if not, runs a registration agent workflow to collect user profile and nutrition targets.\n1.3 Message Processing and AI Analysis\nProcesses text messages directly; downloads and transcribes voice messages using AI; downloads and analyzes food images with AI vision for nutritional content.\n1.4 Meal Data Storage and Profile Updates\nStores parsed meal information into Google Sheets, updates user profiles if requested, and manages user data retrieval.\n1.5 Report Generation and Delivery\nGenerates daily nutrition summaries with progress bars and sends personalized reports to users.\n1.6 Message Formatting and Telegram Response\nFormats messages safely in Telegram MarkdownV2, chunks long messages, and sends responses back to Telegram.\n2. Block-by-Block Analysis\n2.1 User Input Capture and Routing\nOverview:\nThis block captures all incoming messages from Telegram users and routes them based on whether the input is text, voice, or image.\nNodes Involved:\nTelegram Trigger\nInput Message Router1\nDownload Voice Message\nFix mime (for audio)\nAnalyze voice message\nget_message (Audio/Video message)\nDownload IMAGE\nFix mime5 (for images)\nAnalyze image\nget_message (Media message)\nget_message (text)\nget_error_message1\nNode Details:\nTelegram Trigger\nType: Telegram Trigger node\nRole: Entry point capturing all user messages (text, voice, images)\nConfiguration: Listens for \"message\" updates from Telegram API\nOutput: Sends messages to \"Registered?\" node and \"Typing...\" action\nPossible failures: Telegram API connectivity, webhook misconfiguration\nInput Message Router1\nType: Switch node\nRole: Routes messages based on content type: text, voice message, image, or others\nConfiguration:\nRoutes to \"Text\" if\nmessage.text\nexists\nRoutes to \"Voice Message\" if\nmessage.voice\nexists\nRoutes to \"Image\" if\nmessage.photo[0].file_id\nexists\nFallback route to error message node\nInputs: Telegram Trigger\nOutputs: Multiple branches based on message type\nDownload Voice Message\nType: Telegram node\nRole: Downloads voice message binary file from Telegram API\nConfiguration: Uses\nfile_id\nfrom Telegram voice message\nPossible failures: File missing, Telegram API errors, network issues\nFix mime\nType: Code node\nRole: Corrects MIME types of downloaded audio files based on file extension\nConfiguration: Contains a detailed mapping of common MIME types\nInput: Binary data from downloaded voice message\nOutput: Corrected MIME type binary data\nAnalyze voice message\nType: LangChain Google Gemini AI node (Audio analysis)\nRole: Transcribes and analyzes the content of the voice message\nConfiguration: Model \"gemini-2.5-pro\" with prompt \"What's in this audio message from telegram user?\"\nInput: Binary audio data\nOutput: Textual transcription of voice message\nget_message (Audio/Video message)\nType: Set node\nRole: Extracts text transcription and chat ID, formats message for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nfields\nDownload IMAGE\nType: Telegram node\nRole: Downloads the highest resolution photo from Telegram message (up to 4 photos)\nConfiguration: Uses file IDs from photo array, picks the highest available\nPossible failures: Telegram API errors, file not found\nFix mime5\nType: Code node\nRole: Corrects MIME types of downloaded image files similarly to \"Fix mime\" node\nInput: Binary image data\nOutput: Corrected MIME type binary data\nAnalyze image\nType: LangChain Google Gemini AI node (Image analysis)\nRole: Performs detailed nutritional analysis on food image using custom prompt with scientific reasoning and macros estimation\nConfiguration: Uses model \"gemini-2.5-pro\", input type \"binary\", operation \"analyze\"\nOutput: Text with meal description and macros (Calories, Proteins, Carbs, Fat) in a strict format\nget_message (Media message)\nType: Set node\nRole: Extracts analyzed text and chat ID from image analysis for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nget_message (text)\nType: Set node\nRole: Extracts user text message and chat ID for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nget_error_message1\nType: Set node\nRole: Sets an error message when unsupported file types or errors occur\nOutput: JSON with error\nmessage\nand\nchat_id\nEdge Cases:\nMissing or unsupported media files fail gracefully with error message\nTelegram API rate limits or downtime\nVoice or image analysis failures due to AI service unavailability or malformed inputs\n2.2 User Registration Validation and Management\nOverview:\nValidates if the Telegram user is registered in the system; if not, triggers an AI-driven registration process to collect user profile and nutrition targets.\nNodes Involved:\nRegistered? (Google Sheets Lookup)\nIf (Check user ID existence)\nget_message (register)\nRegister Agent (AI LangChain agent)\nSimple Memory1 (AI memory for registration)\nRegister User (Google Sheets append)\nMarkdownV (MarkdownV2 formatter)\nSend a text message1 (Telegram message sender)\nNode Details:\nRegistered?\nType: Google Sheets node\nRole: Looks up the user's\nUser_ID\nin the Profile sheet to check registration\nConfiguration: Filters rows where User_ID equals Telegram chat ID\nOutput: Data about registration or empty if not registered\nPossible failure: Google Sheets API errors, permission issues\nIf\nType: If node\nRole: Checks if\nUser_ID\nexists in lookup result to branch logic\nOutput: Yes (registered) or No (not registered)\nget_message (register)\nType: Set node\nRole: Prepares user text and chat ID for registration agent\nOutput: JSON with user input message and chat_id\nRegister Agent\nType: LangChain AI Agent node\nRole: Conversational agent guiding new users through registration, collecting Name, Calories_target, Protein_target\nSystem prompt: Friendly, motivational tone with emoji support; calculates targets if needed; ensures only numeric data is stored; confirms registration\nInputs: User message\nOutputs: Commands to append user to Profile sheet or continue conversation\nSimple Memory1\nType: AI memory buffer\nRole: Maintains conversation context during registration process keyed by chat_id\nRegister User\nType: Google Sheets Tool node\nRole: Appends new user data (Name, User_ID, Calories_target, Protein_target) to Profile sheet\nConfiguration: Defines columns explicitly; uses append operation\nPossible issues: Duplicates if user registers twice; data validation\nMarkdownV\nType: Code node\nRole: Formats AI agent responses safely for Telegram MarkdownV2 with chunking\nOutput: One or multiple message chunks\nSend a text message1\nType: Telegram node\nRole: Sends formatted messages back to Telegram user\nConfiguration: Parses MarkdownV2, disables attribution\nPossible failures: Telegram API errors\nEdge Cases:\nUser abandons registration midway\nInvalid or missing numeric targets\nGoogle Sheets failures on append\nAI agent generating unexpected responses\n2.3 Message Processing and AI Analysis\nOverview:\nProcesses registered user input messages. Text messages are sent directly to the AI agent. Voice messages are transcribed and analyzed. Images are analyzed for food content and nutritional values.\nNodes Involved:\nCal IA Agent (AI LangChain agent)\nSimple Memory (AI memory buffer)\nGoogle Gemini Chat Model (AI language model)\nAppend Meal Data (Google Sheets append)\nUpdate Profile Data (Google Sheets appendOrUpdate)\nGet Profile Data (Google Sheets Tool)\nGet Report (Tool Workflow node invoking report subworkflow)\nMarkdownV2 (MarkdownV2 formatter)\nSend a text message (Telegram message sender)\nNode Details:\nCal IA Agent\nType: LangChain AI agent\nRole: Main conversational engine for logged-in users, managing meal logging, profile updates, and report generation\nSystem prompt: Friendly fitness coach tone with emoji use; uses four tools: appendMealData, updateProfileData, getUserData, getReport\nInputs: User message (text or AI-processed content)\nOutputs: Commands to tools or conversational responses\nSimple Memory\nType: AI memory buffer\nRole: Maintains conversation context by chat_id for natural interaction continuity\nGoogle Gemini Chat Model\nType: AI language model node\nRole: Executes the language model calls used by Cal IA Agent\nAppend Meal Data\nType: Google Sheets Tool node\nRole: Stores meal data (date, description, calories, proteins, carbs, fats, user_id) in Meals sheet\nConfiguration: Defines columns explicitly; appends rows\nPossible failures: Google Sheets write errors\nUpdate Profile Data\nType: Google Sheets Tool node\nRole: Updates user profile data in Profile sheet, overwriting existing values for Name, Calories_target, Protein_target\nConfiguration: appendOrUpdate operation matching by User_ID\nValidation: Only updates changed fields to avoid unnecessary writes\nGet Profile Data\nType: Google Sheets Tool node\nRole: Retrieves user profile information based on User_ID\nUsed by AI agent to fetch current profile targets\nGet Report\nType: Tool Workflow node\nRole: Invokes the Report Subworkflow passing User_ID and Date to generate daily nutrition summary\nMarkdownV2\nType: Code node\nRole: Formats AI responses safely in Telegram MarkdownV2 with chunking for long messages\nSend a text message\nType: Telegram node\nRole: Sends the AI agent's responses back to the user on Telegram\nEdge Cases:\nAI model errors or rate limits\nGoogle Sheets API failures during read/write\nData format mismatches from AI outputs\nUser requests unsupported by defined tools\n2.4 Meal Data Storage and Profile Updates\nOverview:\nHandles storing meal entries, updating user profiles, and fetching user data from Google Sheets.\nNodes Involved:\nAppend Meal Data\nUpdate Profile Data\nGet Profile Data\nNode Details:\nThese nodes are Google Sheets Tool nodes configured to read or write user data and meals using explicit column mappings. Append Meal Data stores meals, Update Profile Data updates profile targets, and Get Profile Data fetches current profile info for AI decision making.\n2.5 Report Generation and Delivery\nOverview:\nGenerates personalized daily nutrition reports by fetching meals and profile targets, calculating totals, formatting progress bars, and delivering the summary.\nNodes Involved:\nGet report (Execute Workflow Trigger node)\nGet Meals Info (Google Sheets lookup for daily meals)\nGet User Info (Google Sheets lookup for user profile)\nGet Data (Set node to extract macros fields)\nUnify data (Code node to sum totals)\nGet chart message (Code node to produce MarkdownV2 formatted report with progress bars)\nSend back message (Set node)\nSend a text message (Telegram node)\nNode Details:\nGet report\nTriggers subworkflow for daily report generation, passing User_ID and Date\nGet Meals Info\nRetrieves all meals logged for user on given date from Meals sheet\nGet User Info\nRetrieves user profile data (calorie/protein targets)\nGet Data\nExtracts Calories, Proteins, Carbs, Fats from meals for aggregation\nUnify data\nSums Calories, Proteins, Carbs, Fats from all meals to get daily totals\nGet chart message\nProduces a Telegram MarkdownV2 safe message containing:\nGreeting with user name\nCalories and protein progress bars with percentage\nCarbs and fats summary\nUses custom functions to escape Markdown, chunk message, and create progress bars\nSend back message\nPrepares outgoing message for Telegram node\nSend a text message\nSends the formatted report message back to the user on Telegram\nEdge Cases:\nNo meals logged for the date ‚Üí report may show zeros\nMissing user profile data ‚Üí fallback behavior\nGoogle Sheets API errors during data retrieval\n2.6 Message Formatting and Telegram Response\nOverview:\nEnsures all AI-generated messages are safely formatted in Telegram MarkdownV2, chunked if too long, and sent back to the user.\nNodes Involved:\nMarkdownV2\nMarkdownV\nSend a text message\nSend a text message1\nNode Details:\nMarkdownV2 / MarkdownV\nCode nodes with advanced escaping for Telegram MarkdownV2 including safe handling of links, bold, italics, spoilers, and splitting messages into chunks <= 4096 chars\nSend a text message / Send a text message1\nTelegram nodes sending the prepared messages to user chats\nUses MarkdownV2 parse mode and disables attribution for clean messages\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nEntry point, captures incoming Telegram messages\n-\nTyping‚Ä¶, Registered?\nSee Sticky Note7: Telegram Trigger & User Check\nTyping‚Ä¶\nTelegram\nSends Telegram \"Typing...\" status\nTelegram Trigger\n-\nRegistered?\nGoogle Sheets Lookup\nChecks if user is registered\nTelegram Trigger\nIf\nSee Sticky Note7: Telegram Trigger & User Check\nIf\nIf\nBranches based on user registration status\nRegistered?\nInput Message Router1, get_message(register)\nInput Message Router1\nSwitch\nRoutes messages by content type (text, voice, image)\nIf\nget_message(text), Download Voice Message, Download IMAGE, get_error_message1\nSee Sticky Note11: Message Processing\nget_message (text)\nSet\nExtracts text message & chat_id for AI agent\nInput Message Router1\nCal IA Agent\nDownload Voice Message\nTelegram\nDownloads voice message binary\nInput Message Router1\nFix mime\nSee Sticky Note11: Message Processing\nFix mime\nCode\nCorrects MIME type for audio files\nDownload Voice Message\nAnalyze voice message\nAnalyze voice message\nLangChain Google Gemini AI (Audio)\nTranscribes & analyzes voice message\nFix mime\nget_message (Audio/Video message)\nget_message (Audio/Video message)\nSet\nExtracts transcribed text & chat_id\nAnalyze voice message\nCal IA Agent\nDownload IMAGE\nTelegram\nDownloads food image\nInput Message Router1\nFix mime5\nSee Sticky Note11: Message Processing\nFix mime5\nCode\nCorrects MIME type for image files\nDownload IMAGE\nAnalyze image\nAnalyze image\nLangChain Google Gemini AI (Image)\nAnalyzes food image, estimates nutrition\nFix mime5\nget_message (Media message)\nSee Sticky Note11: Message Processing\nget_message (Media message)\nSet\nExtracts analyzed food info & chat_id\nAnalyze image\nCal IA Agent\nget_error_message1\nSet\nSends error message for unsupported files\nInput Message Router1\nCal IA Agent\nSee Sticky Note11: Message Processing\nget_message (register)\nSet\nPrepares message for registration agent\nIf\nRegister Agent\nSee Sticky Note10: Register Agent\nRegister Agent\nLangChain AI Agent\nGuides new user registration & collects data\nget_message (register)\nMarkdownV\nSee Sticky Note10: Register Agent\nSimple Memory1\nAI Memory Buffer\nMaintains registration conversation context\nRegister Agent\nRegister Agent\nRegister User\nGoogle Sheets Tool\nAppends new user profile data\nRegister Agent\nRegister Agent\nSee Sticky Note10: Register Agent\nMarkdownV\nCode\nFormats AI registration responses for Telegram\nRegister Agent\nSend a text message1\nSend a text message1\nTelegram\nSends registration message to user\nMarkdownV\n-\nCal IA Agent\nLangChain AI Agent\nMain AI agent for meal logging, profile update\nget_message (text), get_message (Audio/Video message), get_message (Media message), get_error_message1\nMarkdownV2\nSee Sticky Note13: Main AI Agent\nSimple Memory\nAI Memory Buffer\nMaintains conversation context for main AI\nCal IA Agent\nCal IA Agent\nGoogle Gemini Chat Model\nLangChain AI Language Model\nRuns AI language model for Cal IA Agent\nCal IA Agent\nCal IA Agent\nAppend Meal Data\nGoogle Sheets Tool\nStores meal data into Meals sheet\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nUpdate Profile Data\nGoogle Sheets Tool\nUpdates user profile targets\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nGet Profile Data\nGoogle Sheets Tool\nRetrieves user profile info\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nGet Report\nTool Workflow Trigger\nInvokes report subworkflow\nCal IA Agent\nCal IA Agent\nSee Sticky Note12: Report Subworkflow\nMarkdownV2\nCode\nFormats AI messages safely for Telegram\nCal IA Agent\nSend a text message\nSend a text message\nTelegram\nSends AI agent messages back to Telegram user\nMarkdownV2\n-\nGet report\nExecute Workflow Trigger\nStarts report generation workflow\nCal IA Agent\nGet Meals Info, Get User Info\nSee Sticky Note12: Report Subworkflow\nGet Meals Info\nGoogle Sheets Lookup\nFetches meals logged on a date\nGet report\nGet Data\nGet User Info\nGoogle Sheets Lookup\nFetches user profile info\nGet report\nMerge\nGet Data\nSet\nExtracts macros fields from meals\nGet Meals Info\nUnify data\nUnify data\nCode\nAggregates daily totals of calories, macros\nGet Data\nMerge\nMerge\nMerge\nCombines user info and daily totals\nUnify data, Get User Info\nGet chart message\nGet chart message\nCode\nBuilds MarkdownV2 formatted daily nutrition summary\nMerge\nSend back message\nSee Sticky Note12: Report Subworkflow\nSend back message\nSet\nPrepares final message for Telegram\nGet chart message\nSend a text message\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger Node\nType: Telegram Trigger\nConfigure with Telegram API credentials\nListen for \"message\" updates\nAdd \"Typing‚Ä¶\" Telegram Node\nType: Telegram\nOperation: sendChatAction\nAction: \"typing\"\nChat ID:\n={{ $json.message.chat.id }}\nConnect Telegram Trigger ‚Üí Typing‚Ä¶\nAdd \"Registered?\" Google Sheets Node\nType: Google Sheets (Lookup)\nConfigure credentials for Google Sheets OAuth2\nSpreadsheet ID: Profile spreadsheet ID\nSheet: \"Profile\" (gid=0)\nFilter: User_ID =\n={{ $json.message.chat.id }}\nConnect Telegram Trigger ‚Üí Registered?\nAdd \"If\" Node\nCheck if registered user exists by verifying User_ID in Registered? output\nIf yes ‚Üí proceed to message processing\nIf no ‚Üí proceed to registration\nAdd \"Input Message Router1\" Switch Node\nRoutes messages based on presence of text, voice, or photo in Telegram message\nConditions:\nText exists ‚Üí route to get_message (text)\nVoice exists ‚Üí route to Download Voice Message\nPhoto exists ‚Üí route to Download IMAGE\nElse ‚Üí route to error message\nSet up Text Message Handling\nCreate \"get_message (text)\" Set Node to extract text and chat_id\nConnect Input Message Router1 ‚Üí get_message (text)\nConnect get_message (text) ‚Üí Cal IA Agent\nSet up Voice Message Handling\nCreate \"Download Voice Message\" Telegram Node to download voice file\nConnect Input Message Router1 ‚Üí Download Voice Message\nCreate \"Fix mime\" Code Node to fix MIME types\nConnect Download Voice Message ‚Üí Fix mime\nCreate \"Analyze voice message\" AI node (Google Gemini Audio)\nConnect Fix mime ‚Üí Analyze voice message\nCreate \"get_message (Audio/Video message)\" Set Node to format transcription and chat_id\nConnect Analyze voice message ‚Üí get_message (Audio/Video message)\nConnect get_message (Audio/Video message) ‚Üí Cal IA Agent\nSet up Image Message Handling\nCreate \"Download IMAGE\" Telegram Node to get highest resolution photo\nConnect Input Message Router1 ‚Üí Download IMAGE\nCreate \"Fix mime5\" Code Node for image MIME correction\nConnect Download IMAGE ‚Üí Fix mime5\nCreate \"Analyze image\" AI node (Google Gemini Image) with custom nutrition prompt\nConnect Fix mime5 ‚Üí Analyze image\nCreate \"get_message (Media message)\" Set Node to format output and chat_id\nConnect Analyze image ‚Üí get_message (Media message)\nConnect get_message (Media message) ‚Üí Cal IA Agent\nSet up Error Handling for Unsupported Files\nCreate \"get_error_message1\" Set Node with error text and chat_id\nConnect Input Message Router1 fallback ‚Üí get_error_message1\nConnect get_error_message1 ‚Üí Cal IA Agent\nSet up Registration Flow\nCreate \"get_message (register)\" Set Node to extract message and chat_id for registration\nConnect If (not registered) ‚Üí get_message (register)\nCreate \"Register Agent\" LangChain AI Agent Node with registration system prompt (collect Name, Calories_target, Protein_target, help with targets, append to Google Sheets)\nConnect get_message (register) ‚Üí Register Agent\nCreate \"Simple Memory1\" AI memory node keyed by chat_id\nConnect Register Agent ‚Üí Simple Memory1 ‚Üí Register Agent\nCreate \"Register User\" Google Sheets Tool Node to append user data to Profile sheet\nConnect Register Agent (AI tool output) ‚Üí Register User\nCreate \"MarkdownV\" Code Node for MarkdownV2 safe formatting\nConnect Register Agent ‚Üí MarkdownV\nCreate \"Send a text message1\" Telegram Node to send registration messages\nConnect MarkdownV ‚Üí Send a text message1\nSet up Main AI Agent for Registered Users\nCreate \"Cal IA Agent\" LangChain AI Agent Node with system prompt for nutrition assistant, tools: appendMealData, updateProfileData, getUserData, getReport\nConnect get_message (text), get_message (Audio/Video message), get_message (Media message), get_error_message1 ‚Üí Cal IA Agent\nCreate \"Simple Memory\" AI memory node keyed by chat_id\nConnect Cal IA Agent ‚Üí Simple Memory ‚Üí Cal IA Agent\nCreate \"Google Gemini Chat Model\" node for AI language model calls\nConnect Cal IA Agent ‚Üí Google Gemini Chat Model ‚Üí Cal IA Agent\nSet up Google Sheets Tools for AI Agent\n\"Append Meal Data\" Google Sheets Tool to append meals to Meals sheet\n\"Update Profile Data\" Google Sheets Tool for updating profile targets (appendOrUpdate by User_ID)\n\"Get Profile Data\" Google Sheets Tool to retrieve profile data by User_ID\nConnect these tools as AI tools inside Cal IA Agent\nSet up Report Generation Subworkflow\nCreate a separate workflow for report generation (Report Subworkflow) with inputs User_ID and Date\nIn main workflow, add \"Get Report\" Tool Workflow node invoking subworkflow with inputs User_ID and Date from AI agent\nConnect Cal IA Agent ‚Üí Get Report ‚Üí Cal IA Agent\nBuild Report Subworkflow\nNodes:\n\"Get Meals Info\" Google Sheets Lookup filtering meals by date and user\n\"Get User Info\" Google Sheets Lookup for profile data\n\"Get Data\" Set Node extracting Calories, Proteins, Carbs, Fats from meals\n\"Unify data\" Code Node summing daily totals\n\"Merge\" node to join profile and totals\n\"Get chart message\" Code Node to generate a MarkdownV2 formatted summary with progress bars\n\"Send back message\" Set Node preparing output\n\"Send a text message\" Telegram Node sending report\nSet up Message Formatting and Sending\nCreate \"MarkdownV2\" and \"MarkdownV\" Code nodes for formatting all AI outputs safely for Telegram MarkdownV2\nConnect these to \"Send a text message\" or \"Send a text message1\" Telegram nodes accordingly\nConfigure Credentials\nTelegram API credentials with Bot Token and webhook setup\nGoogle Sheets OAuth2 credentials with access to Profile and Meals spreadsheets\nGoogle Gemini (PaLM) API credentials for AI nodes\n5. General Notes & Resources\nNote Content\nContext or Link\nüìò Cal AI Alternative ‚Äì Nutrition Assistant: Integrates Telegram, Google Sheets, and Gemini AI.\nSee Sticky Note at workflow start; explains features and intended user benefits\nTelegram Trigger & User Check: Handles message capture and registration validation\nSee Sticky Note7\nRegister Agent: AI-driven user registration and nutrition target setup\nSee Sticky Note10\nMessage Processing: Classifies and analyzes messages (text, voice, image)\nSee Sticky Note11\nMain AI Agent: Central conversational agent managing meals, profile, and reports\nSee Sticky Note13\nReport Subworkflow: Generates personalized daily nutrition reports with progress bars\nSee Sticky Note12\nMarkdownV2 Safe Formatter: Code node to ensure Telegram Markdown compliance and chunking\nUsed in multiple places for message formatting\nContact for customization or assistance: Email\n[email¬†protected]\n, LinkedIn profile\nSee Sticky Note15\nWorkflow includes detailed MIME type correction for various media files\nEnsures compatibility with Telegram media downloads\nAI model used: Google Gemini 2.5 Pro for text, audio transcription, and image analysis\nRequires Google PaLM API credentials\nGoogle Sheets Structure: Two main sheets - Profile (User info and targets) and Meals (logged meals)\nDocument links specified in node parameters\nDisclaimer:\nThe text and data processed in this workflow are legal and public. The workflow respects content policies and contains no illegal or offensive content.\nCopied to clipboard",
      "description_full_fr": "Nutrition Tracker & Meal Logger with Telegram, Gemini AI and Google Sheets\n1. Workflow Overview\nThis workflow implements a\nNutrition Tracker & Meal Logger\nthat allows users to interact via Telegram to log meals, receive nutritional analysis, and track their nutrition goals. It integrates\nTelegram\n,\nGoogle Sheets\nfor data storage, and\nGoogle Gemini AI\nfor processing and understanding text, voice, and images.\nThe workflow is logically divided into the following blocks:\n1.1 User Input Capture and Routing\nHandles incoming Telegram messages (text, voice, images), routes them based on content type for further processing.\n1.2 User Registration Validation and Management\nChecks if users are registered, and if not, runs a registration agent workflow to collect user profile and nutrition targets.\n1.3 Message Processing and AI Analysis\nProcesses text messages directly; downloads and transcribes voice messages using AI; downloads and analyzes food images with AI vision for nutritional content.\n1.4 Meal Data Storage and Profile Updates\nStores parsed meal information into Google Sheets, updates user profiles if requested, and manages user data retrieval.\n1.5 Report Generation and Delivery\nGenerates daily nutrition summaries with progress bars and sends personalized reports to users.\n1.6 Message Formatting and Telegram Response\nFormats messages safely in Telegram MarkdownV2, chunks long messages, and sends responses back to Telegram.\n2. Block-by-Block Analysis\n2.1 User Input Capture and Routing\nOverview:\nThis block captures all incoming messages from Telegram users and routes them based on whether the input is text, voice, or image.\nNodes Involved:\nTelegram Trigger\nInput Message Router1\nDownload Voice Message\nFix mime (for audio)\nAnalyze voice message\nget_message (Audio/Video message)\nDownload IMAGE\nFix mime5 (for images)\nAnalyze image\nget_message (Media message)\nget_message (text)\nget_error_message1\nNode Details:\nTelegram Trigger\nType: Telegram Trigger node\nRole: Entry point capturing all user messages (text, voice, images)\nConfiguration: Listens for \"message\" updates from Telegram API\nOutput: Sends messages to \"Registered?\" node and \"Typing...\" action\nPossible failures: Telegram API connectivity, webhook misconfiguration\nInput Message Router1\nType: Switch node\nRole: Routes messages based on content type: text, voice message, image, or others\nConfiguration:\nRoutes to \"Text\" if\nmessage.text\nexists\nRoutes to \"Voice Message\" if\nmessage.voice\nexists\nRoutes to \"Image\" if\nmessage.photo[0].file_id\nexists\nFallback route to error message node\nInputs: Telegram Trigger\nOutputs: Multiple branches based on message type\nDownload Voice Message\nType: Telegram node\nRole: Downloads voice message binary file from Telegram API\nConfiguration: Uses\nfile_id\nfrom Telegram voice message\nPossible failures: File missing, Telegram API errors, network issues\nFix mime\nType: Code node\nRole: Corrects MIME types of downloaded audio files based on file extension\nConfiguration: Contains a detailed mapping of common MIME types\nInput: Binary data from downloaded voice message\nOutput: Corrected MIME type binary data\nAnalyze voice message\nType: LangChain Google Gemini AI node (Audio analysis)\nRole: Transcribes and analyzes the content of the voice message\nConfiguration: Model \"gemini-2.5-pro\" with prompt \"What's in this audio message from telegram user?\"\nInput: Binary audio data\nOutput: Textual transcription of voice message\nget_message (Audio/Video message)\nType: Set node\nRole: Extracts text transcription and chat ID, formats message for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nfields\nDownload IMAGE\nType: Telegram node\nRole: Downloads the highest resolution photo from Telegram message (up to 4 photos)\nConfiguration: Uses file IDs from photo array, picks the highest available\nPossible failures: Telegram API errors, file not found\nFix mime5\nType: Code node\nRole: Corrects MIME types of downloaded image files similarly to \"Fix mime\" node\nInput: Binary image data\nOutput: Corrected MIME type binary data\nAnalyze image\nType: LangChain Google Gemini AI node (Image analysis)\nRole: Performs detailed nutritional analysis on food image using custom prompt with scientific reasoning and macros estimation\nConfiguration: Uses model \"gemini-2.5-pro\", input type \"binary\", operation \"analyze\"\nOutput: Text with meal description and macros (Calories, Proteins, Carbs, Fat) in a strict format\nget_message (Media message)\nType: Set node\nRole: Extracts analyzed text and chat ID from image analysis for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nget_message (text)\nType: Set node\nRole: Extracts user text message and chat ID for AI agent\nOutput: JSON with\nmessage\nand\nchat_id\nget_error_message1\nType: Set node\nRole: Sets an error message when unsupported file types or errors occur\nOutput: JSON with error\nmessage\nand\nchat_id\nEdge Cases:\nMissing or unsupported media files fail gracefully with error message\nTelegram API rate limits or downtime\nVoice or image analysis failures due to AI service unavailability or malformed inputs\n2.2 User Registration Validation and Management\nOverview:\nValidates if the Telegram user is registered in the system; if not, triggers an AI-driven registration process to collect user profile and nutrition targets.\nNodes Involved:\nRegistered? (Google Sheets Lookup)\nIf (Check user ID existence)\nget_message (register)\nRegister Agent (AI LangChain agent)\nSimple Memory1 (AI memory for registration)\nRegister User (Google Sheets append)\nMarkdownV (MarkdownV2 formatter)\nSend a text message1 (Telegram message sender)\nNode Details:\nRegistered?\nType: Google Sheets node\nRole: Looks up the user's\nUser_ID\nin the Profile sheet to check registration\nConfiguration: Filters rows where User_ID equals Telegram chat ID\nOutput: Data about registration or empty if not registered\nPossible failure: Google Sheets API errors, permission issues\nIf\nType: If node\nRole: Checks if\nUser_ID\nexists in lookup result to branch logic\nOutput: Yes (registered) or No (not registered)\nget_message (register)\nType: Set node\nRole: Prepares user text and chat ID for registration agent\nOutput: JSON with user input message and chat_id\nRegister Agent\nType: LangChain AI Agent node\nRole: Conversational agent guiding new users through registration, collecting Name, Calories_target, Protein_target\nSystem prompt: Friendly, motivational tone with emoji support; calculates targets if needed; ensures only numeric data is stored; confirms registration\nInputs: User message\nOutputs: Commands to append user to Profile sheet or continue conversation\nSimple Memory1\nType: AI memory buffer\nRole: Maintains conversation context during registration process keyed by chat_id\nRegister User\nType: Google Sheets Tool node\nRole: Appends new user data (Name, User_ID, Calories_target, Protein_target) to Profile sheet\nConfiguration: Defines columns explicitly; uses append operation\nPossible issues: Duplicates if user registers twice; data validation\nMarkdownV\nType: Code node\nRole: Formats AI agent responses safely for Telegram MarkdownV2 with chunking\nOutput: One or multiple message chunks\nSend a text message1\nType: Telegram node\nRole: Sends formatted messages back to Telegram user\nConfiguration: Parses MarkdownV2, disables attribution\nPossible failures: Telegram API errors\nEdge Cases:\nUser abandons registration midway\nInvalid or missing numeric targets\nGoogle Sheets failures on append\nAI agent generating unexpected responses\n2.3 Message Processing and AI Analysis\nOverview:\nProcesses registered user input messages. Text messages are sent directly to the AI agent. Voice messages are transcribed and analyzed. Images are analyzed for food content and nutritional values.\nNodes Involved:\nCal IA Agent (AI LangChain agent)\nSimple Memory (AI memory buffer)\nGoogle Gemini Chat Model (AI language model)\nAppend Meal Data (Google Sheets append)\nUpdate Profile Data (Google Sheets appendOrUpdate)\nGet Profile Data (Google Sheets Tool)\nGet Report (Tool Workflow node invoking report subworkflow)\nMarkdownV2 (MarkdownV2 formatter)\nSend a text message (Telegram message sender)\nNode Details:\nCal IA Agent\nType: LangChain AI agent\nRole: Main conversational engine for logged-in users, managing meal logging, profile updates, and report generation\nSystem prompt: Friendly fitness coach tone with emoji use; uses four tools: appendMealData, updateProfileData, getUserData, getReport\nInputs: User message (text or AI-processed content)\nOutputs: Commands to tools or conversational responses\nSimple Memory\nType: AI memory buffer\nRole: Maintains conversation context by chat_id for natural interaction continuity\nGoogle Gemini Chat Model\nType: AI language model node\nRole: Executes the language model calls used by Cal IA Agent\nAppend Meal Data\nType: Google Sheets Tool node\nRole: Stores meal data (date, description, calories, proteins, carbs, fats, user_id) in Meals sheet\nConfiguration: Defines columns explicitly; appends rows\nPossible failures: Google Sheets write errors\nUpdate Profile Data\nType: Google Sheets Tool node\nRole: Updates user profile data in Profile sheet, overwriting existing values for Name, Calories_target, Protein_target\nConfiguration: appendOrUpdate operation matching by User_ID\nValidation: Only updates changed fields to avoid unnecessary writes\nGet Profile Data\nType: Google Sheets Tool node\nRole: Retrieves user profile information based on User_ID\nUsed by AI agent to fetch current profile targets\nGet Report\nType: Tool Workflow node\nRole: Invokes the Report Subworkflow passing User_ID and Date to generate daily nutrition summary\nMarkdownV2\nType: Code node\nRole: Formats AI responses safely in Telegram MarkdownV2 with chunking for long messages\nSend a text message\nType: Telegram node\nRole: Sends the AI agent's responses back to the user on Telegram\nEdge Cases:\nAI model errors or rate limits\nGoogle Sheets API failures during read/write\nData format mismatches from AI outputs\nUser requests unsupported by defined tools\n2.4 Meal Data Storage and Profile Updates\nOverview:\nHandles storing meal entries, updating user profiles, and fetching user data from Google Sheets.\nNodes Involved:\nAppend Meal Data\nUpdate Profile Data\nGet Profile Data\nNode Details:\nThese nodes are Google Sheets Tool nodes configured to read or write user data and meals using explicit column mappings. Append Meal Data stores meals, Update Profile Data updates profile targets, and Get Profile Data fetches current profile info for AI decision making.\n2.5 Report Generation and Delivery\nOverview:\nGenerates personalized daily nutrition reports by fetching meals and profile targets, calculating totals, formatting progress bars, and delivering the summary.\nNodes Involved:\nGet report (Execute Workflow Trigger node)\nGet Meals Info (Google Sheets lookup for daily meals)\nGet User Info (Google Sheets lookup for user profile)\nGet Data (Set node to extract macros fields)\nUnify data (Code node to sum totals)\nGet chart message (Code node to produce MarkdownV2 formatted report with progress bars)\nSend back message (Set node)\nSend a text message (Telegram node)\nNode Details:\nGet report\nTriggers subworkflow for daily report generation, passing User_ID and Date\nGet Meals Info\nRetrieves all meals logged for user on given date from Meals sheet\nGet User Info\nRetrieves user profile data (calorie/protein targets)\nGet Data\nExtracts Calories, Proteins, Carbs, Fats from meals for aggregation\nUnify data\nSums Calories, Proteins, Carbs, Fats from all meals to get daily totals\nGet chart message\nProduces a Telegram MarkdownV2 safe message containing:\nGreeting with user name\nCalories and protein progress bars with percentage\nCarbs and fats summary\nUses custom functions to escape Markdown, chunk message, and create progress bars\nSend back message\nPrepares outgoing message for Telegram node\nSend a text message\nSends the formatted report message back to the user on Telegram\nEdge Cases:\nNo meals logged for the date ‚Üí report may show zeros\nMissing user profile data ‚Üí fallback behavior\nGoogle Sheets API errors during data retrieval\n2.6 Message Formatting and Telegram Response\nOverview:\nEnsures all AI-generated messages are safely formatted in Telegram MarkdownV2, chunked if too long, and sent back to the user.\nNodes Involved:\nMarkdownV2\nMarkdownV\nSend a text message\nSend a text message1\nNode Details:\nMarkdownV2 / MarkdownV\nCode nodes with advanced escaping for Telegram MarkdownV2 including safe handling of links, bold, italics, spoilers, and splitting messages into chunks <= 4096 chars\nSend a text message / Send a text message1\nTelegram nodes sending the prepared messages to user chats\nUses MarkdownV2 parse mode and disables attribution for clean messages\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nEntry point, captures incoming Telegram messages\n-\nTyping‚Ä¶, Registered?\nSee Sticky Note7: Telegram Trigger & User Check\nTyping‚Ä¶\nTelegram\nSends Telegram \"Typing...\" status\nTelegram Trigger\n-\nRegistered?\nGoogle Sheets Lookup\nChecks if user is registered\nTelegram Trigger\nIf\nSee Sticky Note7: Telegram Trigger & User Check\nIf\nIf\nBranches based on user registration status\nRegistered?\nInput Message Router1, get_message(register)\nInput Message Router1\nSwitch\nRoutes messages by content type (text, voice, image)\nIf\nget_message(text), Download Voice Message, Download IMAGE, get_error_message1\nSee Sticky Note11: Message Processing\nget_message (text)\nSet\nExtracts text message & chat_id for AI agent\nInput Message Router1\nCal IA Agent\nDownload Voice Message\nTelegram\nDownloads voice message binary\nInput Message Router1\nFix mime\nSee Sticky Note11: Message Processing\nFix mime\nCode\nCorrects MIME type for audio files\nDownload Voice Message\nAnalyze voice message\nAnalyze voice message\nLangChain Google Gemini AI (Audio)\nTranscribes & analyzes voice message\nFix mime\nget_message (Audio/Video message)\nget_message (Audio/Video message)\nSet\nExtracts transcribed text & chat_id\nAnalyze voice message\nCal IA Agent\nDownload IMAGE\nTelegram\nDownloads food image\nInput Message Router1\nFix mime5\nSee Sticky Note11: Message Processing\nFix mime5\nCode\nCorrects MIME type for image files\nDownload IMAGE\nAnalyze image\nAnalyze image\nLangChain Google Gemini AI (Image)\nAnalyzes food image, estimates nutrition\nFix mime5\nget_message (Media message)\nSee Sticky Note11: Message Processing\nget_message (Media message)\nSet\nExtracts analyzed food info & chat_id\nAnalyze image\nCal IA Agent\nget_error_message1\nSet\nSends error message for unsupported files\nInput Message Router1\nCal IA Agent\nSee Sticky Note11: Message Processing\nget_message (register)\nSet\nPrepares message for registration agent\nIf\nRegister Agent\nSee Sticky Note10: Register Agent\nRegister Agent\nLangChain AI Agent\nGuides new user registration & collects data\nget_message (register)\nMarkdownV\nSee Sticky Note10: Register Agent\nSimple Memory1\nAI Memory Buffer\nMaintains registration conversation context\nRegister Agent\nRegister Agent\nRegister User\nGoogle Sheets Tool\nAppends new user profile data\nRegister Agent\nRegister Agent\nSee Sticky Note10: Register Agent\nMarkdownV\nCode\nFormats AI registration responses for Telegram\nRegister Agent\nSend a text message1\nSend a text message1\nTelegram\nSends registration message to user\nMarkdownV\n-\nCal IA Agent\nLangChain AI Agent\nMain AI agent for meal logging, profile update\nget_message (text), get_message (Audio/Video message), get_message (Media message), get_error_message1\nMarkdownV2\nSee Sticky Note13: Main AI Agent\nSimple Memory\nAI Memory Buffer\nMaintains conversation context for main AI\nCal IA Agent\nCal IA Agent\nGoogle Gemini Chat Model\nLangChain AI Language Model\nRuns AI language model for Cal IA Agent\nCal IA Agent\nCal IA Agent\nAppend Meal Data\nGoogle Sheets Tool\nStores meal data into Meals sheet\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nUpdate Profile Data\nGoogle Sheets Tool\nUpdates user profile targets\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nGet Profile Data\nGoogle Sheets Tool\nRetrieves user profile info\nCal IA Agent\nCal IA Agent\nSee Sticky Note13: Main AI Agent\nGet Report\nTool Workflow Trigger\nInvokes report subworkflow\nCal IA Agent\nCal IA Agent\nSee Sticky Note12: Report Subworkflow\nMarkdownV2\nCode\nFormats AI messages safely for Telegram\nCal IA Agent\nSend a text message\nSend a text message\nTelegram\nSends AI agent messages back to Telegram user\nMarkdownV2\n-\nGet report\nExecute Workflow Trigger\nStarts report generation workflow\nCal IA Agent\nGet Meals Info, Get User Info\nSee Sticky Note12: Report Subworkflow\nGet Meals Info\nGoogle Sheets Lookup\nFetches meals logged on a date\nGet report\nGet Data\nGet User Info\nGoogle Sheets Lookup\nFetches user profile info\nGet report\nMerge\nGet Data\nSet\nExtracts macros fields from meals\nGet Meals Info\nUnify data\nUnify data\nCode\nAggregates daily totals of calories, macros\nGet Data\nMerge\nMerge\nMerge\nCombines user info and daily totals\nUnify data, Get User Info\nGet chart message\nGet chart message\nCode\nBuilds MarkdownV2 formatted daily nutrition summary\nMerge\nSend back message\nSee Sticky Note12: Report Subworkflow\nSend back message\nSet\nPrepares final message for Telegram\nGet chart message\nSend a text message\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger Node\nType: Telegram Trigger\nConfigure with Telegram API credentials\nListen for \"message\" updates\nAdd \"Typing‚Ä¶\" Telegram Node\nType: Telegram\nOperation: sendChatAction\nAction: \"typing\"\nChat ID:\n={{ $json.message.chat.id }}\nConnect Telegram Trigger ‚Üí Typing‚Ä¶\nAdd \"Registered?\" Google Sheets Node\nType: Google Sheets (Lookup)\nConfigure credentials for Google Sheets OAuth2\nSpreadsheet ID: Profile spreadsheet ID\nSheet: \"Profile\" (gid=0)\nFilter: User_ID =\n={{ $json.message.chat.id }}\nConnect Telegram Trigger ‚Üí Registered?\nAdd \"If\" Node\nCheck if registered user exists by verifying User_ID in Registered? output\nIf yes ‚Üí proceed to message processing\nIf no ‚Üí proceed to registration\nAdd \"Input Message Router1\" Switch Node\nRoutes messages based on presence of text, voice, or photo in Telegram message\nConditions:\nText exists ‚Üí route to get_message (text)\nVoice exists ‚Üí route to Download Voice Message\nPhoto exists ‚Üí route to Download IMAGE\nElse ‚Üí route to error message\nSet up Text Message Handling\nCreate \"get_message (text)\" Set Node to extract text and chat_id\nConnect Input Message Router1 ‚Üí get_message (text)\nConnect get_message (text) ‚Üí Cal IA Agent\nSet up Voice Message Handling\nCreate \"Download Voice Message\" Telegram Node to download voice file\nConnect Input Message Router1 ‚Üí Download Voice Message\nCreate \"Fix mime\" Code Node to fix MIME types\nConnect Download Voice Message ‚Üí Fix mime\nCreate \"Analyze voice message\" AI node (Google Gemini Audio)\nConnect Fix mime ‚Üí Analyze voice message\nCreate \"get_message (Audio/Video message)\" Set Node to format transcription and chat_id\nConnect Analyze voice message ‚Üí get_message (Audio/Video message)\nConnect get_message (Audio/Video message) ‚Üí Cal IA Agent\nSet up Image Message Handling\nCreate \"Download IMAGE\" Telegram Node to get highest resolution photo\nConnect Input Message Router1 ‚Üí Download IMAGE\nCreate \"Fix mime5\" Code Node for image MIME correction\nConnect Download IMAGE ‚Üí Fix mime5\nCreate \"Analyze image\" AI node (Google Gemini Image) with custom nutrition prompt\nConnect Fix mime5 ‚Üí Analyze image\nCreate \"get_message (Media message)\" Set Node to format output and chat_id\nConnect Analyze image ‚Üí get_message (Media message)\nConnect get_message (Media message) ‚Üí Cal IA Agent\nSet up Error Handling for Unsupported Files\nCreate \"get_error_message1\" Set Node with error text and chat_id\nConnect Input Message Router1 fallback ‚Üí get_error_message1\nConnect get_error_message1 ‚Üí Cal IA Agent\nSet up Registration Flow\nCreate \"get_message (register)\" Set Node to extract message and chat_id for registration\nConnect If (not registered) ‚Üí get_message (register)\nCreate \"Register Agent\" LangChain AI Agent Node with registration system prompt (collect Name, Calories_target, Protein_target, help with targets, append to Google Sheets)\nConnect get_message (register) ‚Üí Register Agent\nCreate \"Simple Memory1\" AI memory node keyed by chat_id\nConnect Register Agent ‚Üí Simple Memory1 ‚Üí Register Agent\nCreate \"Register User\" Google Sheets Tool Node to append user data to Profile sheet\nConnect Register Agent (AI tool output) ‚Üí Register User\nCreate \"MarkdownV\" Code Node for MarkdownV2 safe formatting\nConnect Register Agent ‚Üí MarkdownV\nCreate \"Send a text message1\" Telegram Node to send registration messages\nConnect MarkdownV ‚Üí Send a text message1\nSet up Main AI Agent for Registered Users\nCreate \"Cal IA Agent\" LangChain AI Agent Node with system prompt for nutrition assistant, tools: appendMealData, updateProfileData, getUserData, getReport\nConnect get_message (text), get_message (Audio/Video message), get_message (Media message), get_error_message1 ‚Üí Cal IA Agent\nCreate \"Simple Memory\" AI memory node keyed by chat_id\nConnect Cal IA Agent ‚Üí Simple Memory ‚Üí Cal IA Agent\nCreate \"Google Gemini Chat Model\" node for AI language model calls\nConnect Cal IA Agent ‚Üí Google Gemini Chat Model ‚Üí Cal IA Agent\nSet up Google Sheets Tools for AI Agent\n\"Append Meal Data\" Google Sheets Tool to append meals to Meals sheet\n\"Update Profile Data\" Google Sheets Tool for updating profile targets (appendOrUpdate by User_ID)\n\"Get Profile Data\" Google Sheets Tool to retrieve profile data by User_ID\nConnect these tools as AI tools inside Cal IA Agent\nSet up Report Generation Subworkflow\nCreate a separate workflow for report generation (Report Subworkflow) with inputs User_ID and Date\nIn main workflow, add \"Get Report\" Tool Workflow node invoking subworkflow with inputs User_ID and Date from AI agent\nConnect Cal IA Agent ‚Üí Get Report ‚Üí Cal IA Agent\nBuild Report Subworkflow\nNodes:\n\"Get Meals Info\" Google Sheets Lookup filtering meals by date and user\n\"Get User Info\" Google Sheets Lookup for profile data\n\"Get Data\" Set Node extracting Calories, Proteins, Carbs, Fats from meals\n\"Unify data\" Code Node summing daily totals\n\"Merge\" node to join profile and totals\n\"Get chart message\" Code Node to generate a MarkdownV2 formatted summary with progress bars\n\"Send back message\" Set Node preparing output\n\"Send a text message\" Telegram Node sending report\nSet up Message Formatting and Sending\nCreate \"MarkdownV2\" and \"MarkdownV\" Code nodes for formatting all AI outputs safely for Telegram MarkdownV2\nConnect these to \"Send a text message\" or \"Send a text message1\" Telegram nodes accordingly\nConfigure Credentials\nTelegram API credentials with Bot Token and webhook setup\nGoogle Sheets OAuth2 credentials with access to Profile and Meals spreadsheets\nGoogle Gemini (PaLM) API credentials for AI nodes\n5. General Notes & Resources\nNote Content\nContext or Link\nüìò Cal AI Alternative ‚Äì Nutrition Assistant: Integrates Telegram, Google Sheets, and Gemini AI.\nSee Sticky Note at workflow start; explains features and intended user benefits\nTelegram Trigger & User Check: Handles message capture and registration validation\nSee Sticky Note7\nRegister Agent: AI-driven user registration and nutrition target setup\nSee Sticky Note10\nMessage Processing: Classifies and analyzes messages (text, voice, image)\nSee Sticky Note11\nMain AI Agent: Central conversational agent managing meals, profile, and reports\nSee Sticky Note13\nReport Subworkflow: Generates personalized daily nutrition reports with progress bars\nSee Sticky Note12\nMarkdownV2 Safe Formatter: Code node to ensure Telegram Markdown compliance and chunking\nUsed in multiple places for message formatting\nContact for customization or assistance: Email\n[email¬†protected]\n, LinkedIn profile\nSee Sticky Note15\nWorkflow includes detailed MIME type correction for various media files\nEnsures compatibility with Telegram media downloads\nAI model used: Google Gemini 2.5 Pro for text, audio transcription, and image analysis\nRequires Google PaLM API credentials\nGoogle Sheets Structure: Two main sheets - Profile (User info and targets) and Meals (logged meals)\nDocument links specified in node parameters\nDisclaimer:\nThe text and data processed in this workflow are legal and public. The workflow respects content policies and contains no illegal or offensive content.\nCopied to clipboard\n\n",
      "category": "CRM",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "John Alejandro SIlva",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/nutrition-tracker-meal-logger-with-telegram-gemini-ai-and-google-sheets-7756",
      "nodes_count": 55
    },
    {
      "id": "006",
      "slug": "apprenez-les-bases-de-n8n-en-3-tapes-faciles-",
      "title_en": "Learn n8n Basics in 3 Easy Steps ‚ú®",
      "title_fr": "Apprenez les bases de n8n en 3 √©tapes faciles ‚ú®",
      "description_short_en": "Learn n8n basics fast: create scheduled automations, fetch API data, and send emails‚Äîno coding needed. Start building workflows with confidence!",
      "description_short_fr": "Apprenez rapidement les bases de n8n¬†: cr√©ez des automatisations planifi√©es, r√©cup√©rez des donn√©es API et envoyez des e-mails, aucun codage n'est n√©cessaire. Commencez √† cr√©er des flux de travail en toute confiance¬†!",
      "description_full_en": "Learn n8n Basics in 3 Easy Steps ‚ú®\n1. Workflow Overview\nThis workflow, titled\n\"Learn n8n Basics in 3 Easy Steps ‚ú®\"\n, is a beginner-friendly automation designed to demonstrate key n8n functionalities by fetching inspirational quotes and programming jokes from public APIs, processing their data, scheduling automated runs, and sending results via email. It targets users who want to learn the n8n basics by building a practical example that integrates web requests, data transformation, scheduling, and email dispatch.\nThe workflow is logically divided into three main blocks:\n1.1 Manual Quote Retrieval Block:\nAllows manual triggering to fetch a random inspirational quote and display the results immediately.\n1.2 Scheduled Quote Delivery Block:\nAutomatically fetches a random inspirational quote daily at a specified time, processes the data, and sends it via Gmail.\n1.3 Joke Retrieval and Mapping Block:\nFetches a programming joke, maps its data fields alongside the quote, and prepares it for further email integration.\nSeveral sticky notes guide users interactively on running, scheduling, and extending the workflow.\n2. Block-by-Block Analysis\n1.1 Manual Quote Retrieval Block\nOverview:\nThis block enables users to manually trigger the workflow, retrieve a random inspirational quote from an external API, and view the structured result.\nNodes Involved:\n1.1.1 \"1. Click 'Execute workflow‚Äô\" (Manual Trigger)\n1.1.2 \"2. Get inspirational quote from the internet\" (HTTP Request)\n1.1.3 \"3. See the resutls\" (Set)\nNode Details:\n1.1.1 \"1. Click 'Execute workflow‚Äô\"\nType: Manual Trigger\nRole: Entry point for manual execution.\nConfiguration: No parameters; triggers workflow on manual command.\nConnections: Outputs to \"2. Get inspirational quote from the internet\".\nEdge Cases: None significant; manual trigger is user-controlled.\n1.1.2 \"2. Get inspirational quote from the internet\"\nType: HTTP Request\nRole: Fetches random inspirational quote JSON from\nhttps://zenquotes.io/api/random\n.\nConfiguration: Simple GET request, no authentication or additional headers.\nConnections: Outputs to \"3. See the resutls\".\nEdge Cases: API unavailability, rate limiting, or malformed response. Should handle HTTP errors or empty data gracefully.\n1.1.3 \"3. See the resutls\"\nType: Set\nRole: Extracts and formats the quote and author fields from the API response for easier consumption.\nConfiguration: Assigns\nquote\n=\n{{$json.q}}\n,\nauthor\n=\n{{$json.a}}\n.\nConnections: Terminal node for this block.\nEdge Cases: Missing fields in API response may cause empty or undefined values.\n1.2 Scheduled Quote Delivery Block\nOverview:\nThis block schedules an automated daily task to fetch a random quote, process it, and send it via Gmail to a configured recipient.\nNodes Involved:\n1.2.1 \"Schedule me here\" (Schedule Trigger)\n1.2.2 \"Get quote\" (HTTP Request)\n1.2.3 \"Results\" (Set)\n1.2.4 \"Connect your Gmail\" (Gmail node)\nNode Details:\n1.2.1 \"Schedule me here\"\nType: Schedule Trigger\nRole: Starts the workflow automatically every day at 07:00 AM.\nConfiguration: Interval rule set to trigger daily at 7 AM.\nConnections: Outputs to \"Get quote\".\nEdge Cases: Timezone considerations; ensure server timezone matches expectation.\n1.2.2 \"Get quote\"\nType: HTTP Request\nRole: Fetches random inspirational quote JSON from\nhttps://zenquotes.io/api/random\n, same as in manual block.\nConfiguration: Simple GET request.\nConnections: Outputs to \"Results\".\nEdge Cases: Same as manual block; handle API errors.\n1.2.3 \"Results\"\nType: Set\nRole: Formats the quote and author fields from the API response, identical to the manual block.\nConfiguration: Assigns\nquote\n=\n{{$json.q}}\n,\nauthor\n=\n{{$json.a}}\n.\nConnections: Outputs to \"Connect your Gmail\".\nEdge Cases: Missing or malformed data from API.\n1.2.4 \"Connect your Gmail\"\nType: Gmail node (Send email)\nRole: Sends an email containing the quote and author to the configured recipient.\nConfiguration:\nSubject: \"Daily quote\"\nEmail body: Plain text with template:\nHey,\n\nHere's a quote by {{ $json.author }}:\n\n\"{{ $json.quote }}\"\nCredentials: OAuth2 Gmail account configured (note: user must connect manually).\nConnections: Terminal node for this block.\nEdge Cases: Authentication failures, rate limiting on Gmail API, invalid recipient addresses.\n1.3 Joke Retrieval and Mapping Block\nOverview:\nThis block fetches a programming joke from a public API, combines it with the quote data, and maps all fields for future use, such as adding jokes to emails.\nNodes Involved:\n1.3.1 \"Schedule Trigger\" (Schedule Trigger)\n1.3.2 \"Quote\" (HTTP Request)\n1.3.3 \"Programming joke\" (HTTP Request)\n1.3.4 \"Map the fields\" (Set)\nNode Details:\n1.3.1 \"Schedule Trigger\"\nType: Schedule Trigger\nRole: Triggers the workflow on a schedule (currently set to run once every 12 months at 6 AM, which seems unusual and likely requires adjustment).\nConfiguration: Interval set with a 12-month interval at hour 6.\nConnections: Outputs to \"Quote\".\nEdge Cases: Scheduling frequency likely misconfigured or placeholder; adjust for practical use.\n1.3.2 \"Quote\"\nType: HTTP Request\nRole: Fetches a random quote from\nhttps://zenquotes.io/api/random\n.\nConfiguration: Simple GET request.\nConnections: Outputs to \"Programming joke\".\nEdge Cases: Same as previous quote nodes.\n1.3.3 \"Programming joke\"\nType: HTTP Request\nRole: Retrieves a programming joke from\nhttps://v2.jokeapi.dev/joke/Programming\nwith safe content filters.\nConfiguration: URL includes parameters to blacklist nsfw, religious, political, racist, sexist, explicit content, and requests single-part jokes only.\nConnections: Outputs to \"Map the fields\".\nEdge Cases: API downtime, empty or unexpected joke format.\n1.3.4 \"Map the fields\"\nType: Set\nRole: Intended to map\nauthor\n,\nquote\n, and\njoke\nfields for downstream use.\nConfiguration: All three fields assigned with empty expressions\n=\n, indicating placeholders that require proper field mapping expressions to extract data from previous nodes.\nConnections: Terminal node in this block.\nEdge Cases: Incorrect or missing mapping expressions will lead to empty data fields.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nSticky Note3\nSticky Note\nGuidance on scheduling and Gmail setup\nNone\nNone\n## ... now let's schedule it ‚è∞ 1. Double-click ‚ÄúSchedule‚Äù to set when it runs 2. Connect your Gmail and set the recepient 3. To test, click ‚ÄúExecute workflow‚Äù on the \"Schedule\" node\nSticky Note2\nSticky Note\nEmpty note\nNone\nNone\nSchedule me here\nSchedule Trigger\nTriggers daily quote retrieval at 7 AM\nNone\nGet quote\nDouble-click to set!\nResults\nSet\nFormats quote and author fields\nGet quote\nConnect your Gmail\nGet quote\nHTTP Request\nFetches random inspirational quote\nSchedule me here\nResults\nConnect your Gmail\nGmail\nSends quote email\nResults\nNone\nDouble-click here to connect!\nSticky Note15\nSticky Note\nEmpty note\nNone\nNone\nSticky Note\nSticky Note\nIntroductory instructions for manual workflow\nNone\nNone\n## üöÄüöÄ Start here üöÄüöÄ 1. Click ‚ÄúExecute workflow‚Äù to run it 2. This gets a random quote from the internet 3. Double-click the last node to check what quote you got\n1. Click 'Execute workflow‚Äô\nManual Trigger\nManual trigger for quote retrieval\nNone\n2. Get inspirational quote from the internet\n2. Get inspirational quote from the internet\nHTTP Request\nFetches random inspirational quote\n1. Click 'Execute workflow‚Äô\n3. See the resutls\n3. See the resutls\nSet\nFormats quote and author fields\n2. Get inspirational quote from the internet\nNone\nDouble-click to open!\nSticky Note6\nSticky Note\nEmpty note\nNone\nNone\nSticky Note4\nSticky Note\nGuidance on adding a joke to emails\nNone\nNone\n## ‚ùì How about a joke... 1. Execute this workflow 2. Check out the new \"Programming Joke\" 3. Try mapping the new results and add them to your email\nSticky Note5\nSticky Note\nEmpty note\nNone\nNone\nQuote\nHTTP Request\nFetches random inspirational quote\nSchedule Trigger\nProgramming joke\nSchedule Trigger\nSchedule Trigger\nTriggers quote and joke retrieval (yearly at 6 AM)\nNone\nQuote\nMap the fields\nSet\nMaps fields for author, quote, and joke\nProgramming joke\nNone\nDouble-click to set!\nProgramming joke\nHTTP Request\nFetches programming joke\nQuote\nMap the fields\nCheck out after running!\nSticky Note1\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note8\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note7\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note9\nSticky Note\nStep 1 title\nNone\nNone\n# Step 1\nSticky Note10\nSticky Note\nStep 2 title\nNone\nNone\n# Step 2\nSticky Note11\nSticky Note\nStep 3 title\nNone\nNone\n# Step 3\nSticky Note13\nSticky Note\nReminder to add Gmail credentials\nNone\nNone\n### Click + to add Gmail\n4. Reproducing the Workflow from Scratch\nCreate the Manual Trigger Block\n1.1 Add a\nManual Trigger\nnode named\n\"1. Click 'Execute workflow‚Äô\"\n. No parameters needed.\n1.2 Add an\nHTTP Request\nnode named\n\"2. Get inspirational quote from the internet\"\n. Configure:\n- HTTP Method: GET\n- URL:\nhttps://zenquotes.io/api/random\n1.3 Connect the Manual Trigger node output to the HTTP Request node input.\n1.4 Add a\nSet\nnode named\n\"3. See the resutls\"\n. Configure to assign two string fields:\n-\nquote\n=\n{{$json.q}}\n-\nauthor\n=\n{{$json.a}}\n1.5 Connect the HTTP Request node output to the Set node input.\nCreate the Scheduled Quote Delivery Block\n2.1 Add a\nSchedule Trigger\nnode named\n\"Schedule me here\"\n. Configure to trigger daily at 07:00 AM (adjust timezone as needed).\n2.2 Add an\nHTTP Request\nnode named\n\"Get quote\"\nwith the same configuration as in 1.2.\n2.3 Connect\n\"Schedule me here\"\noutput to\n\"Get quote\"\ninput.\n2.4 Add a\nSet\nnode named\n\"Results\"\nwith the same field assignments as in 1.4.\n2.5 Connect\n\"Get quote\"\noutput to\n\"Results\"\ninput.\n2.6 Add a\nGmail\nnode named\n\"Connect your Gmail\"\n. Configure:\n- Connect your Gmail account via OAuth2 credentials.\n- Set email subject to\n\"Daily quote\"\n.\n- Set email body (plain text) to:\nHey,    Here's a quote by {{ $json.author }}:    \"{{ $json.quote }}\"\n2.7 Connect\n\"Results\"\noutput to\n\"Connect your Gmail\"\ninput.\nCreate the Joke Retrieval and Mapping Block\n3.1 Add a\nSchedule Trigger\nnode named\n\"Schedule Trigger\"\n. Initially set to run yearly at 6 AM (adjust as needed).\n3.2 Add an\nHTTP Request\nnode named\n\"Quote\"\nwith GET to\nhttps://zenquotes.io/api/random\n.\n3.3 Connect\n\"Schedule Trigger\"\noutput to\n\"Quote\"\ninput.\n3.4 Add an\nHTTP Request\nnode named\n\"Programming joke\"\n. Configure:\n- HTTP Method: GET\n- URL:\nhttps://v2.jokeapi.dev/joke/Programming?blacklistFlags=nsfw,religious,political,racist,sexist,explicit&type=single\n3.5 Connect\n\"Quote\"\noutput to\n\"Programming joke\"\ninput.\n3.6 Add a\nSet\nnode named\n\"Map the fields\"\n. Configure to assign the following string fields (to be updated with correct expressions):\n-\nauthor\n=\n=your expression here\n-\nquote\n=\n=your expression here\n-\njoke\n=\n=your expression here\n3.7 Connect\n\"Programming joke\"\noutput to\n\"Map the fields\"\ninput.\nAdd Sticky Notes\nas per the original workflow for guidance and video links:\nAdd sticky notes with instructional content on scheduling, workflow execution, and adding Gmail credentials.\nAdd YouTube video links in sticky notes for additional learning resources.\nCredentials Setup\nFor the Gmail node, configure OAuth2 credentials by connecting your Gmail account securely inside n8n.\nNo credentials are needed for the HTTP requests as they use public APIs.\nFinal Testing and Validation\nManually execute the manual trigger block to verify quote retrieval and formatting.\nAdjust schedule triggers and test scheduled runs.\nVerify Gmail node sends emails correctly with dynamic quote content.\nFix any mapping expressions in\n\"Map the fields\"\nnode to extract correct values from prior nodes.\n5. General Notes & Resources\nNote Content\nContext or Link\n@\nyoutube\nYouTube video linked in Sticky Note1\n@\nyoutube\nYouTube video linked in Sticky Note8\n@\nyoutube\nYouTube video linked in Sticky Note7\n## ... now let's schedule it ‚è∞ 1. Double-click ‚ÄúSchedule‚Äù to set when it runs 2. Connect your Gmail and set the recepient 3. To test, click ‚ÄúExecute workflow‚Äù on the \"Schedule\" node\nGuidance in Sticky Note3\n## üöÄüöÄ Start here üöÄüöÄ 1. Click ‚ÄúExecute workflow‚Äù to run it 2. This gets a random quote from the internet 3. Double-click the last node to check what quote you got\nGuidance in Sticky Note\n## ‚ùì How about a joke... 1. Execute this workflow 2. Check out the new \"Programming Joke\" 3. Try mapping the new results and add them to your email\nGuidance in Sticky Note4\n### Click + to add Gmail\nReminder in Sticky Note13\nDisclaimer:\nThe provided content is exclusively generated from the n8n workflow JSON shared. It adheres strictly to content policies and contains no illegal, offensive, or protected elements. All data handled is legal and publicly accessible.\nCopied to clipboard",
      "description_full_fr": "Apprenez les bases de n8n en 3 √©tapes faciles ‚ú®\n1. Aper√ßu du flux de travail\nCe flux de travail, intitul√©\n\"Apprenez les bases du n8n en 3 √©tapes faciles ‚ú®\"\n, est une automatisation conviviale pour les d√©butants con√ßue pour d√©montrer les fonctionnalit√©s cl√©s de n8n en r√©cup√©rant des citations inspirantes et en programmant des blagues √† partir d'API publiques, en traitant leurs donn√©es, en planifiant des ex√©cutions automatis√©es et en envoyant les r√©sultats par e-mail. Il cible les utilisateurs qui souhaitent apprendre les bases de n8n en cr√©ant un exemple pratique int√©grant les requ√™tes Web, la transformation des donn√©es, la planification et l'envoi d'e-mails.\nLe workflow est logiquement divis√© en trois blocs principaux¬†:\n1.1 Bloc de r√©cup√©ration manuelle des devis¬†:\nPermet un d√©clenchement manuel pour r√©cup√©rer une citation inspirante al√©atoire et afficher les r√©sultats imm√©diatement.\n1.2 Blocage de livraison de devis programm√©¬†:\nR√©cup√®re automatiquement une citation inspirante al√©atoire quotidiennement √† une heure sp√©cifi√©e, traite les donn√©es et l'envoie via Gmail.\n1.3 Bloc de r√©cup√©ration et de cartographie des blagues¬†:\nR√©cup√®re une blague de programmation, mappe ses champs de donn√©es avec le devis et la pr√©pare pour une int√©gration ult√©rieure du courrier √©lectronique.\nPlusieurs notes autocollantes guident les utilisateurs de mani√®re interactive sur l'ex√©cution, la planification et l'extension du flux de travail.\n2. Analyse bloc par bloc\n1.1 Bloc de r√©cup√©ration manuelle des devis\nAper√ßu¬†:\nCe bloc permet aux utilisateurs de d√©clencher manuellement le flux de travail, de r√©cup√©rer une citation inspirante al√©atoire √† partir d'une API externe et d'afficher le r√©sultat structur√©.\nN≈ìuds impliqu√©s¬†:\n1.1.1 \"1. Cliquez sur 'Ex√©cuter le workflow'\" (D√©clencheur manuel)\n1.1.2 \"2. Obtenez une citation inspirante sur Internet\" (demande HTTP)\n1.1.3 \"3. Voir les r√©sultats\" (Set)\nD√©tails du n≈ìud¬†:\n1.1.1 \"1. Cliquez sur 'Ex√©cuter le workflow'\"\nType : D√©clencheur manuel\nR√¥le¬†: point d'entr√©e pour l'ex√©cution manuelle.\nConfiguration¬†:¬†Aucun param√®tre¬†; d√©clenche le flux de travail sur commande manuelle.\nConnexions¬†:¬†sorties vers \"2. Obtenez une citation inspirante sur Internet\".\nCas extr√™mes¬†:¬†aucun significatif¬†; le d√©clencheur manuel est contr√¥l√© par l'utilisateur.\n1.1.2 \"2. Obtenez une citation inspirante sur Internet\"\nType¬†:¬†Requ√™te HTTP\nR√¥le¬†: R√©cup√®re une citation inspirante al√©atoire JSON √† partir de\nhttps://zenquotes.io/api/random\n.\nConfiguration¬†: requ√™te GET simple, pas d'authentification ni d'en-t√™tes suppl√©mentaires.\nConnexions : Sorties vers \"3. Voir les r√©sultats\".\nCas extr√™mes¬†: indisponibilit√© de l'API, limitation du d√©bit ou r√©ponse mal form√©e. Doit g√©rer les erreurs HTTP ou les donn√©es vides avec √©l√©gance.\n1.1.3 \"3. Voir les r√©sultats\"\nType: Ensemble\nR√¥le¬†: extrait et formate les champs de citation et d'auteur de la r√©ponse de l'API pour une utilisation plus facile.\nConfiguration¬†:¬†affecte\ncitation\n=\n{{$json.q}}\n,\nauteur\n=\n{{$json.a}}\n.\nConnexions¬†: N≈ìud terminal pour ce bloc.\nCas extr√™mes¬†: les champs manquants dans la r√©ponse de l'API peuvent entra√Æner des valeurs vides ou non d√©finies.\n1.2 Blocage de livraison de devis programm√©\nAper√ßu¬†:\nCe bloc planifie une t√¢che quotidienne automatis√©e pour r√©cup√©rer un devis al√©atoire, le traiter et l'envoyer via Gmail √† un destinataire configur√©.\nN≈ìuds impliqu√©s¬†:\n1.2.1 ¬´ Planifiez-moi ici ¬ª (D√©clencheur de planification)\n1.2.2 \"Obtenir un devis\" (Demande HTTP)\n1.2.3 \"R√©sultats\" (Ensemble)\n1.2.4 \"Connectez votre Gmail\" (n≈ìud Gmail)\nD√©tails du n≈ìud¬†:\n1.2.1 ¬´ Planifiez-moi ici ¬ª\nType¬†: D√©clencheur de planification\nR√¥le¬†: d√©marre le flux de travail automatiquement tous les jours √† 07h00.\nConfiguration¬†:¬†r√®gle d'intervalle d√©finie pour se d√©clencher quotidiennement √† 7 heures du matin.\nConnexions¬†: Sorties vers \"Obtenir un devis\".\nCas extr√™mes¬†: consid√©rations relatives au fuseau horaire¬†; assurez-vous que le fuseau horaire du serveur correspond aux attentes.\n1.2.2 \"Obtenir un devis\"\nType¬†:¬†Requ√™te HTTP\nR√¥le¬†: R√©cup√®re une citation inspirante al√©atoire JSON √† partir de\nhttps://zenquotes.io/api/random\n, comme dans le bloc manuel.\nConfiguration¬†: simple requ√™te GET.\nConnexions¬†:¬†sorties vers \"R√©sultats\".\nCas Edge¬†: Identique au bloc manuel¬†; g√©rer les erreurs API.\n1.2.3 \"R√©sultats\"\nType: Ensemble\nR√¥le¬†: Formate les champs devis et auteur √† partir de la r√©ponse API, identique au bloc manuel.\nConfiguration¬†:¬†affecte\ncitation\n=\n{{$json.q}}\n,\nauteur\n=\n{{$json.a}}\n.\nConnexions¬†: sorties vers \"Connectez votre Gmail\".\nCas extr√™mes¬†:¬†donn√©es manquantes ou mal form√©es de l'API.\n1.2.4 \"Connectez votre Gmail\"\nTapez¬†: n≈ìud Gmail (Envoyer un e-mail)\nR√¥le¬†: envoie un e-mail contenant la citation et l'auteur au destinataire configur√©.\nConfiguration¬†:\nObjet¬†: \"Citation quotidienne\"\nCorps de l'e-mail¬†: texte brut avec mod√®le¬†:\nH√©,\n\nVoici une citation de {{ $json.author }}¬†:\n\n\"{{ $json.quote }}\"\nCredentials: OAuth2 Gmail account configured (note: user must connect manually).\nConnections: Terminal node for this block.\nEdge Cases: Authentication failures, rate limiting on Gmail API, invalid recipient addresses.\n1.3 Joke Retrieval and Mapping Block\nOverview:\nThis block fetches a programming joke from a public API, combines it with the quote data, and maps all fields for future use, such as adding jokes to emails.\nNodes Involved:\n1.3.1 \"Schedule Trigger\" (Schedule Trigger)\n1.3.2 \"Quote\" (HTTP Request)\n1.3.3 \"Programming joke\" (HTTP Request)\n1.3.4 \"Map the fields\" (Set)\nNode Details:\n1.3.1 \"Schedule Trigger\"\nType: Schedule Trigger\nRole: Triggers the workflow on a schedule (currently set to run once every 12 months at 6 AM, which seems unusual and likely requires adjustment).\nConfiguration: Interval set with a 12-month interval at hour 6.\nConnections: Outputs to \"Quote\".\nEdge Cases: Scheduling frequency likely misconfigured or placeholder; adjust for practical use.\n1.3.2 \"Quote\"\nType: HTTP Request\nRole: Fetches a random quote from\nhttps://zenquotes.io/api/random\n.\nConfiguration: Simple GET request.\nConnections: Outputs to \"Programming joke\".\nEdge Cases: Same as previous quote nodes.\n1.3.3 \"Programming joke\"\nType: HTTP Request\nRole: Retrieves a programming joke from\nhttps://v2.jokeapi.dev/joke/Programming\nwith safe content filters.\nConfiguration: URL includes parameters to blacklist nsfw, religious, political, racist, sexist, explicit content, and requests single-part jokes only.\nConnections: Outputs to \"Map the fields\".\nEdge Cases: API downtime, empty or unexpected joke format.\n1.3.4 \"Map the fields\"\nType: Set\nRole: Intended to map\nauthor\n,\nquote\n, and\njoke\nfields for downstream use.\nConfiguration: All three fields assigned with empty expressions\n=\n, indicating placeholders that require proper field mapping expressions to extract data from previous nodes.\nConnections: Terminal node in this block.\nEdge Cases: Incorrect or missing mapping expressions will lead to empty data fields.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nSticky Note3\nSticky Note\nGuidance on scheduling and Gmail setup\nNone\nNone\n## ... now let's schedule it ‚è∞ 1. Double-click ‚ÄúSchedule‚Äù to set when it runs 2. Connect your Gmail and set the recepient 3. To test, click ‚ÄúExecute workflow‚Äù on the \"Schedule\" node\nSticky Note2\nSticky Note\nEmpty note\nNone\nNone\nSchedule me here\nSchedule Trigger\nTriggers daily quote retrieval at 7 AM\nNone\nGet quote\nDouble-click to set!\nResults\nSet\nFormats quote and author fields\nGet quote\nConnect your Gmail\nGet quote\nHTTP Request\nFetches random inspirational quote\nSchedule me here\nResults\nConnect your Gmail\nGmail\nSends quote email\nResults\nNone\nDouble-click here to connect!\nSticky Note15\nSticky Note\nEmpty note\nNone\nNone\nSticky Note\nSticky Note\nIntroductory instructions for manual workflow\nNone\nNone\n## üöÄüöÄ Start here üöÄüöÄ 1. Click ‚ÄúExecute workflow‚Äù to run it 2. This gets a random quote from the internet 3. Double-click the last node to check what quote you got\n1. Click 'Execute workflow‚Äô\nManual Trigger\nManual trigger for quote retrieval\nNone\n2. Get inspirational quote from the internet\n2. Get inspirational quote from the internet\nHTTP Request\nFetches random inspirational quote\n1. Click 'Execute workflow‚Äô\n3. See the resutls\n3. See the resutls\nSet\nFormats quote and author fields\n2. Get inspirational quote from the internet\nNone\nDouble-click to open!\nSticky Note6\nSticky Note\nEmpty note\nNone\nNone\nSticky Note4\nSticky Note\nGuidance on adding a joke to emails\nNone\nNone\n## ‚ùì How about a joke... 1. Execute this workflow 2. Check out the new \"Programming Joke\" 3. Try mapping the new results and add them to your email\nSticky Note5\nSticky Note\nEmpty note\nNone\nNone\nQuote\nHTTP Request\nFetches random inspirational quote\nSchedule Trigger\nProgramming joke\nSchedule Trigger\nSchedule Trigger\nTriggers quote and joke retrieval (yearly at 6 AM)\nNone\nQuote\nMap the fields\nSet\nMaps fields for author, quote, and joke\nProgramming joke\nNone\nDouble-click to set!\nProgramming joke\nHTTP Request\nFetches programming joke\nQuote\nMap the fields\nCheck out after running!\nSticky Note1\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note8\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note7\nSticky Note\nYouTube link\nNone\nNone\n@\nyoutube\nSticky Note9\nSticky Note\nStep 1 title\nNone\nNone\n# Step 1\nSticky Note10\nSticky Note\nStep 2 title\nNone\nNone\n# Step 2\nSticky Note11\nSticky Note\nStep 3 title\nNone\nNone\n# Step 3\nSticky Note13\nSticky Note\nReminder to add Gmail credentials\nNone\nNone\n### Click + to add Gmail\n4. Reproducing the Workflow from Scratch\nCreate the Manual Trigger Block\n1.1 Add a\nManual Trigger\nnode named\n\"1. Click 'Execute workflow‚Äô\"\n. No parameters needed.\n1.2 Add an\nHTTP Request\nnode named\n\"2. Get inspirational quote from the internet\"\n. Configure:\n- HTTP Method: GET\n- URL:\nhttps://zenquotes.io/api/random\n1.3 Connect the Manual Trigger node output to the HTTP Request node input.\n1.4 Add a\nSet\nnode named\n\"3. See the resutls\"\n. Configure to assign two string fields:\n-\nquote\n=\n{{$json.q}}\n-\nauthor\n=\n{{$json.a}}\n1.5 Connect the HTTP Request node output to the Set node input.\nCreate the Scheduled Quote Delivery Block\n2.1 Add a\nSchedule Trigger\nnode named\n\"Schedule me here\"\n. Configure to trigger daily at 07:00 AM (adjust timezone as needed).\n2.2 Add an\nHTTP Request\nnode named\n\"Get quote\"\nwith the same configuration as in 1.2.\n2.3 Connect\n\"Schedule me here\"\noutput to\n\"Get quote\"\ninput.\n2.4 Add a\nSet\nnode named\n\"Results\"\nwith the same field assignments as in 1.4.\n2.5 Connect\n\"Get quote\"\noutput to\n\"Results\"\ninput.\n2.6 Add a\nGmail\nnode named\n\"Connect your Gmail\"\n. Configure:\n- Connect your Gmail account via OAuth2 credentials.\n- Set email subject to\n\"Daily quote\"\n.\n- Set email body (plain text) to:\nHey,    Here's a quote by {{ $json.author }}:    \"{{ $json.quote }}\"\n2.7 Connect\n\"Results\"\noutput to\n\"Connect your Gmail\"\ninput.\nCreate the Joke Retrieval and Mapping Block\n3.1 Add a\nSchedule Trigger\nnode named\n\"Schedule Trigger\"\n. Initially set to run yearly at 6 AM (adjust as needed).\n3.2 Add an\nHTTP Request\nnode named\n\"Quote\"\nwith GET to\nhttps://zenquotes.io/api/random\n.\n3.3 Connect\n\"Schedule Trigger\"\noutput to\n\"Quote\"\ninput.\n3.4 Add an\nHTTP Request\nnode named\n\"Programming joke\"\n. Configure:\n- HTTP Method: GET\n- URL:\nhttps://v2.jokeapi.dev/joke/Programming?blacklistFlags=nsfw,religious,political,racist,sexist,explicit&type=single\n3.5 Connect\n\"Quote\"\noutput to\n\"Programming joke\"\ninput.\n3.6 Add a\nSet\nnode named\n\"Map the fields\"\n. Configure to assign the following string fields (to be updated with correct expressions):\n-\nauthor\n=\n=your expression here\n-\nquote\n=\n=your expression here\n-\njoke\n=\n=your expression here\n3.7 Connect\n\"Programming joke\"\noutput to\n\"Map the fields\"\ninput.\nAdd Sticky Notes\nas per the original workflow for guidance and video links:\nAdd sticky notes with instructional content on scheduling, workflow execution, and adding Gmail credentials.\nAdd YouTube video links in sticky notes for additional learning resources.\nCredentials Setup\nFor the Gmail node, configure OAuth2 credentials by connecting your Gmail account securely inside n8n.\nNo credentials are needed for the HTTP requests as they use public APIs.\nFinal Testing and Validation\nManually execute the manual trigger block to verify quote retrieval and formatting.\nAdjust schedule triggers and test scheduled runs.\nVerify Gmail node sends emails correctly with dynamic quote content.\nFix any mapping expressions in\n\"Map the fields\"\nnode to extract correct values from prior nodes.\n5. General Notes & Resources\nNote Content\nContext or Link\n@\nyoutube\nYouTube video linked in Sticky Note1\n@\nyoutube\nYouTube video linked in Sticky Note8\n@\nyoutube\nYouTube video linked in Sticky Note7\n## ... now let's schedule it ‚è∞ 1. Double-click ‚ÄúSchedule‚Äù to set when it runs 2. Connect your Gmail and set the recepient 3. To test, click ‚ÄúExecute workflow‚Äù on the \"Schedule\" node\nGuidance in Sticky Note3\n## üöÄüöÄ Start here üöÄüöÄ 1. Click ‚ÄúExecute workflow‚Äù to run it 2. This gets a random quote from the internet 3. Double-click the last node to check what quote you got\nGuidance in Sticky Note\n## ‚ùì How about a joke... 1. Execute this workflow 2. Check out the new \"Programming Joke\" 3. Try mapping the new results and add them to your email\nGuidance in Sticky Note4\n### Click + to add Gmail\nReminder in Sticky Note13\nDisclaimer:\nThe provided content is exclusively generated from the n8n workflow JSON shared. It adheres strictly to content policies and contains no illegal, offensive, or protected elements. All data handled is legal and publicly accessible.\nCopied to clipboard\n\n",
      "category": "Marketing",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Miha",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/learn-n8n-basics-in-3-easy-steps-8527",
      "nodes_count": 0
    },
    {
      "id": "007",
      "slug": "gestionnaire-de-vie-personnelle-avec-telegram-services-google-et-ia-vocale",
      "title_en": "Personal Life Manager with Telegram, Google Services & Voice-Enabled AI",
      "title_fr": "Gestionnaire de vie personnelle avec Telegram, services Google et IA vocale",
      "description_short_en": "Manage emails, calendar, and tasks with Caylee‚Äîyour AI assistant on Telegram. Enjoy hands-free voice control and smart Google integration. Learn more!",
      "description_short_fr": "G√©rez les e-mails, le calendrier et les t√¢ches avec Caylee, votre assistant IA sur Telegram. Profitez de la commande vocale mains libres et de l'int√©gration intelligente de Google. Apprendre encore plus!",
      "description_full_en": "Personal Life Manager with Telegram, Google Services & Voice-Enabled AI\n1. Workflow Overview\nThis workflow implements a\nPersonal Life Manager\nintegrating Telegram, Google services (Calendar, Tasks, Gmail), and Voice-Enabled AI using OpenAI/OpenRouter models. Its primary purpose is to allow users to interact with their digital life through Telegram messages and voice notes, enabling hands-free management of emails, calendar events, and tasks via conversational AI.\nLogical blocks of the workflow:\n1.1 Input Reception and Preprocessing:\nReceives Telegram messages or voice notes, distinguishes input type (voice or text), and prepares data for processing.\n1.2 Voice Transcription:\nConverts incoming voice messages from Telegram into text using OpenAI's transcription API.\n1.3 Contextual Memory Management:\nMaintains a conversational memory buffer keyed per user to allow contextual AI interactions.\n1.4 AI Processing and Task Handling:\nThe core AI agent ‚ÄúCaylee‚Äù processes user queries by accessing Gmail, Google Calendar, Tasks, and responding accordingly.\n1.5 Google Services Integration:\nNodes specifically fetch emails, calendar events, and manage Google Tasks as requested by the user.\n1.6 Response Delivery:\nSends the AI-generated replies back to the user via Telegram.\nSupporting elements include sticky notes providing setup instructions, usage tips, and video tutorial links.\n2. Block-by-Block Analysis\n2.1 Input Reception and Preprocessing\nOverview:\nThis block captures incoming Telegram updates (messages or voice notes), distinguishes between voice and text inputs, and filters empty messages.\nNodes Involved:\nListen for incoming events\nVoice or Text (Set node)\nIf (Conditional node)\nGet Voice File\nNode Details:\nListen for incoming events\nType: Telegram Trigger\nRole: Entry point to capture Telegram messages (text or voice).\nConfig: Listens to \"message\" updates; uses Telegram credentials.\nInput: External webhook from Telegram.\nOutput: JSON message payload containing Telegram message data.\nFailure modes: Telegram API downtime, webhook misconfiguration, invalid message format.\nVoice or Text\nType: Set\nRole: Extracts message text or sets empty string if absent.\nConfig: Sets a variable\ntext\nwith\n{{$json?.message?.text || \"\"}}\nto handle both text and voice inputs uniformly.\nInput: From Telegram trigger node.\nOutput: Contains\ntext\nfield for downstream conditional check.\nIf\nType: If (Conditional)\nRole: Checks if the incoming message text is empty (distinguishes voice messages).\nConfig: Condition tests if\n{{$json.message.text}}\nis empty.\nInput: From \"Voice or Text\" node.\nOutput:\nTrue: No text present ‚Üí proceed to get voice file.\nFalse: Text present ‚Üí proceed to AI assistant directly.\nEdge cases: Empty messages (no text or voice), malformed messages.\nGet Voice File\nType: Telegram node (File resource)\nRole: Fetches the voice file from Telegram using the voice message file ID.\nConfig: Uses\n{{$('Listen for incoming events').item.json.message.voice.file_id}}\nto get the voice file.\nInput: Triggered if message has no text (voice message).\nOutput: Voice file binary data for transcription.\nFailure modes: File ID missing or expired, Telegram file API errors.\n2.2 Voice Transcription\nOverview:\nConverts the Telegram voice message audio into text using OpenAI‚Äôs transcription capabilities.\nNodes Involved:\nTranscribe a recording\nNode Details:\nTranscribe a recording\nType: OpenAI node (audio resource)\nRole: Transcribes voice audio to text.\nConfig: Operation set to \"transcribe\"; requires OpenAI API credentials.\nInput: Receives audio binary from \"Get Voice File\" node.\nOutput: Transcribed text for AI processing.\nEdge cases: Audio quality issues, transcription API errors, rate limits.\n2.3 Contextual Memory Management\nOverview:\nMaintains a sliding window memory buffer per user session to keep conversation context for the AI assistant.\nNodes Involved:\nWindow Buffer Memory\nNode Details:\nWindow Buffer Memory\nType: LangChain memory buffer (window)\nRole: Stores recent conversation messages keyed by Telegram user ID to maintain context.\nConfig: Session key derived from\n{{$('Listen for incoming events').first().json.message.from.id}}\n.\nInput: Connected to AI assistant node.\nOutput: Provides memory context for AI prompt.\nEdge cases: Memory overflow, session key missing, concurrency issues.\n2.4 AI Processing and Task Handling\nOverview:\nMain AI agent ‚ÄúCaylee‚Äù interprets user input, accesses Google APIs as needed, and generates responses.\nNodes Involved:\nCaylee, AI Assistant üë©üèª‚Äçüè´\nOpenRouter\nGet Email\nGoogle Calendar\nCreate a task in Google Tasks\nGet many tasks in Google Tasks\nNode Details:\nCaylee, AI Assistant üë©üèª‚Äçüè´\nType: LangChain Agent\nRole: Core conversational AI agent processing user queries.\nConfig: Uses a system message defining assistant behavior (personal assistant called Caylee with specific guidelines on email summary, calendar filtering, and date assumptions).\nInputs: Text from transcription or direct message, AI language model from OpenRouter, contextual memory, Google services nodes input.\nOutputs: Text response to send back to Telegram.\nEdge cases: Model API errors, prompt formatting issues, external API failures.\nOpenRouter\nType: LangChain OpenRouter Language Model\nRole: Provides AI language model backend for Caylee.\nConfig: Uses OpenRouter API key credential.\nInput: Receives prompt from Caylee node.\nOutput: AI-generated completions.\nFailure modes: API key invalid, rate limits, network errors.\nGet Email\nType: Gmail Tool\nRole: Retrieves recent unread emails from user inbox.\nConfig: Limit 20 emails, filters for INBOX and UNREAD labels.\nInput: Triggered by AI agent when email info requested.\nOutput: Email summaries to AI agent.\nFailure modes: Gmail API auth errors, quota limits, network issues.\nGoogle Calendar\nType: Google Calendar Tool\nRole: Fetches calendar events after a date specified by AI.\nConfig: Uses dynamic date from AI input; retrieves summary and start time fields.\nInput: AI agent request.\nOutput: Calendar events data to AI agent.\nFailure modes: OAuth token expiry, invalid date format, API errors.\nCreate a task in Google Tasks\nType: Google Tasks Tool\nRole: Creates new task with title provided by AI.\nConfig: Task list ID hardcoded; title dynamically set from AI output.\nInput: AI agent triggers task creation.\nOutput: Confirmation of task creation.\nFailure modes: OAuth errors, invalid task data.\nGet many tasks in Google Tasks\nType: Google Tasks Tool\nRole: Retrieves all tasks from specified task list.\nConfig: Task list ID hardcoded.\nInput: AI agent requests task list.\nOutput: Task list data.\nFailure modes: OAuth failures, empty task list.\n2.5 Response Delivery\nOverview:\nDelivers the AI-generated textual response back to the Telegram user in Markdown format.\nNodes Involved:\nTelegram\nNode Details:\nTelegram\nType: Telegram node (send message)\nRole: Sends text messages to Telegram user chat.\nConfig: Text from AI output; chat ID from incoming Telegram message; Markdown parse mode; attribution disabled.\nInput: From AI assistant node output.\nOutput: Message sent to Telegram user.\nFailure modes: Telegram API rate limits, invalid chat ID, network errors.\nOn error: Set to continue without stopping the workflow.\n2.6 Supportive Sticky Notes\nSticky notes provide setup instructions, usage guidance, and links, including:\nSetup instructions for OpenRouter API key.\nOpenAI API key setup for transcription.\nExplanation of memory buffer role.\nGoogle Tasks, Gmail, Google Calendar node purposes.\nVideo tutorial link:\nhttps://youtu.be/ROgf5dVqYPQ\n.\nIntroductory user instructions and community link:\nAI Automation Engineering Community\n.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nListen for incoming events\nTelegram Trigger\nEntry point for Telegram messages\n‚Äî\nVoice or Text\nVoice or Text\nSet\nExtract text or set empty string\nListen for incoming events\nIf\n## Process Telegram Request\nIf\nIf\nChecks if message text is empty\nVoice or Text\nGet Voice File / Caylee AI\nGet Voice File\nTelegram node (file resource)\nRetrieves voice file from Telegram\nIf (true branch)\nTranscribe a recording\nTranscribe a recording\nOpenAI (audio transcription)\nConverts voice audio to text\nGet Voice File\nCaylee AI\nUses OpenAI to convert voice to text.\nOpenAI API Key setup link\nWindow Buffer Memory\nLangChain memory buffer (window)\nMaintains conversation memory\n‚Äî\nCaylee AI\nThis node helps your agent remember the last few messages to stay on topic.\nCaylee, AI Assistant üë©üèª‚Äçüè´\nLangChain Agent\nCore AI assistant processing user\nVoice or Text / Transcribe / Google nodes / Window Buffer Memory\nTelegram\nCaylee, your personal AI assistant: get email, calendar, tasks. Edit system message to adjust behavior.\nOpenRouter\nLangChain language model (OpenRouter)\nAI language model backend\nCaylee AI\nCaylee AI\n¬© 2025 Lucas Peyrin. Setup instructions in sticky note.\nGet Email\nGmail Tool\nFetches unread emails\nCaylee AI\nCaylee AI\nThis node allows your agent access your Gmail.\nGoogle Calendar\nGoogle Calendar Tool\nFetches calendar events\nCaylee AI\nCaylee AI\nThis node allows your agent access your Google calendar.\nCreate a task in Google Tasks\nGoogle Tasks Tool\nCreates new Google task\nCaylee AI\nCaylee AI\nThis node allows your agent create and get tasks from Google Tasks.\nGet many tasks in Google Tasks\nGoogle Tasks Tool\nRetrieves Google tasks list\nCaylee AI\nCaylee AI\nTelegram\nTelegram node (send message)\nSends AI response back to user\nCaylee AI\n‚Äî\nSends message back to Telegram.\nSticky Note\nSticky Note\nSetup and instructional notes\n‚Äî\n‚Äî\n# Try It Out! Instructions and community link:\nAI Automation Engineering Community\nSticky Note1\nSticky Note\nOpenRouter API key setup\n‚Äî\n‚Äî\nIn OpenRouter create API key and configure OpenRouter node.\nSticky Note13\nSticky Note\nOverview of Caylee AI Assistant\n‚Äî\n‚Äî\nCaylee, your personal AI assistant: get email, calendar, and tasks.\nSticky Note15\nSticky Note\nExplains memory buffer node\n‚Äî\n‚Äî\nThis node helps your agent remember the last few messages to stay on topic.\nSticky Note16\nSticky Note\nExplains Google Tasks integration\n‚Äî\n‚Äî\nThis node allows your agent create and get tasks from Google Tasks.\nSticky Note18\nSticky Note\nExplains Gmail integration\n‚Äî\n‚Äî\nThis node allows your agent access your Gmail.\nSticky Note19\nSticky Note\nExplains Google Calendar integration\n‚Äî\n‚Äî\nThis node allows your agent access your Google calendar.\nSticky Note20\nSticky Note\nExplains OpenAI transcription setup\n‚Äî\n‚Äî\nUses OpenAI to convert voice to text.\nOpenAI API Key setup link\nSticky Note2\nSticky Note\nVideo tutorial link\n‚Äî\n‚Äî\nVideo Tutorial\nSticky Note3\nSticky Note\nUser instructions and community link\n‚Äî\n‚Äî\n# Try It Out! with Telegram commands examples and community link.\nSticky Note4\nSticky Note\nExplains Telegram response node\n‚Äî\n‚Äî\nSend message back to Telegram.\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger node (\"Listen for incoming events\")\nType: Telegram Trigger\nConfigure: Listen to \"message\" updates, set webhook ID.\nCredentials: Connect Telegram API account.\nPosition: Start node.\nAdd Set node (\"Voice or Text\")\nType: Set\nParameters: Create field\ntext\nwith expression\n{{$json?.message?.text || \"\"}}\n.\nConnect from Telegram Trigger node.\nAdd If node (\"If\")\nType: If (version 2)\nCondition: Check if\n{{$json.message.text}}\nis empty (string empty operator).\nConnect from \"Voice or Text\" node.\nAdd Telegram node (\"Get Voice File\")\nType: Telegram\nResource: File\nParameters: File ID set to\n{{$('Listen for incoming events').item.json.message.voice.file_id}}\n.\nCredentials: Telegram API account.\nConnect from If node, True branch (empty text).\nAdd OpenAI node (\"Transcribe a recording\")\nType: OpenAI (resource audio)\nOperation: Transcribe\nCredentials: OpenAI API key configured.\nConnect from \"Get Voice File\".\nAdd LangChain Window Buffer Memory node (\"Window Buffer Memory\")\nType: @n8n/n8n-nodes-langchain.memoryBufferWindow\nParameters:\nsessionKey\nset to\n{{$('Listen for incoming events').first().json.message.from.id}}\n, sessionIdType: customKey.\nPosition near AI node.\nAdd LangChain OpenRouter Language Model node (\"OpenRouter\")\nType: @n8n/n8n-nodes-langchain.lmChatOpenRouter\nCredentials: Create and attach OpenRouter API key credential.\nNo specific parameters required.\nAdd LangChain Agent node (\"Caylee, AI Assistant üë©üèª‚Äçüè´\")\nType: @n8n/n8n-nodes-langchain.agent\nParameters:\nText input:\n{{$json.text}}\n(from transcription or text message).\nSystem message: Define assistant behavior (see node for example).\nPrompt type: Define.\nConnect inputs:\nAI Language Model: Connect from OpenRouter node.\nAI Memory: Connect from Window Buffer Memory node.\nAI Tools (multiple): Connect from Gmail, Google Calendar, Google Tasks nodes.\nConnect from If node False branch (text message) and from Transcribe node.\nAdd Gmail Tool node (\"Get Email\")\nType: Gmail Tool\nOperation: Get All\nFilters: LabelIds: INBOX, UNREAD; Limit: 20.\nCredentials: Gmail OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Calendar Tool node (\"Google Calendar\")\nType: Google Calendar Tool\nOperation: Get All\nParameters: TimeMin set dynamically from AI input using expression:\n={{$fromAI(\"date\",\"the date after which to fetch the messages in format YYYY-MM-DDTHH:MM:SS\")}}\nCredentials: Google Calendar OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Tasks Tool node (\"Create a task in Google Tasks\")\nType: Google Tasks Tool\nOperation: Create\nParameters: Task list ID pre-set, title dynamically set from AI input:\n={{$fromAI('Title', '', 'string')}}\nCredentials: Google Tasks OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Tasks Tool node (\"Get many tasks in Google Tasks\")\nType: Google Tasks Tool\nOperation: Get All\nTask list ID pre-set.\nCredentials: Google Tasks OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Telegram node (\"Telegram\")\nType: Telegram (send message)\nParameters:\nText:\n={{ $json.output }}\n(AI agent output).\nChat ID:\n={{ $('Listen for incoming events').first().json.message.from.id }}\nAdditional fields: Parse mode Markdown, no attribution.\nCredentials: Telegram API account.\nConnect from AI Agent node output.\nOn error: Set to continue (do not stop workflow).\nConnect Nodes:\nTelegram Trigger ‚Üí Voice or Text ‚Üí If\nIf True ‚Üí Get Voice File ‚Üí Transcribe a recording ‚Üí Caylee AI\nIf False ‚Üí Caylee AI\nCaylee AI ‚Üí Telegram (send message)\nGoogle services nodes ‚Üí Caylee AI (as AI tools inputs)\nWindow Buffer Memory ‚Üí Caylee AI (AI memory input)\nOpenRouter ‚Üí Caylee AI (AI language model input)\nCredential Setup:\nTelegram API account (bot token)\nOpenAI API key (for transcription)\nOpenRouter API key (for AI language model)\nGmail OAuth2 account\nGoogle Calendar OAuth2 account\nGoogle Tasks OAuth2 account\nFinal Checks:\nWebhook URLs registered properly with Telegram.\nAll credentials authorized and tested.\nSystem message for AI assistant customized for desired behavior.\n5. General Notes & Resources\nNote Content\nContext or Link\n# Try It Out! Launch Caylee‚Äîyour personal AI assistant that handles voice & text via Telegram to manage your digital life. Commands example included.\nSticky Note3\nOpenRouter API key creation instructions and node configuration details.\nSticky Note1, OpenRouter node credential setup\nOpenAI API key creation instructions for voice transcription.\nSticky Note20, Transcribe node credential setup\nThis node helps your agent remember the last few messages to stay on topic.\nSticky Note15, Window Buffer Memory node\nThis node allows your agent create and get tasks from Google Tasks.\nSticky Note16, Google Tasks nodes\nThis node allows your agent access your Gmail.\nSticky Note18, Gmail Tool node\nThis node allows your agent access your Google calendar.\nSticky Note19, Google Calendar node\nVideo tutorial for setup and usage:\nhttps://youtu.be/ROgf5dVqYPQ\nSticky Note2\nAI Automation Engineering Community for support and learning:\nhttps://www.skool.com/ai-automation-engineering-3014\nSticky Note3\nDisclaimer:\nThe text provided originates exclusively from an automated workflow created using n8n, a workflow automation tool. The processing strictly complies with current content policies and contains no illegal, offensive, or protected elements. All handled data is legal and public.\nCopied to clipboard",
      "description_full_fr": "Personal Life Manager with Telegram, Google Services & Voice-Enabled AI\n1. Workflow Overview\nThis workflow implements a\nPersonal Life Manager\nintegrating Telegram, Google services (Calendar, Tasks, Gmail), and Voice-Enabled AI using OpenAI/OpenRouter models. Its primary purpose is to allow users to interact with their digital life through Telegram messages and voice notes, enabling hands-free management of emails, calendar events, and tasks via conversational AI.\nLogical blocks of the workflow:\n1.1 Input Reception and Preprocessing:\nReceives Telegram messages or voice notes, distinguishes input type (voice or text), and prepares data for processing.\n1.2 Voice Transcription:\nConverts incoming voice messages from Telegram into text using OpenAI's transcription API.\n1.3 Contextual Memory Management:\nMaintains a conversational memory buffer keyed per user to allow contextual AI interactions.\n1.4 AI Processing and Task Handling:\nThe core AI agent ‚ÄúCaylee‚Äù processes user queries by accessing Gmail, Google Calendar, Tasks, and responding accordingly.\n1.5 Google Services Integration:\nNodes specifically fetch emails, calendar events, and manage Google Tasks as requested by the user.\n1.6 Response Delivery:\nSends the AI-generated replies back to the user via Telegram.\nSupporting elements include sticky notes providing setup instructions, usage tips, and video tutorial links.\n2. Block-by-Block Analysis\n2.1 Input Reception and Preprocessing\nOverview:\nThis block captures incoming Telegram updates (messages or voice notes), distinguishes between voice and text inputs, and filters empty messages.\nNodes Involved:\nListen for incoming events\nVoice or Text (Set node)\nIf (Conditional node)\nGet Voice File\nNode Details:\nListen for incoming events\nType: Telegram Trigger\nRole: Entry point to capture Telegram messages (text or voice).\nConfig: Listens to \"message\" updates; uses Telegram credentials.\nInput: External webhook from Telegram.\nOutput: JSON message payload containing Telegram message data.\nFailure modes: Telegram API downtime, webhook misconfiguration, invalid message format.\nVoice or Text\nType: Set\nRole: Extracts message text or sets empty string if absent.\nConfig: Sets a variable\ntext\nwith\n{{$json?.message?.text || \"\"}}\nto handle both text and voice inputs uniformly.\nInput: From Telegram trigger node.\nOutput: Contains\ntext\nfield for downstream conditional check.\nIf\nType: If (Conditional)\nRole: Checks if the incoming message text is empty (distinguishes voice messages).\nConfig: Condition tests if\n{{$json.message.text}}\nis empty.\nInput: From \"Voice or Text\" node.\nOutput:\nTrue: No text present ‚Üí proceed to get voice file.\nFalse: Text present ‚Üí proceed to AI assistant directly.\nEdge cases: Empty messages (no text or voice), malformed messages.\nGet Voice File\nType: Telegram node (File resource)\nRole: Fetches the voice file from Telegram using the voice message file ID.\nConfig: Uses\n{{$('Listen for incoming events').item.json.message.voice.file_id}}\nto get the voice file.\nInput: Triggered if message has no text (voice message).\nOutput: Voice file binary data for transcription.\nFailure modes: File ID missing or expired, Telegram file API errors.\n2.2 Voice Transcription\nOverview:\nConverts the Telegram voice message audio into text using OpenAI‚Äôs transcription capabilities.\nNodes Involved:\nTranscribe a recording\nNode Details:\nTranscribe a recording\nType: OpenAI node (audio resource)\nRole: Transcribes voice audio to text.\nConfig: Operation set to \"transcribe\"; requires OpenAI API credentials.\nInput: Receives audio binary from \"Get Voice File\" node.\nOutput: Transcribed text for AI processing.\nEdge cases: Audio quality issues, transcription API errors, rate limits.\n2.3 Contextual Memory Management\nOverview:\nMaintains a sliding window memory buffer per user session to keep conversation context for the AI assistant.\nNodes Involved:\nWindow Buffer Memory\nNode Details:\nWindow Buffer Memory\nType: LangChain memory buffer (window)\nRole: Stores recent conversation messages keyed by Telegram user ID to maintain context.\nConfig: Session key derived from\n{{$('Listen for incoming events').first().json.message.from.id}}\n.\nInput: Connected to AI assistant node.\nOutput: Provides memory context for AI prompt.\nEdge cases: Memory overflow, session key missing, concurrency issues.\n2.4 AI Processing and Task Handling\nOverview:\nMain AI agent ‚ÄúCaylee‚Äù interprets user input, accesses Google APIs as needed, and generates responses.\nNodes Involved:\nCaylee, AI Assistant üë©üèª‚Äçüè´\nOpenRouter\nGet Email\nGoogle Calendar\nCreate a task in Google Tasks\nGet many tasks in Google Tasks\nNode Details:\nCaylee, AI Assistant üë©üèª‚Äçüè´\nType: LangChain Agent\nRole: Core conversational AI agent processing user queries.\nConfig: Uses a system message defining assistant behavior (personal assistant called Caylee with specific guidelines on email summary, calendar filtering, and date assumptions).\nInputs: Text from transcription or direct message, AI language model from OpenRouter, contextual memory, Google services nodes input.\nOutputs: Text response to send back to Telegram.\nEdge cases: Model API errors, prompt formatting issues, external API failures.\nOpenRouter\nType: LangChain OpenRouter Language Model\nRole: Provides AI language model backend for Caylee.\nConfig: Uses OpenRouter API key credential.\nInput: Receives prompt from Caylee node.\nOutput: AI-generated completions.\nFailure modes: API key invalid, rate limits, network errors.\nGet Email\nType: Gmail Tool\nRole: Retrieves recent unread emails from user inbox.\nConfig: Limit 20 emails, filters for INBOX and UNREAD labels.\nInput: Triggered by AI agent when email info requested.\nOutput: Email summaries to AI agent.\nFailure modes: Gmail API auth errors, quota limits, network issues.\nGoogle Calendar\nType: Google Calendar Tool\nRole: Fetches calendar events after a date specified by AI.\nConfig: Uses dynamic date from AI input; retrieves summary and start time fields.\nInput: AI agent request.\nOutput: Calendar events data to AI agent.\nFailure modes: OAuth token expiry, invalid date format, API errors.\nCreate a task in Google Tasks\nType: Google Tasks Tool\nRole: Creates new task with title provided by AI.\nConfig: Task list ID hardcoded; title dynamically set from AI output.\nInput: AI agent triggers task creation.\nOutput: Confirmation of task creation.\nFailure modes: OAuth errors, invalid task data.\nGet many tasks in Google Tasks\nType: Google Tasks Tool\nRole: Retrieves all tasks from specified task list.\nConfig: Task list ID hardcoded.\nInput: AI agent requests task list.\nOutput: Task list data.\nFailure modes: OAuth failures, empty task list.\n2.5 Response Delivery\nOverview:\nDelivers the AI-generated textual response back to the Telegram user in Markdown format.\nNodes Involved:\nTelegram\nNode Details:\nTelegram\nType: Telegram node (send message)\nRole: Sends text messages to Telegram user chat.\nConfig: Text from AI output; chat ID from incoming Telegram message; Markdown parse mode; attribution disabled.\nInput: From AI assistant node output.\nOutput: Message sent to Telegram user.\nFailure modes: Telegram API rate limits, invalid chat ID, network errors.\nOn error: Set to continue without stopping the workflow.\n2.6 Supportive Sticky Notes\nSticky notes provide setup instructions, usage guidance, and links, including:\nSetup instructions for OpenRouter API key.\nOpenAI API key setup for transcription.\nExplanation of memory buffer role.\nGoogle Tasks, Gmail, Google Calendar node purposes.\nVideo tutorial link:\nhttps://youtu.be/ROgf5dVqYPQ\n.\nIntroductory user instructions and community link:\nAI Automation Engineering Community\n.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nListen for incoming events\nTelegram Trigger\nEntry point for Telegram messages\n‚Äî\nVoice or Text\nVoice or Text\nSet\nExtract text or set empty string\nListen for incoming events\nIf\n## Process Telegram Request\nIf\nIf\nChecks if message text is empty\nVoice or Text\nGet Voice File / Caylee AI\nGet Voice File\nTelegram node (file resource)\nRetrieves voice file from Telegram\nIf (true branch)\nTranscribe a recording\nTranscribe a recording\nOpenAI (audio transcription)\nConverts voice audio to text\nGet Voice File\nCaylee AI\nUses OpenAI to convert voice to text.\nOpenAI API Key setup link\nWindow Buffer Memory\nLangChain memory buffer (window)\nMaintains conversation memory\n‚Äî\nCaylee AI\nThis node helps your agent remember the last few messages to stay on topic.\nCaylee, AI Assistant üë©üèª‚Äçüè´\nLangChain Agent\nCore AI assistant processing user\nVoice or Text / Transcribe / Google nodes / Window Buffer Memory\nTelegram\nCaylee, your personal AI assistant: get email, calendar, tasks. Edit system message to adjust behavior.\nOpenRouter\nLangChain language model (OpenRouter)\nAI language model backend\nCaylee AI\nCaylee AI\n¬© 2025 Lucas Peyrin. Setup instructions in sticky note.\nGet Email\nGmail Tool\nFetches unread emails\nCaylee AI\nCaylee AI\nThis node allows your agent access your Gmail.\nGoogle Calendar\nGoogle Calendar Tool\nFetches calendar events\nCaylee AI\nCaylee AI\nThis node allows your agent access your Google calendar.\nCreate a task in Google Tasks\nGoogle Tasks Tool\nCreates new Google task\nCaylee AI\nCaylee AI\nThis node allows your agent create and get tasks from Google Tasks.\nGet many tasks in Google Tasks\nGoogle Tasks Tool\nRetrieves Google tasks list\nCaylee AI\nCaylee AI\nTelegram\nTelegram node (send message)\nSends AI response back to user\nCaylee AI\n‚Äî\nSends message back to Telegram.\nSticky Note\nSticky Note\nSetup and instructional notes\n‚Äî\n‚Äî\n# Try It Out! Instructions and community link:\nAI Automation Engineering Community\nSticky Note1\nSticky Note\nOpenRouter API key setup\n‚Äî\n‚Äî\nIn OpenRouter create API key and configure OpenRouter node.\nSticky Note13\nSticky Note\nOverview of Caylee AI Assistant\n‚Äî\n‚Äî\nCaylee, your personal AI assistant: get email, calendar, and tasks.\nSticky Note15\nSticky Note\nExplains memory buffer node\n‚Äî\n‚Äî\nThis node helps your agent remember the last few messages to stay on topic.\nSticky Note16\nSticky Note\nExplains Google Tasks integration\n‚Äî\n‚Äî\nThis node allows your agent create and get tasks from Google Tasks.\nSticky Note18\nSticky Note\nExplains Gmail integration\n‚Äî\n‚Äî\nThis node allows your agent access your Gmail.\nSticky Note19\nSticky Note\nExplains Google Calendar integration\n‚Äî\n‚Äî\nThis node allows your agent access your Google calendar.\nSticky Note20\nSticky Note\nExplains OpenAI transcription setup\n‚Äî\n‚Äî\nUses OpenAI to convert voice to text.\nOpenAI API Key setup link\nSticky Note2\nSticky Note\nVideo tutorial link\n‚Äî\n‚Äî\nVideo Tutorial\nSticky Note3\nSticky Note\nUser instructions and community link\n‚Äî\n‚Äî\n# Try It Out! with Telegram commands examples and community link.\nSticky Note4\nSticky Note\nExplains Telegram response node\n‚Äî\n‚Äî\nSend message back to Telegram.\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger node (\"Listen for incoming events\")\nType: Telegram Trigger\nConfigure: Listen to \"message\" updates, set webhook ID.\nCredentials: Connect Telegram API account.\nPosition: Start node.\nAdd Set node (\"Voice or Text\")\nType: Set\nParameters: Create field\ntext\nwith expression\n{{$json?.message?.text || \"\"}}\n.\nConnect from Telegram Trigger node.\nAdd If node (\"If\")\nType: If (version 2)\nCondition: Check if\n{{$json.message.text}}\nis empty (string empty operator).\nConnect from \"Voice or Text\" node.\nAdd Telegram node (\"Get Voice File\")\nType: Telegram\nResource: File\nParameters: File ID set to\n{{$('Listen for incoming events').item.json.message.voice.file_id}}\n.\nCredentials: Telegram API account.\nConnect from If node, True branch (empty text).\nAdd OpenAI node (\"Transcribe a recording\")\nType: OpenAI (resource audio)\nOperation: Transcribe\nCredentials: OpenAI API key configured.\nConnect from \"Get Voice File\".\nAdd LangChain Window Buffer Memory node (\"Window Buffer Memory\")\nType: @n8n/n8n-nodes-langchain.memoryBufferWindow\nParameters:\nsessionKey\nset to\n{{$('Listen for incoming events').first().json.message.from.id}}\n, sessionIdType: customKey.\nPosition near AI node.\nAdd LangChain OpenRouter Language Model node (\"OpenRouter\")\nType: @n8n/n8n-nodes-langchain.lmChatOpenRouter\nCredentials: Create and attach OpenRouter API key credential.\nNo specific parameters required.\nAdd LangChain Agent node (\"Caylee, AI Assistant üë©üèª‚Äçüè´\")\nType: @n8n/n8n-nodes-langchain.agent\nParameters:\nText input:\n{{$json.text}}\n(from transcription or text message).\nSystem message: Define assistant behavior (see node for example).\nPrompt type: Define.\nConnect inputs:\nAI Language Model: Connect from OpenRouter node.\nAI Memory: Connect from Window Buffer Memory node.\nAI Tools (multiple): Connect from Gmail, Google Calendar, Google Tasks nodes.\nConnect from If node False branch (text message) and from Transcribe node.\nAdd Gmail Tool node (\"Get Email\")\nType: Gmail Tool\nOperation: Get All\nFilters: LabelIds: INBOX, UNREAD; Limit: 20.\nCredentials: Gmail OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Calendar Tool node (\"Google Calendar\")\nType: Google Calendar Tool\nOperation: Get All\nParameters: TimeMin set dynamically from AI input using expression:\n={{$fromAI(\"date\",\"the date after which to fetch the messages in format YYYY-MM-DDTHH:MM:SS\")}}\nCredentials: Google Calendar OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Tasks Tool node (\"Create a task in Google Tasks\")\nType: Google Tasks Tool\nOperation: Create\nParameters: Task list ID pre-set, title dynamically set from AI input:\n={{$fromAI('Title', '', 'string')}}\nCredentials: Google Tasks OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Google Tasks Tool node (\"Get many tasks in Google Tasks\")\nType: Google Tasks Tool\nOperation: Get All\nTask list ID pre-set.\nCredentials: Google Tasks OAuth2 account.\nConnect to AI Tools input of AI Agent node.\nAdd Telegram node (\"Telegram\")\nType: Telegram (send message)\nParameters:\nText:\n={{ $json.output }}\n(AI agent output).\nChat ID:\n={{ $('Listen for incoming events').first().json.message.from.id }}\nAdditional fields: Parse mode Markdown, no attribution.\nCredentials: Telegram API account.\nConnect from AI Agent node output.\nOn error: Set to continue (do not stop workflow).\nConnect Nodes:\nTelegram Trigger ‚Üí Voice or Text ‚Üí If\nIf True ‚Üí Get Voice File ‚Üí Transcribe a recording ‚Üí Caylee AI\nIf False ‚Üí Caylee AI\nCaylee AI ‚Üí Telegram (send message)\nGoogle services nodes ‚Üí Caylee AI (as AI tools inputs)\nWindow Buffer Memory ‚Üí Caylee AI (AI memory input)\nOpenRouter ‚Üí Caylee AI (AI language model input)\nCredential Setup:\nTelegram API account (bot token)\nOpenAI API key (for transcription)\nOpenRouter API key (for AI language model)\nGmail OAuth2 account\nGoogle Calendar OAuth2 account\nGoogle Tasks OAuth2 account\nFinal Checks:\nWebhook URLs registered properly with Telegram.\nAll credentials authorized and tested.\nSystem message for AI assistant customized for desired behavior.\n5. General Notes & Resources\nNote Content\nContext or Link\n# Try It Out! Launch Caylee‚Äîyour personal AI assistant that handles voice & text via Telegram to manage your digital life. Commands example included.\nSticky Note3\nOpenRouter API key creation instructions and node configuration details.\nSticky Note1, OpenRouter node credential setup\nOpenAI API key creation instructions for voice transcription.\nSticky Note20, Transcribe node credential setup\nThis node helps your agent remember the last few messages to stay on topic.\nSticky Note15, Window Buffer Memory node\nThis node allows your agent create and get tasks from Google Tasks.\nSticky Note16, Google Tasks nodes\nThis node allows your agent access your Gmail.\nSticky Note18, Gmail Tool node\nThis node allows your agent access your Google calendar.\nSticky Note19, Google Calendar node\nVideo tutorial for setup and usage:\nhttps://youtu.be/ROgf5dVqYPQ\nSticky Note2\nAI Automation Engineering Community for support and learning:\nhttps://www.skool.com/ai-automation-engineering-3014\nSticky Note3\nDisclaimer:\nThe text provided originates exclusively from an automated workflow created using n8n, a workflow automation tool. The processing strictly complies with current content policies and contains no illegal, offensive, or protected elements. All handled data is legal and public.\nCopied to clipboard\n\n",
      "category": "CRM",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Derek Cheung",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/personal-life-manager-with-telegram-google-services-voice-enabled-ai-8237",
      "nodes_count": 24
    },
    {
      "id": "008",
      "slug": "automatisez-la-slection-des-candidats-avec-mistral-ocr-et-gemini-ai-cv-analysis",
      "title_en": "Automate Candidate Screening with Mistral OCR & Gemini AI CV Analysis",
      "title_fr": "Automatisez la s√©lection des candidats avec Mistral OCR et Gemini AI CV Analysis",
      "description_short_en": "Automate hiring with an AI-powered CV scanner. Collect, analyze, and score applications in Google Sheets for faster, smarter candidate selection. Learn more!",
      "description_short_fr": "Automatisez le recrutement avec un scanner de CV aliment√© par l'IA. Collectez, analysez et notez les candidatures dans Google Sheets pour une s√©lection de candidats plus rapide et plus intelligente. Apprendre encore plus!",
      "description_full_en": "Automate Candidate Screening with Mistral OCR & Gemini AI CV Analysis\n1. Workflow Overview\nThis n8n workflow automates candidate screening by integrating form submissions, OCR text extraction, AI-powered CV evaluation, and data storage in Google Sheets. It targets recruitment teams aiming to streamline the initial hiring pipeline by automatically extracting text from uploaded CV PDFs, analyzing candidate qualifications against a specific job profile, and logging structured results for easy review and follow-up.\nThe workflow is logically divided into the following blocks:\n1.1 Input Reception:\nCaptures candidate application data and CV file via a customizable web form.\n1.2 Text Extraction:\nUses Mistral OCR to extract text content from the submitted CV PDF.\n1.3 AI Processing:\nEmploys Google Gemini AI to analyze extracted CV text against defined job requirements and outputs a qualification score with explanation.\n1.4 Data Logging and Update:\nLogs candidate basic info immediately on form submission, then updates the Google Sheet with AI analysis results after evaluation.\n1.5 Initialization and Setup:\nCreates and configures the Google Sheets spreadsheet with appropriate columns before processing begins.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nThis block collects candidate information and CV uploads via a secure, stylized web form. It triggers the workflow upon submission.\nNodes Involved:\nApplication Form (Form Trigger)\nNode Details:\nApplication Form\nType: Form Trigger\nRole: Receives candidate data (Full Name, Email) and CV PDF file upload from users.\nConfiguration:\nWebhook path set for unique form access.\nCustom dark theme CSS for styling.\nFields: Full Name (required), Email (required), Upload CV (PDF, required).\nResponse mode configured to return last node‚Äôs output.\nInputs: External HTTP form submission\nOutputs: Emits JSON with form data and binary file data (CV PDF)\nEdge Cases:\nForm submission without required fields will be blocked by UI validation.\nFile upload type restriction (.pdf) enforced to avoid incompatible inputs.\nSticky Note Reference:\n\"üí° Later, activate this workflow and share the public form URL to let candidates share their CV!\"\nIntegration Issues:\nRequires public webhook exposure and proper SSL configuration for secure form usage.\n2.2 Text Extraction\nOverview:\nExtracts textual content from the uploaded CV PDF using Mistral OCR service for accurate downstream AI analysis.\nNodes Involved:\nExtract CV Text (Mistral AI Node)\nLog Candidate Submission (Google Sheets Append)\nNode Details:\nExtract CV Text\nType: Mistral AI OCR Node\nRole: Converts binary PDF data into raw text from candidate CVs.\nConfiguration:\nBinary property configured dynamically to the uploaded file from the form node.\nUses Mistral Cloud API credentials for authentication.\nInputs: Binary PDF from Application Form node\nOutputs: JSON with extracted text of CV\nVersion Requirements: Mistral API key setup required\nEdge Cases:\nOCR failure due to unsupported file format or corrupted PDF.\nAPI timeout or rate limiting may cause extraction errors.\nSticky Note Reference:\n\"This uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF).\"\n\"\nGet your Mistral API key here\n\"\nLog Candidate Submission\nType: Google Sheets ‚Äî Append Operation\nRole: Immediately logs candidate‚Äôs Full Name and Email upon form submission to ensure data persistence even if later steps fail.\nConfiguration:\nAppends to the \"CVs\" Google Sheet on sheet \"gid=0\".\nMaps FullName and Email from form JSON to sheet columns.\nUses OAuth2 credentials for Google Sheets access.\nInputs: JSON data from Application Form\nOutputs: Confirmation of append operation\nEdge Cases:\nGoogle Sheets API quota or permission issues.\nNetwork errors causing failure to log data promptly.\nSticky Note Reference:\n\"Adds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\"\n2.3 AI Processing\nOverview:\nAnalyzes the extracted CV text against predefined job requirements for a Senior Frontend Developer role using Google Gemini AI, producing a structured qualification score and explanation.\nNodes Involved:\nGemini 2.5 Flash Lite (Google Gemini AI Node)\nJSON Output Parser (LangChain Structured Output Parser)\nAI Qualification (LangChain LLM Chain)\nNode Details:\nGemini 2.5 Flash Lite\nType: LangChain Google Gemini Chat Model Node\nRole: Executes the AI language model prompt to evaluate CV content.\nConfiguration:\nModel set to \"models/gemini-2.5-flash-lite\".\nTemperature parameter set to 0.4 for balanced creativity and determinism.\nUses Google Palm API OAuth credentials.\nInputs: Text extracted from CV node output\nOutputs: Raw AI response (text)\nEdge Cases:\nAPI key invalid or quota exceeded.\nModel downtime or connectivity issues.\nSticky Note Reference:\n\"1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\"\n\"2. Open the\nConnect Gemini\nnode: select credential, create new, then paste API key and save.\"\nJSON Output Parser\nType: LangChain Output Parser (Structured)\nRole: Enforces structured JSON schema on AI output to ensure consistent data format (\nqualificationRate\n,\nexplanation\n).\nConfiguration:\nManual schema defines required numeric and string fields without additional properties.\nInputs: Raw AI text from Gemini node\nOutputs: Validated and parsed JSON object for downstream use\nEdge Cases:\nAI output not conforming to schema causing parse errors.\nSchema mismatch if AI prompt changes.\nAI Qualification\nType: LangChain LLM Chain Node\nRole: Implements the full AI prompt chain combining role instructions, job requirements context, evaluation criteria, and output format.\nConfiguration:\nPrompt includes detailed Senior Frontend Developer job description, core & preferred requirements, evaluation logic, and output JSON format.\nHas output parser linked to JSON Output Parser node for structured results.\nInputs: Parsed extracted CV text\nOutputs: JSON object with candidate qualification data\nEdge Cases:\nPrompt formatting errors or truncation.\nAI model response delays or failures.\nSticky Note Reference:\n\"Adapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\"\n2.4 Data Logging and Update\nOverview:\nUpdates the existing Google Sheet entry for the candidate with their AI qualification results, linking by email for record integrity.\nNodes Involved:\nAdd CV Analysis (Google Sheets Update)\nNode Details:\nAdd CV Analysis\nType: Google Sheets ‚Äî Update Operation\nRole: Updates candidate row in \"CVs\" sheet matching by Email with AI-generated qualification score and explanation text.\nConfiguration:\nMatches rows by Email column.\nUpdates QualificationRate and QualificationDescription columns with AI data.\nUses OAuth2 credentials.\nInputs: JSON output from AI Qualification and original form data for email\nOutputs: Confirmation of update operation\nEdge Cases:\nNo matching email row found causing update failure.\nGoogle Sheets API permission or quota issues.\nSticky Note Reference:\n\"Check your Google Sheets! You now have the analysis of the candidate.\"\n2.5 Initialization and Setup\nOverview:\nSets up a new Google Sheets spreadsheet titled \"CVs\" with necessary columns to store candidate information and analysis results.\nNodes Involved:\nCreate 'CVs' Spreadsheet\nSticky Notes (multiple for instructions and workflow goal)\nNode Details:\nCreate 'CVs' Spreadsheet\nType: Google Sheets ‚Äî Spreadsheet Creation\nRole: Initializes a new Google Sheet with columns: FullName, Email, QualificationRate, QualificationDescription.\nConfiguration:\nSpreadsheet title set to \"CVs\".\nSeparate sheets created for each column title (sheet names match column names).\nUses OAuth2 credentials.\nInputs: Manual trigger or workflow start\nOutputs: Spreadsheet ID and URL for access\nEdge Cases:\nGoogle API quota or permissions errors.\nSticky Note Reference:\n\"Initializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\"\nSticky Notes\nProvide workflow goals, instructions for credential setup, and user tips, such as sharing form URL and adapting prompts.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nStart Here\nManual Trigger\nWorkflow manual start trigger\n‚Äî\nCreate 'CVs' Spreadsheet\n¬© 2025 Lucas Peyrin\nCreate 'CVs' Spreadsheet\nGoogle Sheets (Spreadsheet Create)\nInitializes candidate data spreadsheet\nStart Here\nApplication Form\nInitializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\nApplication Form\nForm Trigger\nCaptures candidate‚Äôs info and CV\nCreate 'CVs' Spreadsheet\nExtract CV Text, Log Candidate Submission\nüí° Later, activate this workflow and share the public form URL to let candidates share their CV!\nExtract CV Text\nMistral AI OCR\nExtracts text from candidate CV PDF\nApplication Form\nAI Qualification\nThis uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF). \\n**\nGet your Mistral API key here\n**\nLog Candidate Submission\nGoogle Sheets (Append)\nLogs candidate basic info immediately\nApplication Form\n‚Äî\nAdds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\nGemini 2.5 Flash Lite\nLangChain Google Gemini AI Model\nRuns AI model for CV analysis\nExtract CV Text\nAI Qualification\n1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\\n2. Open the\nConnect Gemini\nnode and paste API key.\nJSON Output Parser\nLangChain Output Parser (Structured)\nParses AI output into structured JSON\nGemini 2.5 Flash Lite\nAI Qualification\nEnsures the AI's response is perfectly structured as JSON (e.g.,\nqualificationRate\n,\nexplanation\n), making data reliable.\nAI Qualification\nLangChain LLM Chain\nEvaluates CV text against job criteria\nExtract CV Text, Gemini 2.5 Flash Lite, JSON Output Parser\nAdd CV Analysis\nAdapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\nAdd CV Analysis\nGoogle Sheets (Update)\nUpdates candidate row with AI analysis\nAI Qualification\n‚Äî\nCheck your Google Sheets! You now have the analysis of the candidate.\nSticky Note - Workflow Goal1\nSticky Note\nDescribes workflow purpose and usage\n‚Äî\n‚Äî\n## Automated CV Scanner\\nThis workflow automates your hiring pipeline: 1. Collects applications via form, 2. Extracts CV text, 3. Analyzes CV with AI, 4. Stores results in Google Sheets.\nSticky Note - Create Spreadsheet1\nSticky Note\nNotes about spreadsheet setup\n‚Äî\n‚Äî\nInitializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\nSticky Note - Append Row1\nSticky Note\nNotes about logging candidate info\n‚Äî\n‚Äî\nAdds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\nSticky Note - Extract Text1\nSticky Note\nNotes about Mistral OCR usage\n‚Äî\n‚Äî\nThis uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF).\nSticky Note - LLM Chain1\nSticky Note\nNotes about prompt adaptation\n‚Äî\n‚Äî\nAdapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\nSticky Note - Output Parser1\nSticky Note\nNotes about output parsing\n‚Äî\n‚Äî\nEnsures the AI's response is perfectly structured as JSON (e.g.,\nqualificationRate\n,\nexplanation\n), making the data reliable.\nSticky Note - Update Row1\nSticky Note\nNotes about final Google Sheets update\n‚Äî\n‚Äî\nCheck your Google Sheets! You now have the analysis of the candidate.\nSticky Note12\nSticky Note\nReminds to activate workflow and share form\n‚Äî\n‚Äî\nüí° Later, activate this workflow and share the public form URL to let candidates share their CV!\nSticky Note\nSticky Note\nInstructions for Gemini AI API key setup\n‚Äî\n‚Äî\n1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\\n2. Open the\nConnect Gemini\nnode: select credential, create new, paste API key and save.\n4. Reproducing the Workflow from Scratch\nCreate Manual Trigger Node\nName: \"Start Here\"\nPurpose: Manual workflow start for initialization.\nCreate Google Sheets Node to Initialize Spreadsheet\nName: \"Create 'CVs' Spreadsheet\"\nType: Google Sheets ‚Äî Create Spreadsheet\nParameters:\nTitle: \"CVs\"\nSheets: Create columns as separate sheets titled \"FullName\", \"Email\", \"QualificationRate\", \"QualificationDescription\"\nCredentials: OAuth2 Google Sheets with proper permission for creating spreadsheets.\nConnect \"Start Here\" node output to this node input.\nCreate Form Trigger Node\nName: \"Application Form\"\nType: Form Trigger\nParameters:\nWebhook path: unique path for public access\nForm fields:\nFull Name (required, text)\nEmail (required, text)\nUpload CV (required, file, accept only .pdf)\nCustom CSS: Use provided dark professional theme CSS for UI\nSubmit button label: \"Submit Application\"\nForm description: \"Please fill out the form below and upload your CV to apply.\"\nConnect output of \"Create 'CVs' Spreadsheet\" node to this node.\nCreate Mistral OCR Node\nName: \"Extract CV Text\"\nType: Mistral AI\nParameters:\nBinary Property: dynamically set to the uploaded CV file from \"Application Form\" node, using expression\n={{ $('Application Form').last().binary.keys()[0] }}\nCredentials: Mistral Cloud API key (register and obtain from\nhttps://console.mistral.ai/api-keys\n)\nConnect output of \"Application Form\" to this node.\nCreate Google Sheets Append Node\nName: \"Log Candidate Submission\"\nType: Google Sheets ‚Äî Append\nParameters:\nDocument ID: ID of the \"CVs\" spreadsheet created previously\nSheet Name: \"gid=0\" (default first sheet)\nColumns to append: FullName mapped from\n{{$json[\"Full Name\"]}}\n, Email mapped from\n{{$json.Email}}\nCredentials: OAuth2 Google Sheets\nConnect output of \"Application Form\" to this node (parallel with \"Extract CV Text\").\nCreate Google Gemini AI Node\nName: \"Gemini 2.5 Flash Lite\"\nType: LangChain Google Gemini Chat Model\nParameters:\nModel: \"models/gemini-2.5-flash-lite\"\nTemperature: 0.4\nCredentials: Google Palm API (create API key at\nhttps://aistudio.google.com/app/apikey\n, then configure credential in n8n)\nConnect output of \"Extract CV Text\" node to this node.\nCreate LangChain Output Parser Node\nName: \"JSON Output Parser\"\nType: LangChain Output Parser (Structured)\nParameters:\nSchema type: manual\nInput schema:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"qualificationRate\": { \"type\": \"number\" },\n    \"explanation\": { \"type\": \"string\" }\n  },\n  \"required\": [\"qualificationRate\", \"explanation\"],\n  \"additionalProperties\": false\n}\nConnect output of \"Gemini 2.5 Flash Lite\" node to this node (as AI output parser).\nCreate LangChain LLM Chain Node\nName: \"AI Qualification\"\nType: LangChain Chain LLM\nParameters:\nText: Full AI prompt including:\nGoal: Evaluate CV against Senior Frontend Developer job requirements\nContext: Job description detailing core and preferred qualifications\nEvaluation Logic: Scoring rules and explanation requirements\nOutput format: Strict JSON object with\nqualificationRate\nand\nexplanation\nHas output parser: enabled, linked to \"JSON Output Parser\"\nConnect output of \"Extract CV Text\" node (for CV text input) and connect AI model and output parser nodes appropriately as inputs for chain processing.\nCreate Google Sheets Update Node\nName: \"Add CV Analysis\"\nType: Google Sheets ‚Äî Update\nParameters:\nDocument ID: Same \"CVs\" spreadsheet ID\nSheet Name: \"gid=0\"\nMatching column: Email\nColumns to update:\nQualificationRate: mapped from\n{{$json.output.qualificationRate}}\nfrom AI Qualification output\nQualificationDescription: mapped from\n{{$json.output.explanation}}\nCredentials: OAuth2 Google Sheets\nConnect output of \"AI Qualification\" node to this node.\nValidate connections:\nApplication Form ‚Üí Extract CV Text ‚Üí Gemini 2.5 Flash Lite ‚Üí JSON Output Parser ‚Üí AI Qualification ‚Üí Add CV Analysis\nApplication Form ‚Üí Log Candidate Submission (parallel branch)\nStart Here ‚Üí Create 'CVs' Spreadsheet ‚Üí Application Form\nCredential Setup:\nGoogle Sheets OAuth2: Required for all Google Sheets nodes.\nMistral API Key: For OCR node.\nGoogle Palm API Key: For Gemini AI node.\nOptional:\nAdd Sticky Notes to document each step and provide instructions on credential setup, workflow goals, and usage tips for maintainability.\n5. General Notes & Resources\nNote Content\nContext or Link\nWorkflow automates hiring pipeline: collects applications, extracts CV text via OCR, analyzes with AI, and stores structured results in Google Sheets for easy review.\nWorkflow Goal Sticky Note\nMistral OCR provides high-quality text extraction from PDFs. Requires API key setup at\nhttps://console.mistral.ai/api-keys\n.\nhttps://mistral.ai/fr/news/mistral-ocr\nand\nhttps://console.mistral.ai/api-keys\nGoogle Gemini AI model (Gemini 2.5 Flash Lite) requires API key from Google AI Studio (\nhttps://aistudio.google.com/app/apikey\n).\nhttps://aistudio.google.com/app/apikey\nSuggested to adapt AI prompt‚Äôs job requirements to match the specific position and evaluation criteria you need.\nSticky note on LLM Chain node\nThe form uses a modern dark theme with CSS for enhanced user experience; customization is possible as needed.\nApplication Form node CSS settings\nFor feedback or custom workflow development, contact via unified AI-powered form:\nhttps://api.ia2s.app/form/templates/academy\nWorkflow Goal Sticky Note\nDisclaimer:\nThe provided content is derived solely from an automated n8n workflow. It fully complies with current content policies and contains no illegal, offensive, or protected elements. All processed data is legal and public.\nCopied to clipboard",
      "description_full_fr": "Automate Candidate Screening with Mistral OCR & Gemini AI CV Analysis\n1. Workflow Overview\nThis n8n workflow automates candidate screening by integrating form submissions, OCR text extraction, AI-powered CV evaluation, and data storage in Google Sheets. It targets recruitment teams aiming to streamline the initial hiring pipeline by automatically extracting text from uploaded CV PDFs, analyzing candidate qualifications against a specific job profile, and logging structured results for easy review and follow-up.\nThe workflow is logically divided into the following blocks:\n1.1 Input Reception:\nCaptures candidate application data and CV file via a customizable web form.\n1.2 Text Extraction:\nUses Mistral OCR to extract text content from the submitted CV PDF.\n1.3 AI Processing:\nEmploys Google Gemini AI to analyze extracted CV text against defined job requirements and outputs a qualification score with explanation.\n1.4 Data Logging and Update:\nLogs candidate basic info immediately on form submission, then updates the Google Sheet with AI analysis results after evaluation.\n1.5 Initialization and Setup:\nCreates and configures the Google Sheets spreadsheet with appropriate columns before processing begins.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nThis block collects candidate information and CV uploads via a secure, stylized web form. It triggers the workflow upon submission.\nNodes Involved:\nApplication Form (Form Trigger)\nNode Details:\nApplication Form\nType: Form Trigger\nRole: Receives candidate data (Full Name, Email) and CV PDF file upload from users.\nConfiguration:\nWebhook path set for unique form access.\nCustom dark theme CSS for styling.\nFields: Full Name (required), Email (required), Upload CV (PDF, required).\nResponse mode configured to return last node‚Äôs output.\nInputs: External HTTP form submission\nOutputs: Emits JSON with form data and binary file data (CV PDF)\nEdge Cases:\nForm submission without required fields will be blocked by UI validation.\nFile upload type restriction (.pdf) enforced to avoid incompatible inputs.\nSticky Note Reference:\n\"üí° Later, activate this workflow and share the public form URL to let candidates share their CV!\"\nIntegration Issues:\nRequires public webhook exposure and proper SSL configuration for secure form usage.\n2.2 Text Extraction\nOverview:\nExtracts textual content from the uploaded CV PDF using Mistral OCR service for accurate downstream AI analysis.\nNodes Involved:\nExtract CV Text (Mistral AI Node)\nLog Candidate Submission (Google Sheets Append)\nNode Details:\nExtract CV Text\nType: Mistral AI OCR Node\nRole: Converts binary PDF data into raw text from candidate CVs.\nConfiguration:\nBinary property configured dynamically to the uploaded file from the form node.\nUses Mistral Cloud API credentials for authentication.\nInputs: Binary PDF from Application Form node\nOutputs: JSON with extracted text of CV\nVersion Requirements: Mistral API key setup required\nEdge Cases:\nOCR failure due to unsupported file format or corrupted PDF.\nAPI timeout or rate limiting may cause extraction errors.\nSticky Note Reference:\n\"This uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF).\"\n\"\nGet your Mistral API key here\n\"\nLog Candidate Submission\nType: Google Sheets ‚Äî Append Operation\nRole: Immediately logs candidate‚Äôs Full Name and Email upon form submission to ensure data persistence even if later steps fail.\nConfiguration:\nAppends to the \"CVs\" Google Sheet on sheet \"gid=0\".\nMaps FullName and Email from form JSON to sheet columns.\nUses OAuth2 credentials for Google Sheets access.\nInputs: JSON data from Application Form\nOutputs: Confirmation of append operation\nEdge Cases:\nGoogle Sheets API quota or permission issues.\nNetwork errors causing failure to log data promptly.\nSticky Note Reference:\n\"Adds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\"\n2.3 AI Processing\nOverview:\nAnalyzes the extracted CV text against predefined job requirements for a Senior Frontend Developer role using Google Gemini AI, producing a structured qualification score and explanation.\nNodes Involved:\nGemini 2.5 Flash Lite (Google Gemini AI Node)\nJSON Output Parser (LangChain Structured Output Parser)\nAI Qualification (LangChain LLM Chain)\nNode Details:\nGemini 2.5 Flash Lite\nType: LangChain Google Gemini Chat Model Node\nRole: Executes the AI language model prompt to evaluate CV content.\nConfiguration:\nModel set to \"models/gemini-2.5-flash-lite\".\nTemperature parameter set to 0.4 for balanced creativity and determinism.\nUses Google Palm API OAuth credentials.\nInputs: Text extracted from CV node output\nOutputs: Raw AI response (text)\nEdge Cases:\nAPI key invalid or quota exceeded.\nModel downtime or connectivity issues.\nSticky Note Reference:\n\"1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\"\n\"2. Open the\nConnect Gemini\nnode: select credential, create new, then paste API key and save.\"\nJSON Output Parser\nType: LangChain Output Parser (Structured)\nRole: Enforces structured JSON schema on AI output to ensure consistent data format (\nqualificationRate\n,\nexplanation\n).\nConfiguration:\nManual schema defines required numeric and string fields without additional properties.\nInputs: Raw AI text from Gemini node\nOutputs: Validated and parsed JSON object for downstream use\nEdge Cases:\nAI output not conforming to schema causing parse errors.\nSchema mismatch if AI prompt changes.\nAI Qualification\nType: LangChain LLM Chain Node\nRole: Implements the full AI prompt chain combining role instructions, job requirements context, evaluation criteria, and output format.\nConfiguration:\nPrompt includes detailed Senior Frontend Developer job description, core & preferred requirements, evaluation logic, and output JSON format.\nHas output parser linked to JSON Output Parser node for structured results.\nInputs: Parsed extracted CV text\nOutputs: JSON object with candidate qualification data\nEdge Cases:\nPrompt formatting errors or truncation.\nAI model response delays or failures.\nSticky Note Reference:\n\"Adapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\"\n2.4 Data Logging and Update\nOverview:\nUpdates the existing Google Sheet entry for the candidate with their AI qualification results, linking by email for record integrity.\nNodes Involved:\nAdd CV Analysis (Google Sheets Update)\nNode Details:\nAdd CV Analysis\nType: Google Sheets ‚Äî Update Operation\nRole: Updates candidate row in \"CVs\" sheet matching by Email with AI-generated qualification score and explanation text.\nConfiguration:\nMatches rows by Email column.\nUpdates QualificationRate and QualificationDescription columns with AI data.\nUses OAuth2 credentials.\nInputs: JSON output from AI Qualification and original form data for email\nOutputs: Confirmation of update operation\nEdge Cases:\nNo matching email row found causing update failure.\nGoogle Sheets API permission or quota issues.\nSticky Note Reference:\n\"Check your Google Sheets! You now have the analysis of the candidate.\"\n2.5 Initialization and Setup\nOverview:\nSets up a new Google Sheets spreadsheet titled \"CVs\" with necessary columns to store candidate information and analysis results.\nNodes Involved:\nCreate 'CVs' Spreadsheet\nSticky Notes (multiple for instructions and workflow goal)\nNode Details:\nCreate 'CVs' Spreadsheet\nType: Google Sheets ‚Äî Spreadsheet Creation\nRole: Initializes a new Google Sheet with columns: FullName, Email, QualificationRate, QualificationDescription.\nConfiguration:\nSpreadsheet title set to \"CVs\".\nSeparate sheets created for each column title (sheet names match column names).\nUses OAuth2 credentials.\nInputs: Manual trigger or workflow start\nOutputs: Spreadsheet ID and URL for access\nEdge Cases:\nGoogle API quota or permissions errors.\nSticky Note Reference:\n\"Initializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\"\nSticky Notes\nProvide workflow goals, instructions for credential setup, and user tips, such as sharing form URL and adapting prompts.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nStart Here\nManual Trigger\nWorkflow manual start trigger\n‚Äî\nCreate 'CVs' Spreadsheet\n¬© 2025 Lucas Peyrin\nCreate 'CVs' Spreadsheet\nGoogle Sheets (Spreadsheet Create)\nInitializes candidate data spreadsheet\nStart Here\nApplication Form\nInitializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\nApplication Form\nForm Trigger\nCaptures candidate‚Äôs info and CV\nCreate 'CVs' Spreadsheet\nExtract CV Text, Log Candidate Submission\nüí° Later, activate this workflow and share the public form URL to let candidates share their CV!\nExtract CV Text\nMistral AI OCR\nExtracts text from candidate CV PDF\nApplication Form\nAI Qualification\nThis uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF). \\n**\nGet your Mistral API key here\n**\nLog Candidate Submission\nGoogle Sheets (Append)\nLogs candidate basic info immediately\nApplication Form\n‚Äî\nAdds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\nGemini 2.5 Flash Lite\nLangChain Google Gemini AI Model\nRuns AI model for CV analysis\nExtract CV Text\nAI Qualification\n1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\\n2. Open the\nConnect Gemini\nnode and paste API key.\nJSON Output Parser\nLangChain Output Parser (Structured)\nParses AI output into structured JSON\nGemini 2.5 Flash Lite\nAI Qualification\nEnsures the AI's response is perfectly structured as JSON (e.g.,\nqualificationRate\n,\nexplanation\n), making data reliable.\nAI Qualification\nLangChain LLM Chain\nEvaluates CV text against job criteria\nExtract CV Text, Gemini 2.5 Flash Lite, JSON Output Parser\nAdd CV Analysis\nAdapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\nAdd CV Analysis\nGoogle Sheets (Update)\nUpdates candidate row with AI analysis\nAI Qualification\n‚Äî\nCheck your Google Sheets! You now have the analysis of the candidate.\nSticky Note - Workflow Goal1\nSticky Note\nDescribes workflow purpose and usage\n‚Äî\n‚Äî\n## Automated CV Scanner\\nThis workflow automates your hiring pipeline: 1. Collects applications via form, 2. Extracts CV text, 3. Analyzes CV with AI, 4. Stores results in Google Sheets.\nSticky Note - Create Spreadsheet1\nSticky Note\nNotes about spreadsheet setup\n‚Äî\n‚Äî\nInitializes a new Google Sheet with columns for applicant data. Can be replaced with Airtable, Notion, etc.\nSticky Note - Append Row1\nSticky Note\nNotes about logging candidate info\n‚Äî\n‚Äî\nAdds the applicant's name and email to the Google Sheet right after they submit the form to have it logged even if the workflow fails.\nSticky Note - Extract Text1\nSticky Note\nNotes about Mistral OCR usage\n‚Äî\n‚Äî\nThis uses\nMistral OCR\n, it extracts the text perfectly from a candidate's CV (PDF).\nSticky Note - LLM Chain1\nSticky Note\nNotes about prompt adaptation\n‚Äî\n‚Äî\nAdapt the\njob requirements\nin the prompt to\nyour position & criteria\n.\nSticky Note - Output Parser1\nSticky Note\nNotes about output parsing\n‚Äî\n‚Äî\nEnsures the AI's response is perfectly structured as JSON (e.g.,\nqualificationRate\n,\nexplanation\n), making the data reliable.\nSticky Note - Update Row1\nSticky Note\nNotes about final Google Sheets update\n‚Äî\n‚Äî\nCheck your Google Sheets! You now have the analysis of the candidate.\nSticky Note12\nSticky Note\nReminds to activate workflow and share form\n‚Äî\n‚Äî\nüí° Later, activate this workflow and share the public form URL to let candidates share their CV!\nSticky Note\nSticky Note\nInstructions for Gemini AI API key setup\n‚Äî\n‚Äî\n1.\nIn Google AI Studio\nclick\n‚ÄúCreate API key in new project‚Äù\nand copy it.\\n2. Open the\nConnect Gemini\nnode: select credential, create new, paste API key and save.\n4. Reproducing the Workflow from Scratch\nCreate Manual Trigger Node\nName: \"Start Here\"\nPurpose: Manual workflow start for initialization.\nCreate Google Sheets Node to Initialize Spreadsheet\nName: \"Create 'CVs' Spreadsheet\"\nType: Google Sheets ‚Äî Create Spreadsheet\nParameters:\nTitle: \"CVs\"\nSheets: Create columns as separate sheets titled \"FullName\", \"Email\", \"QualificationRate\", \"QualificationDescription\"\nCredentials: OAuth2 Google Sheets with proper permission for creating spreadsheets.\nConnect \"Start Here\" node output to this node input.\nCreate Form Trigger Node\nName: \"Application Form\"\nType: Form Trigger\nParameters:\nWebhook path: unique path for public access\nForm fields:\nFull Name (required, text)\nEmail (required, text)\nUpload CV (required, file, accept only .pdf)\nCustom CSS: Use provided dark professional theme CSS for UI\nSubmit button label: \"Submit Application\"\nForm description: \"Please fill out the form below and upload your CV to apply.\"\nConnect output of \"Create 'CVs' Spreadsheet\" node to this node.\nCreate Mistral OCR Node\nName: \"Extract CV Text\"\nType: Mistral AI\nParameters:\nBinary Property: dynamically set to the uploaded CV file from \"Application Form\" node, using expression\n={{ $('Application Form').last().binary.keys()[0] }}\nCredentials: Mistral Cloud API key (register and obtain from\nhttps://console.mistral.ai/api-keys\n)\nConnect output of \"Application Form\" to this node.\nCreate Google Sheets Append Node\nName: \"Log Candidate Submission\"\nType: Google Sheets ‚Äî Append\nParameters:\nDocument ID: ID of the \"CVs\" spreadsheet created previously\nSheet Name: \"gid=0\" (default first sheet)\nColumns to append: FullName mapped from\n{{$json[\"Full Name\"]}}\n, Email mapped from\n{{$json.Email}}\nCredentials: OAuth2 Google Sheets\nConnect output of \"Application Form\" to this node (parallel with \"Extract CV Text\").\nCreate Google Gemini AI Node\nName: \"Gemini 2.5 Flash Lite\"\nType: LangChain Google Gemini Chat Model\nParameters:\nModel: \"models/gemini-2.5-flash-lite\"\nTemperature: 0.4\nCredentials: Google Palm API (create API key at\nhttps://aistudio.google.com/app/apikey\n, then configure credential in n8n)\nConnect output of \"Extract CV Text\" node to this node.\nCreate LangChain Output Parser Node\nName: \"JSON Output Parser\"\nType: LangChain Output Parser (Structured)\nParameters:\nSchema type: manual\nInput schema:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"qualificationRate\": { \"type\": \"number\" },\n    \"explanation\": { \"type\": \"string\" }\n  },\n  \"required\": [\"qualificationRate\", \"explanation\"],\n  \"additionalProperties\": false\n}\nConnect output of \"Gemini 2.5 Flash Lite\" node to this node (as AI output parser).\nCreate LangChain LLM Chain Node\nName: \"AI Qualification\"\nType: LangChain Chain LLM\nParameters:\nText: Full AI prompt including:\nGoal: Evaluate CV against Senior Frontend Developer job requirements\nContext: Job description detailing core and preferred qualifications\nEvaluation Logic: Scoring rules and explanation requirements\nOutput format: Strict JSON object with\nqualificationRate\nand\nexplanation\nHas output parser: enabled, linked to \"JSON Output Parser\"\nConnect output of \"Extract CV Text\" node (for CV text input) and connect AI model and output parser nodes appropriately as inputs for chain processing.\nCreate Google Sheets Update Node\nName: \"Add CV Analysis\"\nType: Google Sheets ‚Äî Update\nParameters:\nDocument ID: Same \"CVs\" spreadsheet ID\nSheet Name: \"gid=0\"\nMatching column: Email\nColumns to update:\nQualificationRate: mapped from\n{{$json.output.qualificationRate}}\nfrom AI Qualification output\nQualificationDescription: mapped from\n{{$json.output.explanation}}\nCredentials: OAuth2 Google Sheets\nConnect output of \"AI Qualification\" node to this node.\nValidate connections:\nApplication Form ‚Üí Extract CV Text ‚Üí Gemini 2.5 Flash Lite ‚Üí JSON Output Parser ‚Üí AI Qualification ‚Üí Add CV Analysis\nApplication Form ‚Üí Log Candidate Submission (parallel branch)\nStart Here ‚Üí Create 'CVs' Spreadsheet ‚Üí Application Form\nCredential Setup:\nGoogle Sheets OAuth2: Required for all Google Sheets nodes.\nMistral API Key: For OCR node.\nGoogle Palm API Key: For Gemini AI node.\nOptional:\nAdd Sticky Notes to document each step and provide instructions on credential setup, workflow goals, and usage tips for maintainability.\n5. General Notes & Resources\nNote Content\nContext or Link\nWorkflow automates hiring pipeline: collects applications, extracts CV text via OCR, analyzes with AI, and stores structured results in Google Sheets for easy review.\nWorkflow Goal Sticky Note\nMistral OCR provides high-quality text extraction from PDFs. Requires API key setup at\nhttps://console.mistral.ai/api-keys\n.\nhttps://mistral.ai/fr/news/mistral-ocr\nand\nhttps://console.mistral.ai/api-keys\nGoogle Gemini AI model (Gemini 2.5 Flash Lite) requires API key from Google AI Studio (\nhttps://aistudio.google.com/app/apikey\n).\nhttps://aistudio.google.com/app/apikey\nSuggested to adapt AI prompt‚Äôs job requirements to match the specific position and evaluation criteria you need.\nSticky note on LLM Chain node\nThe form uses a modern dark theme with CSS for enhanced user experience; customization is possible as needed.\nApplication Form node CSS settings\nFor feedback or custom workflow development, contact via unified AI-powered form:\nhttps://api.ia2s.app/form/templates/academy\nWorkflow Goal Sticky Note\nDisclaimer:\nThe provided content is derived solely from an automated n8n workflow. It fully complies with current content policies and contains no illegal, offensive, or protected elements. All processed data is legal and public.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Lucas Peyrin",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/automate-candidate-screening-with-mistral-ocr-gemini-ai-cv-analysis-7456",
      "nodes_count": 18
    },
    {
      "id": "009",
      "slug": "parlez-vos-feuilles-google-laide-de-chatgpt-5",
      "title_en": "Talk to Your Google Sheets Using ChatGPT-5",
      "title_fr": "Parlez √† vos feuilles Google √† l'aide de ChatGPT-5",
      "description_short_en": "Transform Google Sheets into an AI-powered chatbot with GPT-5 Mini for instant data analysis, smart insights, and seamless natural language conversation.",
      "description_short_fr": "Transformez Google Sheets en un chatbot aliment√© par l'IA avec GPT-5 Mini pour une analyse instantan√©e des donn√©es, des informations intelligentes et une conversation fluide en langage naturel.",
      "description_full_en": "Talk to Your Google Sheets Using ChatGPT-5\n1. Workflow Overview\nThis workflow titled\n\"Talk to Your Google Sheets Using ChatGPT-5\"\nenables intelligent, natural language querying of marketing data stored in Google Sheets via an AI-powered chatbot interface. It leverages OpenAI's GPT-5 Mini model (represented here as \"gpt-4.1-nano\") to interpret user questions and provide precise data-driven answers by querying a single Google Sheet dataset.\nThe workflow is logically structured into the following blocks:\n1.1 Input Reception:\nCaptures user queries via a chat trigger.\n1.2 AI Conversational Memory:\nMaintains contextual memory of the conversation.\n1.3 AI Processing Agent:\nThe core LangChain agent that orchestrates the AI language model and data tool to answer questions.\n1.4 Data Access Tool:\nFetches and analyzes data from a specified Google Sheet.\n1.5 Auxiliary Documentation:\nSticky notes providing setup instructions, usage guidelines, and tutorial links.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nReceives chat input from users to trigger the workflow.\nNodes Involved:\nChat with Your Data\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.chatTrigger\nRole: Listens for incoming chat messages to start the AI conversation.\nConfiguration: Default settings with a webhook ID (\nedca0f0a-77c3-43e5-8ece-e514a29446f5\n).\nConnections:\nOutputs to the\nTalk to Your Data\nnode.\nEdge Cases:\nPossible webhook connectivity issues.\nRate limiting or message format errors.\nVersion: 1.3\n2.2 AI Conversational Memory\nOverview:\nMaintains a buffer memory window to provide context for ongoing conversations.\nNodes Involved:\nMemory\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nRole: Stores recent conversation history allowing the AI to remember prior exchanges.\nConfiguration: Uses default buffer window (no custom parameters).\nConnections:\nMemory output connected back as\nai_memory\ninput to the\nTalk to Your Data\nagent.\nEdge Cases:\nMemory overflow or loss of context if conversation is too long.\nVersion: 1.3\n2.3 AI Processing Agent\nOverview:\nActs as the orchestrator AI agent that uses the OpenAI model and the Google Sheets tool to answer user queries.\nNodes Involved:\nTalk to Your Data\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.agent\nRole: Main AI agent combining language understanding with data access.\nConfiguration:\nSystem message instructs agent to answer questions\nonly using Google Sheets data\n, emphasizing precision and conservatism.\nOutput parser enabled to format AI responses properly.\nConnections:\nReceives input from\nChat with Your Data\n.\nSends language model input to\nOpenAI Chat Model\n.\nSends tool input to\nAnalyze Data\n(Google Sheets).\nReceives memory input from\nMemory\n.\nEdge Cases:\nMisinterpretation if system prompt is ignored.\nFailures if Google Sheets API or OpenAI API fails.\nVersion: 2.2\n2.4 Data Access Tool\nOverview:\nConnects and retrieves data from a specific Google Sheets document and sheet.\nNodes Involved:\nAnalyze Data\nNode Details:\nType:\nn8n-nodes-base.googleSheetsTool\nRole: Queries the designated Google Sheets dataset to provide data for analysis.\nConfiguration:\nSpreadsheet ID:\n1UDWt0-Z9fHqwnSNfU3vvhSoYCFG6EG3E-ZewJC_CLq4\nSheet name: The sheet with ID\n365710158\ntitled \"Data\".\nUses OAuth2 credentials implicitly for access.\nConnections:\nProvides tool output to\nTalk to Your Data\n.\nEdge Cases:\nOAuth token expiration or permission errors.\nData format changes breaking queries.\nVersion: 4.7\n2.5 Auxiliary Documentation\nOverview:\nProvides user-facing documentation, setup instructions, and tutorial links through sticky notes.\nNodes Involved:\nSticky Note2\n,\nSticky Note7\n,\nSticky Note8\n,\nSticky Note9\n,\nSticky Note10\n,\nSticky Note\nNode Details:\nType:\nn8n-nodes-base.stickyNote\nRole: Contains detailed instructions on setup, usage scenarios, and external resources.\nContent Highlights:\nOverview of the workflow purpose.\nStepwise setup for OpenAI API key and Google Sheets.\nExample questions users can ask.\nEmbedded tutorial video (\nYouTube: qsrVPdo6svc\n)\nContact and LinkedIn information for support.\nConnections: None (standalone informational nodes).\nEdge Cases:\nStale or broken external links.\nVersion: 1\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nChat with Your Data\n@n8n/n8n-nodes-langchain.chatTrigger\nReceives user chat input\n‚Äî\nTalk to Your Data\nMemory\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nMaintains conversation memory\n‚Äî\nTalk to Your Data (ai_memory)\nTalk to Your Data\n@n8n/n8n-nodes-langchain.agent\nOrchestrates AI language model and tool\nChat with Your Data, Memory, OpenAI Chat Model, Analyze Data\n‚Äî\nOpenAI Chat Model\n@n8n/n8n-nodes-langchain.lmChatOpenAi\nProvides GPT-5 Mini language model\nTalk to Your Data\nTalk to Your Data\nAnalyze Data\nn8n-nodes-base.googleSheetsTool\nQueries Google Sheets data\nTalk to Your Data\nTalk to Your Data\nSticky Note2\nn8n-nodes-base.stickyNote\nWorkflow overview and purpose\n‚Äî\n‚Äî\n## Talk to Your Data with Google Sheets & OpenAI GPT-5 Mini - Intelligent data analysis chatbot\nSticky Note7\nn8n-nodes-base.stickyNote\nExample questions users can ask\n‚Äî\n‚Äî\n### 3. Ask Questions of Your Data - Examples of natural language queries\nSticky Note8\nn8n-nodes-base.stickyNote\nSetup instructions + tutorial link\n‚Äî\n‚Äî\n## üé• Watch This Tutorial - Includes OpenAI and Google Sheets setup steps + video link\nSticky Note9\nn8n-nodes-base.stickyNote\nOpenAI API key setup\n‚Äî\n‚Äî\n### 1. Set Up OpenAI Connection - Steps to get API key and billing setup\nSticky Note10\nn8n-nodes-base.stickyNote\nGoogle Sheets data preparation\n‚Äî\n‚Äî\n### 2. Prepare Your Google Sheet - Format and OAuth login instructions\nSticky Note\nn8n-nodes-base.stickyNote\nEmpty (placeholder or UI spacing)\n‚Äî\n‚Äî\n4. Reproducing the Workflow from Scratch\nCreate Chat Trigger Node\nAdd node:\n@n8n/n8n-nodes-langchain.chatTrigger\nName:\nChat with Your Data\nConfigure webhook ID (auto-generated or custom).\nNo additional parameters needed.\nAdd Memory Buffer Node\nAdd node:\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nName:\nMemory\nUse default configuration (no parameters).\nConnect output to\nTalk to Your Data\nunder\nai_memory\ninput.\nAdd OpenAI Language Model Node\nAdd node:\n@n8n/n8n-nodes-langchain.lmChatOpenAi\nName:\nOpenAI Chat Model\nSet model to\ngpt-4.1-nano\n(represents GPT-5 Mini).\nConfigure OpenAI credentials with your API key.\nConnect output to\nTalk to Your Data\nunder\nai_languageModel\ninput.\nAdd Google Sheets Tool Node\nAdd node:\nn8n-nodes-base.googleSheetsTool\nName:\nAnalyze Data\nSet Spreadsheet ID to\n1UDWt0-Z9fHqwnSNfU3vvhSoYCFG6EG3E-ZewJC_CLq4\nSet Sheet Name to sheet ID\n365710158\n(\"Data\").\nAuthenticate with Google OAuth2 credentials.\nConnect output to\nTalk to Your Data\nunder\nai_tool\ninput.\nAdd LangChain Agent Node\nAdd node:\n@n8n/n8n-nodes-langchain.agent\nName:\nTalk to Your Data\nSet system message to:\nGoogle Sheets Ask-Data\n\nYou are Ask-Data. Answer questions using Google Sheets ONLY via the tool below. Be precise and conservative.\n\nThere is only one dataset. don't ask what dataset it is.\n\nUse the data tool to answer the question.\nEnable output parser.\nConnect inputs:\nmain\nfrom\nChat with Your Data\nai_languageModel\nfrom\nOpenAI Chat Model\nai_tool\nfrom\nAnalyze Data\nai_memory\nfrom\nMemory\n(Optional) Add Sticky Notes for Documentation\nCreate several\nn8n-nodes-base.stickyNote\nnodes.\nAdd content describing setup instructions, usage examples, and tutorial links as in the original workflow.\nValidate all connections and credentials\nEnsure Google OAuth2 credentials have access to the specified spreadsheet.\nEnsure OpenAI API key is valid and has billing enabled.\nTest the webhook by sending sample chat queries to trigger the workflow.\n5. General Notes & Resources\nNote Content\nContext or Link\nüé• Watch the tutorial video on YouTube for a step-by-step guide:\nhttps://youtu.be/qsrVPdo6svc\nTutorial video linked in Sticky Note8\nOpenAI API Keys and Billing setup instructions:\nhttps://platform.openai.com/api-keys\n,\nhttps://platform.openai.com/settings/organization/billing/overview\nSetup instructions in Sticky Note8 and Sticky Note9\nSample marketing data spreadsheet format reference:\nGoogle Sheet\nData format guidance in Sticky Note8 and Sticky Note10\nContact for support or customization inquiries:\n[email¬†protected]\n, LinkedIn:\nhttps://www.linkedin.com/in/robert-breen-29429625/\nProvided in Sticky Note8\nDisclaimer:\nThe provided text and workflow are generated and processed exclusively with n8n, an integration and automation tool. This treatment strictly complies with content policies and contains no illegal, offensive, or protected elements. All data handled is legal and publicly available.\nCopied to clipboard",
      "description_full_fr": "Talk to Your Google Sheets Using ChatGPT-5\n1. Workflow Overview\nThis workflow titled\n\"Talk to Your Google Sheets Using ChatGPT-5\"\nenables intelligent, natural language querying of marketing data stored in Google Sheets via an AI-powered chatbot interface. It leverages OpenAI's GPT-5 Mini model (represented here as \"gpt-4.1-nano\") to interpret user questions and provide precise data-driven answers by querying a single Google Sheet dataset.\nThe workflow is logically structured into the following blocks:\n1.1 Input Reception:\nCaptures user queries via a chat trigger.\n1.2 AI Conversational Memory:\nMaintains contextual memory of the conversation.\n1.3 AI Processing Agent:\nThe core LangChain agent that orchestrates the AI language model and data tool to answer questions.\n1.4 Data Access Tool:\nFetches and analyzes data from a specified Google Sheet.\n1.5 Auxiliary Documentation:\nSticky notes providing setup instructions, usage guidelines, and tutorial links.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nReceives chat input from users to trigger the workflow.\nNodes Involved:\nChat with Your Data\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.chatTrigger\nRole: Listens for incoming chat messages to start the AI conversation.\nConfiguration: Default settings with a webhook ID (\nedca0f0a-77c3-43e5-8ece-e514a29446f5\n).\nConnections:\nOutputs to the\nTalk to Your Data\nnode.\nEdge Cases:\nPossible webhook connectivity issues.\nRate limiting or message format errors.\nVersion: 1.3\n2.2 AI Conversational Memory\nOverview:\nMaintains a buffer memory window to provide context for ongoing conversations.\nNodes Involved:\nMemory\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nRole: Stores recent conversation history allowing the AI to remember prior exchanges.\nConfiguration: Uses default buffer window (no custom parameters).\nConnections:\nMemory output connected back as\nai_memory\ninput to the\nTalk to Your Data\nagent.\nEdge Cases:\nMemory overflow or loss of context if conversation is too long.\nVersion: 1.3\n2.3 AI Processing Agent\nOverview:\nActs as the orchestrator AI agent that uses the OpenAI model and the Google Sheets tool to answer user queries.\nNodes Involved:\nTalk to Your Data\nNode Details:\nType:\n@n8n/n8n-nodes-langchain.agent\nRole: Main AI agent combining language understanding with data access.\nConfiguration:\nSystem message instructs agent to answer questions\nonly using Google Sheets data\n, emphasizing precision and conservatism.\nOutput parser enabled to format AI responses properly.\nConnections:\nReceives input from\nChat with Your Data\n.\nSends language model input to\nOpenAI Chat Model\n.\nSends tool input to\nAnalyze Data\n(Google Sheets).\nReceives memory input from\nMemory\n.\nEdge Cases:\nMisinterpretation if system prompt is ignored.\nFailures if Google Sheets API or OpenAI API fails.\nVersion: 2.2\n2.4 Data Access Tool\nOverview:\nConnects and retrieves data from a specific Google Sheets document and sheet.\nNodes Involved:\nAnalyze Data\nNode Details:\nType:\nn8n-nodes-base.googleSheetsTool\nRole: Queries the designated Google Sheets dataset to provide data for analysis.\nConfiguration:\nSpreadsheet ID:\n1UDWt0-Z9fHqwnSNfU3vvhSoYCFG6EG3E-ZewJC_CLq4\nSheet name: The sheet with ID\n365710158\ntitled \"Data\".\nUses OAuth2 credentials implicitly for access.\nConnections:\nProvides tool output to\nTalk to Your Data\n.\nEdge Cases:\nOAuth token expiration or permission errors.\nData format changes breaking queries.\nVersion: 4.7\n2.5 Auxiliary Documentation\nOverview:\nProvides user-facing documentation, setup instructions, and tutorial links through sticky notes.\nNodes Involved:\nSticky Note2\n,\nSticky Note7\n,\nSticky Note8\n,\nSticky Note9\n,\nSticky Note10\n,\nSticky Note\nNode Details:\nType:\nn8n-nodes-base.stickyNote\nRole: Contains detailed instructions on setup, usage scenarios, and external resources.\nContent Highlights:\nOverview of the workflow purpose.\nStepwise setup for OpenAI API key and Google Sheets.\nExample questions users can ask.\nEmbedded tutorial video (\nYouTube: qsrVPdo6svc\n)\nContact and LinkedIn information for support.\nConnections: None (standalone informational nodes).\nEdge Cases:\nStale or broken external links.\nVersion: 1\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nChat with Your Data\n@n8n/n8n-nodes-langchain.chatTrigger\nReceives user chat input\n‚Äî\nTalk to Your Data\nMemory\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nMaintains conversation memory\n‚Äî\nTalk to Your Data (ai_memory)\nTalk to Your Data\n@n8n/n8n-nodes-langchain.agent\nOrchestrates AI language model and tool\nChat with Your Data, Memory, OpenAI Chat Model, Analyze Data\n‚Äî\nOpenAI Chat Model\n@n8n/n8n-nodes-langchain.lmChatOpenAi\nProvides GPT-5 Mini language model\nTalk to Your Data\nTalk to Your Data\nAnalyze Data\nn8n-nodes-base.googleSheetsTool\nQueries Google Sheets data\nTalk to Your Data\nTalk to Your Data\nSticky Note2\nn8n-nodes-base.stickyNote\nWorkflow overview and purpose\n‚Äî\n‚Äî\n## Talk to Your Data with Google Sheets & OpenAI GPT-5 Mini - Intelligent data analysis chatbot\nSticky Note7\nn8n-nodes-base.stickyNote\nExample questions users can ask\n‚Äî\n‚Äî\n### 3. Ask Questions of Your Data - Examples of natural language queries\nSticky Note8\nn8n-nodes-base.stickyNote\nSetup instructions + tutorial link\n‚Äî\n‚Äî\n## üé• Watch This Tutorial - Includes OpenAI and Google Sheets setup steps + video link\nSticky Note9\nn8n-nodes-base.stickyNote\nOpenAI API key setup\n‚Äî\n‚Äî\n### 1. Set Up OpenAI Connection - Steps to get API key and billing setup\nSticky Note10\nn8n-nodes-base.stickyNote\nGoogle Sheets data preparation\n‚Äî\n‚Äî\n### 2. Prepare Your Google Sheet - Format and OAuth login instructions\nSticky Note\nn8n-nodes-base.stickyNote\nEmpty (placeholder or UI spacing)\n‚Äî\n‚Äî\n4. Reproducing the Workflow from Scratch\nCreate Chat Trigger Node\nAdd node:\n@n8n/n8n-nodes-langchain.chatTrigger\nName:\nChat with Your Data\nConfigure webhook ID (auto-generated or custom).\nNo additional parameters needed.\nAdd Memory Buffer Node\nAdd node:\n@n8n/n8n-nodes-langchain.memoryBufferWindow\nName:\nMemory\nUse default configuration (no parameters).\nConnect output to\nTalk to Your Data\nunder\nai_memory\ninput.\nAdd OpenAI Language Model Node\nAdd node:\n@n8n/n8n-nodes-langchain.lmChatOpenAi\nName:\nOpenAI Chat Model\nSet model to\ngpt-4.1-nano\n(represents GPT-5 Mini).\nConfigure OpenAI credentials with your API key.\nConnect output to\nTalk to Your Data\nunder\nai_languageModel\ninput.\nAdd Google Sheets Tool Node\nAdd node:\nn8n-nodes-base.googleSheetsTool\nName:\nAnalyze Data\nSet Spreadsheet ID to\n1UDWt0-Z9fHqwnSNfU3vvhSoYCFG6EG3E-ZewJC_CLq4\nSet Sheet Name to sheet ID\n365710158\n(\"Data\").\nAuthenticate with Google OAuth2 credentials.\nConnect output to\nTalk to Your Data\nunder\nai_tool\ninput.\nAdd LangChain Agent Node\nAdd node:\n@n8n/n8n-nodes-langchain.agent\nName:\nTalk to Your Data\nSet system message to:\nGoogle Sheets Ask-Data\n\n\n\nVous √™tes Ask-Data. R√©pondez aux questions en utilisant Google Sheets UNIQUEMENT via l'outil ci-dessous. Soyez pr√©cis et conservateur.\n\nIl n'existe qu'un seul ensemble de donn√©es. ne demandez pas de quel ensemble de donn√©es il s'agit.\n\nUtilisez l‚Äôoutil de donn√©es pour r√©pondre √† la question.\nActiver l'analyseur de sortie.\nConnectez les entr√©es¬†:\nprincipal\nde\nDiscutez avec vos donn√©es\nai_langueMod√®le\nde\nMod√®le de discussion OpenAI\nai_tool\nde\nAnalyser les donn√©es\nai_m√©moire\nde\nM√©moire\n(Facultatif) Ajouter des notes autocollantes pour la documentation\nCr√©ez plusieurs\nn8n-nodes-base.stickyNote\nn≈ìuds.\nAjoutez du contenu d√©crivant les instructions de configuration, des exemples d'utilisation et des liens de didacticiel comme dans le flux de travail d'origine.\nValider toutes les connexions et informations d'identification\nAssurez-vous que les informations d'identification Google OAuth2 ont acc√®s √† la feuille de calcul sp√©cifi√©e.\nAssurez-vous que la cl√© API OpenAI est valide et que la facturation est activ√©e.\nTestez le webhook en envoyant des exemples de requ√™tes de chat pour d√©clencher le flux de travail.\n5. Notes g√©n√©rales et ressources\nContenu de la note\nContexte ou lien\nüé• Regardez la vid√©o du didacticiel sur YouTube pour un guide √©tape par √©tape¬†:\nhttps://youtu.be/qsrVPdo6svc\nVid√©o du didacticiel li√©e dans Sticky Note8\nCl√©s API OpenAI et instructions de configuration de la facturation¬†:\nhttps://platform.openai.com/api-keys\n,\nhttps://platform.openai.com/settings/organization/billing/overview\nInstructions de configuration dans Sticky Note8 et Sticky Note9\nExemple de r√©f√©rence de format de feuille de calcul de donn√©es marketing¬†:\nFeuille Google\nConseils sur le format des donn√©es dans Sticky Note8 et Sticky Note10\nContact pour les demandes d‚Äôassistance ou de personnalisation¬†:\n[e-mail prot√©g√©]\n, LinkedIn¬†:\nhttps://www.linkedin.com/in/robert-breen-29429625/\nFourni dans Sticky Note8\nAvertissement¬†:\nLe texte et le flux de travail fournis sont g√©n√©r√©s et trait√©s exclusivement avec n8n, un outil d'int√©gration et d'automatisation. Ce traitement est strictement conforme aux politiques de contenu et ne contient aucun √©l√©ment ill√©gal, offensant ou prot√©g√©. Toutes les donn√©es trait√©es sont l√©gales et accessibles au public.\nCopi√© dans le presse-papiers",
      "category": "AI",
      "complexity": "Intermediate",
      "tags_en": [],
      "tags_fr": [],
      "author": "Robert Breen",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/talk-to-your-google-sheets-using-chatgpt-5-7639",
      "nodes_count": 11
    },
    {
      "id": "010",
      "slug": "gnration-automatise-de-leads-et-envoi-de-mails-froid-avec-apify-ai-et-gmail",
      "title_en": "Automated Lead Generation & Cold Emailing with Apify, AI & Gmail",
      "title_fr": "G√©n√©ration automatis√©e de leads et envoi d'e-mails √† froid avec Apify, AI et Gmail",
      "description_short_en": "Automate lead generation for agencies‚Äîfind business prospects, extract contacts, and send AI-crafted emails from one form. Discover smarter outreach!",
      "description_short_fr": "Automatisez la g√©n√©ration de leads pour les agences¬†: trouvez des prospects commerciaux, extrayez des contacts et envoyez des e-mails cr√©√©s par l'IA √† partir d'un seul formulaire. D√©couvrez une sensibilisation plus intelligente¬†!",
      "description_full_en": "Automated Lead Generation & Cold Emailing with Apify, AI & Gmail\n1. Workflow Overview\nThis workflow automates lead generation and cold emailing by integrating form input, web data scraping, AI-powered email content creation, and email dispatch via Gmail. It is designed for digital marketing agencies or sales teams aiming to streamline outreach to potential clients based on specified business types and locations.\nThe workflow is logically grouped into the following functional blocks:\n1.1 Input Reception:\nCaptures user input about the target business type, location, lead quantity, and email style through a web form.\n1.2 Lead Data Acquisition:\nSends a request to an Apify actor to scrape business leads based on the form input.\n1.3 Lead Filtering and Storage:\nFilters leads with valid websites and appends them to a Google Sheet for record-keeping.\n1.4 Email Address Extraction:\nUses Google Gemini AI to extract the best email address from each lead‚Äôs website.\n1.5 Email Generation:\nUtilizes OpenAI GPT-4 to generate personalized cold email subject lines and bodies based on lead details and selected email style.\n1.6 Email Sending and Logging:\nSends the generated emails via Gmail, waits between sends to avoid spam detection, and updates the Google Sheet with email send status and timestamp.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nCaptures form inputs specifying the lead search criteria: business type, location, number of leads, and preferred email style.\nNodes Involved:\nOn form submission\nSticky Note (\"# Business Data\")\nNode Details:\nOn form submission\nType:\nformTrigger\n(Webhook trigger node)\nConfiguration: Custom form titled \"Lead Machine\" with required fields: Business Type (text), Location (text), Lead Number (numeric), and Email Style (dropdown with Friendly, Professional, Simple)\nInput: User HTTP POST submission\nOutput: JSON containing form values\nEdge Cases: Missing required fields block submission; malformed input possible if form validation fails.\nSticky Note\nProvides a visual label for the block; no functional role.\n2.2 Lead Data Acquisition\nOverview:\nSends an HTTP POST request to an Apify actor endpoint that scrapes leads based on input criteria, returning business data.\nNodes Involved:\nHTTP Request\nNode Details:\nHTTP Request\nType: HTTP Request node\nConfiguration:\nURL: Dynamic, replaced with\nApify_Actor_Endpoint_URL\nenvironment/credential variable\nMethod: POST\nBody: JSON containing parameters such as location, business type (searchStringsArray), max leads, and scraping options (mostly false except\nscrapeReviewsPersonalData\n)\nInput: JSON from form submission node\nOutput: JSON array with business leads data, including website, address, category, title, and phone number\nEdge Cases: Network errors, invalid Apify endpoint URL, or empty response if no leads found.\n2.3 Lead Filtering and Storage\nOverview:\nFilters leads to only those containing a website URL and appends these filtered leads to a Google Sheet.\nNodes Involved:\nFilter\nAppend row in sheet\nSticky Note (\"# Getting the Email Address\")\nNode Details:\nFilter\nType: Filter node\nConfiguration: Checks if the\nwebsite\nproperty exists and is non-empty in the lead data.\nInput: Leads array from HTTP Request\nOutput: Leads with valid websites (true branch), or discarded leads (false branch)\nEdge Cases: Leads without websites are ignored; expression errors if\nwebsite\nfield missing or malformed.\nAppend row in sheet\nType: Google Sheets node\nConfiguration: Appends lead details (Address, Website, Category, Company Name, Email Address (initially empty), Phone Number) to Sheet1 of a specified Google Sheet document ID.\nInput: Filtered lead data\nOutput: Confirmation of append operation\nCredentials: Google Sheets OAuth2 configured externally\nEdge Cases: Sheet access permission errors, API quota limits, or malformed data mapping.\nSticky Note\nLabels the processing block for clarity.\n2.4 Email Address Extraction\nOverview:\nFor each lead with a website, uses Google Gemini AI to scrape and extract the best email address from the website content.\nNodes Involved:\nLoop Over Items\nInformation Extractor (Google Gemini Chat Model)\nIf (valid email address check)\nNode Details:\nLoop Over Items\nType: SplitInBatches\nConfiguration: Iterates over each lead row appended to Google Sheets\nEdge Cases: Large lead counts may require batch size tuning to avoid timeouts.\nInformation Extractor\nType: LangChain Information Extractor with Google Gemini Chat Model\nConfiguration: Extracts a single, ideally formatted \"Email Address\" attribute from the website field JSON.\nInput: Lead website string\nOutput: JSON with extracted \"Email Address\"\nCredentials: Google Gemini API key required\nEdge Cases: Failure to find an email, malformed website URLs, API quota or connectivity issues.\nIf\nType: Conditional node\nConfiguration: Passes only leads where extracted email contains \"@\" symbol to next step; otherwise ends flow for that lead.\nEdge Cases: False positives or invalid emails may proceed; no email leads skipped.\n2.5 Email Generation\nOverview:\nGenerates personalized cold email subject and body using OpenAI GPT-4 based on lead details and chosen email style.\nNodes Involved:\nWait\nInformation Extractor1 (OpenAI Chat Model)\nEdit Fields1\nNode Details:\nWait\nType: Wait node\nConfiguration: 1-second delay between email generation for rate limiting and API pacing.\nEdge Cases: Minimal risk, but long runs may accumulate delay.\nInformation Extractor1\nType: LangChain Information Extractor with OpenAI Chat Model (GPT-4 mini)\nConfiguration:\nInput prompt includes company name, business type, and email style from form input.\nInstructions specify tone, greeting format, plural pronouns, professional and concise style, and signature format.\nOutputs required: \"Mail Subject\" and \"Mail Body\" (cold email content).\nCredentials: OpenAI API key required\nEdge Cases: Model errors, API limits, or unexpected prompt results.\nEdit Fields1\nType: Set node\nConfiguration: Adds current send time (formatted) and email address to the data object for logging.\nEdge Cases: Time formatting errors unlikely.\n2.6 Email Sending and Logging\nOverview:\nSends the generated cold email via Gmail and updates the Google Sheet with send time and status.\nNodes Involved:\nSend a message (Gmail)\nAppend or update row in sheet\nNo Operation, do nothing\nSticky Notes (\"# Email Send\" and setup guide notes)\nNode Details:\nSend a message\nType: Gmail node\nConfiguration:\nSends email to the extracted email address\nUses subject and message body from the OpenAI-generated content\nEmail format: plain text\nRetry on error: no; max 2 tries\nCredentials: Gmail OAuth2 configured externally\nEdge Cases: Gmail API limits, invalid email addresses, or send failures; node set to continue on error.\nAppend or update row in sheet\nType: Google Sheets node\nConfiguration: Updates the lead‚Äôs row by matching on \"Email Address\" with status \"‚úÖ\" and current \"SEND Time\" in the sheet.\nEdge Cases: Sheet update conflicts or access errors.\nNo Operation, do nothing\nType: NoOp node\nRole: Ends flow for leads without valid emails; no action taken.\nSticky Notes\nVisual guides for email sending section and setup instructions including links and tutorial video.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nOn form submission\nformTrigger\nCapture user input from lead form\n-\nHTTP Request\n# Business Data\nHTTP Request\nhttpRequest\nScrape lead data from Apify actor\nOn form submission\nFilter\nFilter\nfilter\nFilter leads that have websites\nHTTP Request\nAppend row in sheet, NoOp\nAppend row in sheet\ngoogleSheets\nStore filtered leads in Google Sheet\nFilter\nLoop Over Items\n# Getting the Email Address\nLoop Over Items\nsplitInBatches\nIterate over stored leads\nAppend row in sheet\nWait, (empty branch)\n# Getting the Email Address\nWait\nwait\nDelay between email generations\nLoop Over Items\nInformation Extractor1\n# Email Send\nInformation Extractor\nlangchain.informationExtractor (Google Gemini)\nExtract email address from website\nFilter\nIf\n# Getting the Email Address\nIf\nif\nCheck if extracted email is valid\nInformation Extractor\nAppend row in sheet, NoOp\nInformation Extractor1\nlangchain.informationExtractor (OpenAI GPT-4)\nGenerate cold email subject and body\nWait\nEdit Fields1\n# Email Send\nEdit Fields1\nset\nAdd send time and email address info\nInformation Extractor1\nSend a message\n# Email Send\nSend a message\ngmail\nSend cold email via Gmail\nEdit Fields1\nAppend or update row in sheet\n# Email Send\nAppend or update row in sheet\ngoogleSheets\nUpdate lead status and timestamp\nSend a message\nLoop Over Items\n# Email Send\nNo Operation, do nothing\nnoOp\nEnd flow for leads without valid email\nFilter, If\n-\nGoogle Gemini Chat Model\nlangchain.lmChatGoogleGemini\nAI model for email extraction\nInformation Extractor\nInformation Extractor\nOpenAI Chat Model\nlangchain.lmChatOpenAi\nAI model for cold email generation\nInformation Extractor1\nInformation Extractor1\nSticky Note\nstickyNote\nVisual notes for sections and guides\n-\n-\nMultiple sticky notes with setup guide and tutorial video links:\nhttps://youtu.be/3UwutV1x3mA\n4. Reproducing the Workflow from Scratch\nCreate Form Trigger Node\nType:\nformTrigger\nConfigure form titled \"Lead Machine\" with fields:\nBusiness Type (text, required)\nLocation (text, required)\nLead Number (number, required)\nEmail Style (dropdown: Friendly, Professional, Simple)\nSet button label to \"GO üöÄ\" and disable attribution.\nAdd HTTP Request Node\nConnect from Form Trigger\nMethod: POST\nURL: Set to your Apify actor endpoint URL (replace placeholder\nApify_Actor_Endpoint_URL\n)\nBody Type: JSON\nBody Content: Pass form data parameters dynamically:\nlocationQuery\n:\n{{ $json.Location }}\nmaxCrawledPlacesPerSearch\n:\n{{ $json['Lead Number'] }}\nsearchStringsArray\n:\n[ \"{{ $json['Business Type'] }}\" ]\nOther scraping options set as per workflow.\nAdd Filter Node\nConnect from HTTP Request\nCondition: Check if\nwebsite\nfield exists and is non-empty (\nexists\n, strict, case-sensitive).\nTrue branch leads to Append row in sheet; False branch leads to No Operation.\nAdd Google Sheets Append Row Node\nConnect from Filter (true branch)\nDocument ID: Your target Google Sheet ID\nSheet Name: Sheet1 or your chosen sheet\nMap columns for company details (Company Name, Website, Phone Number, Address, Category) and empty Email Address field.\nAdd SplitInBatches Node (\"Loop Over Items\")\nConnect from Append row in sheet\nDefault batch size or configure as needed.\nAdd Wait Node\nConnect from Loop Over Items\nSet delay to 1 second.\nAdd Information Extractor Node (Google Gemini)\nConnect from Wait\nConfigure LangChain Information Extractor to extract \"Email Address\" from website text:\nInput:\nWebsite: {{ $json.website }}\nAttribute: \"Email Address\" required, description to find best formatted email address from website.\nAdd If Node\nConnect from Information Extractor (Google Gemini)\nCondition: Check if extracted \"Email Address\" contains \"@\"\nOn If True branch:\nConnect to Loop Over Items to continue processing\nConnect also to Information Extractor1 (OpenAI GPT-4 node)\nAdd Information Extractor1 Node (OpenAI GPT-4)\nConnect from Wait node (or from If true branch, depending on design)\nConfigure prompt with company data and email style to generate \"Mail Subject\" and \"Mail Body\".\nUse GPT-4 mini or equivalent model.\nAdd Set Node (Edit Fields1)\nConnect from Information Extractor1\nAdd fields:\nSend Time: current timestamp formatted as MM-dd-yyyy (h:mm a)\nEmail Address: from Wait node data\nAdd Gmail Send Node\nConnect from Edit Fields1\nConfigure to send email:\nTo:\n{{ $json['Email Address'] }}\nSubject:\n{{ $('Information Extractor1').item.json.output['Mail Subject'] }}\nMessage:\n{{ $('Information Extractor1').item.json.output['Mail Body'] }}\nEmail type: text\nSet max tries to 2; continue on error.\nAdd Google Sheets Append or Update Row Node\nConnect from Gmail Send Node\nConfigure to update lead row matching on \"Email Address\" with:\nCold Mail Status: \"‚úÖ\"\nSEND Time: from Edit Fields1 node\nAdd No Operation Node\nConnect from Filter false branch and If false branch to end flow for leads without website or valid email.\nSetup Credentials:\nGoogle Sheets OAuth2 with access to target sheet\nGmail OAuth2 with send mail permission\nOpenAI API key for GPT-4 usage\nGoogle Gemini API key for email extraction\nAdd Sticky Notes for Documentation:\nAdd visual sticky notes labeling blocks: Business Data, Getting the Email Address, Email Send, and Setup Guide with embedded tutorial video link:\nhttps://youtu.be/3UwutV1x3mA\n5. General Notes & Resources\nNote Content\nContext or Link\nVideo tutorial on creating this automated lead finder and cold email system with AI agents.\nhttps://youtu.be/3UwutV1x3mA\nSetup guide notes embedded in workflow explain how to configure Apify endpoint, Google Gemini, Google Sheets, OpenAI, and Gmail integration.\nWorkflow sticky notes\nWorkflow respects data privacy by selectively scraping publicly available business data and sending cold emails only after email address extraction and validity checks.\nWorkflow design principle\nGoogle Sheets columns required: Company Name, Category, Website, Phone Number, Email Address, Address, Cold Mail Status, SEND Time.\nGoogle Sheets configuration\nUse of AI models: Google Gemini for email extraction from website text; OpenAI GPT-4 for email content generation.\nNode details\nRetry and error handling: Gmail sending node retries twice and continues on failure; no operation nodes terminate flows cleanly for invalid data.\nNode configurations\nThis document enables clear understanding, modification, and manual recreation of the Automated Lead Generation & Cold Emailing workflow using n8n, supporting both human operators and integration automation tools.\nCopied to clipboard",
      "description_full_fr": "Automated Lead Generation & Cold Emailing with Apify, AI & Gmail\n1. Workflow Overview\nThis workflow automates lead generation and cold emailing by integrating form input, web data scraping, AI-powered email content creation, and email dispatch via Gmail. It is designed for digital marketing agencies or sales teams aiming to streamline outreach to potential clients based on specified business types and locations.\nThe workflow is logically grouped into the following functional blocks:\n1.1 Input Reception:\nCaptures user input about the target business type, location, lead quantity, and email style through a web form.\n1.2 Lead Data Acquisition:\nSends a request to an Apify actor to scrape business leads based on the form input.\n1.3 Lead Filtering and Storage:\nFilters leads with valid websites and appends them to a Google Sheet for record-keeping.\n1.4 Email Address Extraction:\nUses Google Gemini AI to extract the best email address from each lead‚Äôs website.\n1.5 Email Generation:\nUtilizes OpenAI GPT-4 to generate personalized cold email subject lines and bodies based on lead details and selected email style.\n1.6 Email Sending and Logging:\nSends the generated emails via Gmail, waits between sends to avoid spam detection, and updates the Google Sheet with email send status and timestamp.\n2. Block-by-Block Analysis\n2.1 Input Reception\nOverview:\nCaptures form inputs specifying the lead search criteria: business type, location, number of leads, and preferred email style.\nNodes Involved:\nOn form submission\nSticky Note (\"# Business Data\")\nNode Details:\nOn form submission\nType:\nformTrigger\n(Webhook trigger node)\nConfiguration: Custom form titled \"Lead Machine\" with required fields: Business Type (text), Location (text), Lead Number (numeric), and Email Style (dropdown with Friendly, Professional, Simple)\nInput: User HTTP POST submission\nOutput: JSON containing form values\nEdge Cases: Missing required fields block submission; malformed input possible if form validation fails.\nSticky Note\nProvides a visual label for the block; no functional role.\n2.2 Lead Data Acquisition\nOverview:\nSends an HTTP POST request to an Apify actor endpoint that scrapes leads based on input criteria, returning business data.\nNodes Involved:\nHTTP Request\nNode Details:\nHTTP Request\nType: HTTP Request node\nConfiguration:\nURL: Dynamic, replaced with\nApify_Actor_Endpoint_URL\nenvironment/credential variable\nMethod: POST\nBody: JSON containing parameters such as location, business type (searchStringsArray), max leads, and scraping options (mostly false except\nscrapeReviewsPersonalData\n)\nInput: JSON from form submission node\nOutput: JSON array with business leads data, including website, address, category, title, and phone number\nEdge Cases: Network errors, invalid Apify endpoint URL, or empty response if no leads found.\n2.3 Lead Filtering and Storage\nOverview:\nFilters leads to only those containing a website URL and appends these filtered leads to a Google Sheet.\nNodes Involved:\nFilter\nAppend row in sheet\nSticky Note (\"# Getting the Email Address\")\nNode Details:\nFilter\nType: Filter node\nConfiguration: Checks if the\nwebsite\nproperty exists and is non-empty in the lead data.\nInput: Leads array from HTTP Request\nOutput: Leads with valid websites (true branch), or discarded leads (false branch)\nEdge Cases: Leads without websites are ignored; expression errors if\nwebsite\nfield missing or malformed.\nAppend row in sheet\nType: Google Sheets node\nConfiguration: Appends lead details (Address, Website, Category, Company Name, Email Address (initially empty), Phone Number) to Sheet1 of a specified Google Sheet document ID.\nInput: Filtered lead data\nOutput: Confirmation of append operation\nCredentials: Google Sheets OAuth2 configured externally\nEdge Cases: Sheet access permission errors, API quota limits, or malformed data mapping.\nSticky Note\nLabels the processing block for clarity.\n2.4 Email Address Extraction\nOverview:\nFor each lead with a website, uses Google Gemini AI to scrape and extract the best email address from the website content.\nNodes Involved:\nLoop Over Items\nInformation Extractor (Google Gemini Chat Model)\nIf (valid email address check)\nNode Details:\nLoop Over Items\nType: SplitInBatches\nConfiguration: Iterates over each lead row appended to Google Sheets\nEdge Cases: Large lead counts may require batch size tuning to avoid timeouts.\nInformation Extractor\nType: LangChain Information Extractor with Google Gemini Chat Model\nConfiguration: Extracts a single, ideally formatted \"Email Address\" attribute from the website field JSON.\nInput: Lead website string\nOutput: JSON with extracted \"Email Address\"\nCredentials: Google Gemini API key required\nEdge Cases: Failure to find an email, malformed website URLs, API quota or connectivity issues.\nIf\nType: Conditional node\nConfiguration: Passes only leads where extracted email contains \"@\" symbol to next step; otherwise ends flow for that lead.\nEdge Cases: False positives or invalid emails may proceed; no email leads skipped.\n2.5 Email Generation\nOverview:\nGenerates personalized cold email subject and body using OpenAI GPT-4 based on lead details and chosen email style.\nNodes Involved:\nWait\nInformation Extractor1 (OpenAI Chat Model)\nEdit Fields1\nNode Details:\nWait\nType: Wait node\nConfiguration: 1-second delay between email generation for rate limiting and API pacing.\nEdge Cases: Minimal risk, but long runs may accumulate delay.\nInformation Extractor1\nType: LangChain Information Extractor with OpenAI Chat Model (GPT-4 mini)\nConfiguration:\nInput prompt includes company name, business type, and email style from form input.\nInstructions specify tone, greeting format, plural pronouns, professional and concise style, and signature format.\nOutputs required: \"Mail Subject\" and \"Mail Body\" (cold email content).\nCredentials: OpenAI API key required\nEdge Cases: Model errors, API limits, or unexpected prompt results.\nEdit Fields1\nType: Set node\nConfiguration: Adds current send time (formatted) and email address to the data object for logging.\nEdge Cases: Time formatting errors unlikely.\n2.6 Email Sending and Logging\nOverview:\nSends the generated cold email via Gmail and updates the Google Sheet with send time and status.\nNodes Involved:\nSend a message (Gmail)\nAppend or update row in sheet\nNo Operation, do nothing\nSticky Notes (\"# Email Send\" and setup guide notes)\nNode Details:\nSend a message\nType: Gmail node\nConfiguration:\nSends email to the extracted email address\nUses subject and message body from the OpenAI-generated content\nEmail format: plain text\nRetry on error: no; max 2 tries\nCredentials: Gmail OAuth2 configured externally\nEdge Cases: Gmail API limits, invalid email addresses, or send failures; node set to continue on error.\nAppend or update row in sheet\nType: Google Sheets node\nConfiguration: Updates the lead‚Äôs row by matching on \"Email Address\" with status \"‚úÖ\" and current \"SEND Time\" in the sheet.\nEdge Cases: Sheet update conflicts or access errors.\nNo Operation, do nothing\nType: NoOp node\nRole: Ends flow for leads without valid emails; no action taken.\nSticky Notes\nVisual guides for email sending section and setup instructions including links and tutorial video.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nOn form submission\nformTrigger\nCapture user input from lead form\n-\nHTTP Request\n# Business Data\nHTTP Request\nhttpRequest\nScrape lead data from Apify actor\nOn form submission\nFilter\nFilter\nfilter\nFilter leads that have websites\nHTTP Request\nAppend row in sheet, NoOp\nAppend row in sheet\ngoogleSheets\nStore filtered leads in Google Sheet\nFilter\nLoop Over Items\n# Getting the Email Address\nLoop Over Items\nsplitInBatches\nIterate over stored leads\nAppend row in sheet\nWait, (empty branch)\n# Getting the Email Address\nWait\nwait\nDelay between email generations\nLoop Over Items\nInformation Extractor1\n# Email Send\nInformation Extractor\nlangchain.informationExtractor (Google Gemini)\nExtract email address from website\nFilter\nIf\n# Getting the Email Address\nIf\nif\nCheck if extracted email is valid\nInformation Extractor\nAppend row in sheet, NoOp\nInformation Extractor1\nlangchain.informationExtractor (OpenAI GPT-4)\nGenerate cold email subject and body\nWait\nEdit Fields1\n# Email Send\nEdit Fields1\nset\nAdd send time and email address info\nInformation Extractor1\nSend a message\n# Email Send\nSend a message\ngmail\nSend cold email via Gmail\nEdit Fields1\nAppend or update row in sheet\n# Email Send\nAppend or update row in sheet\ngoogleSheets\nUpdate lead status and timestamp\nSend a message\nLoop Over Items\n# Email Send\nNo Operation, do nothing\nnoOp\nEnd flow for leads without valid email\nFilter, If\n-\nGoogle Gemini Chat Model\nlangchain.lmChatGoogleGemini\nAI model for email extraction\nInformation Extractor\nInformation Extractor\nOpenAI Chat Model\nlangchain.lmChatOpenAi\nAI model for cold email generation\nInformation Extractor1\nInformation Extractor1\nSticky Note\nstickyNote\nVisual notes for sections and guides\n-\n-\nMultiple sticky notes with setup guide and tutorial video links:\nhttps://youtu.be/3UwutV1x3mA\n4. Reproducing the Workflow from Scratch\nCreate Form Trigger Node\nType:\nformTrigger\nConfigure form titled \"Lead Machine\" with fields:\nBusiness Type (text, required)\nLocation (text, required)\nLead Number (number, required)\nEmail Style (dropdown: Friendly, Professional, Simple)\nSet button label to \"GO üöÄ\" and disable attribution.\nAdd HTTP Request Node\nConnect from Form Trigger\nMethod: POST\nURL: Set to your Apify actor endpoint URL (replace placeholder\nApify_Actor_Endpoint_URL\n)\nBody Type: JSON\nBody Content: Pass form data parameters dynamically:\nlocationQuery\n:\n{{ $json.Location }}\nmaxCrawledPlacesPerSearch\n:\n{{ $json['Lead Number'] }}\nsearchStringsArray\n:\n[ \"{{ $json['Business Type'] }}\" ]\nOther scraping options set as per workflow.\nAdd Filter Node\nConnect from HTTP Request\nCondition: Check if\nwebsite\nfield exists and is non-empty (\nexists\n, strict, case-sensitive).\nTrue branch leads to Append row in sheet; False branch leads to No Operation.\nAdd Google Sheets Append Row Node\nConnect from Filter (true branch)\nDocument ID: Your target Google Sheet ID\nSheet Name: Sheet1 or your chosen sheet\nMap columns for company details (Company Name, Website, Phone Number, Address, Category) and empty Email Address field.\nAdd SplitInBatches Node (\"Loop Over Items\")\nConnect from Append row in sheet\nDefault batch size or configure as needed.\nAdd Wait Node\nConnect from Loop Over Items\nSet delay to 1 second.\nAdd Information Extractor Node (Google Gemini)\nConnect from Wait\nConfigure LangChain Information Extractor to extract \"Email Address\" from website text:\nInput:\nWebsite: {{ $json.website }}\nAttribute: \"Email Address\" required, description to find best formatted email address from website.\nAdd If Node\nConnect from Information Extractor (Google Gemini)\nCondition: Check if extracted \"Email Address\" contains \"@\"\nOn If True branch:\nConnect to Loop Over Items to continue processing\nConnect also to Information Extractor1 (OpenAI GPT-4 node)\nAdd Information Extractor1 Node (OpenAI GPT-4)\nConnect from Wait node (or from If true branch, depending on design)\nConfigure prompt with company data and email style to generate \"Mail Subject\" and \"Mail Body\".\nUse GPT-4 mini or equivalent model.\nAdd Set Node (Edit Fields1)\nConnect from Information Extractor1\nAdd fields:\nSend Time: current timestamp formatted as MM-dd-yyyy (h:mm a)\nEmail Address: from Wait node data\nAdd Gmail Send Node\nConnect from Edit Fields1\nConfigure to send email:\nTo:\n{{ $json['Email Address'] }}\nSubject:\n{{ $('Information Extractor1').item.json.output['Mail Subject'] }}\nMessage:\n{{ $('Information Extractor1').item.json.output['Mail Body'] }}\nEmail type: text\nSet max tries to 2; continue on error.\nAdd Google Sheets Append or Update Row Node\nConnect from Gmail Send Node\nConfigure to update lead row matching on \"Email Address\" with:\nCold Mail Status: \"‚úÖ\"\nSEND Time: from Edit Fields1 node\nAdd No Operation Node\nConnect from Filter false branch and If false branch to end flow for leads without website or valid email.\nSetup Credentials:\nGoogle Sheets OAuth2 with access to target sheet\nGmail OAuth2 with send mail permission\nOpenAI API key for GPT-4 usage\nGoogle Gemini API key for email extraction\nAdd Sticky Notes for Documentation:\nAdd visual sticky notes labeling blocks: Business Data, Getting the Email Address, Email Send, and Setup Guide with embedded tutorial video link:\nhttps://youtu.be/3UwutV1x3mA\n5. General Notes & Resources\nNote Content\nContext or Link\nVideo tutorial on creating this automated lead finder and cold email system with AI agents.\nhttps://youtu.be/3UwutV1x3mA\nSetup guide notes embedded in workflow explain how to configure Apify endpoint, Google Gemini, Google Sheets, OpenAI, and Gmail integration.\nWorkflow sticky notes\nWorkflow respects data privacy by selectively scraping publicly available business data and sending cold emails only after email address extraction and validity checks.\nWorkflow design principle\nGoogle Sheets columns required: Company Name, Category, Website, Phone Number, Email Address, Address, Cold Mail Status, SEND Time.\nGoogle Sheets configuration\nUse of AI models: Google Gemini for email extraction from website text; OpenAI GPT-4 for email content generation.\nNode details\nRetry and error handling: Gmail sending node retries twice and continues on failure; no operation nodes terminate flows cleanly for invalid data.\nNode configurations\nThis document enables clear understanding, modification, and manual recreation of the Automated Lead Generation & Cold Emailing workflow using n8n, supporting both human operators and integration automation tools.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Rakin Jakaria",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/automated-lead-generation-cold-emailing-with-apify-ai-gmail-7423",
      "nodes_count": 20
    },
    {
      "id": "011",
      "slug": "jarvis-agent-dia-de-productivit-pour-les-tches-le-calendrier-les-e-mails-et-les-dpenses-laide-de-mcp",
      "title_en": "Jarvis: Productivity AI Agent for Tasks, Calendar, Email & Expense using MCPs",
      "title_fr": "Jarvis¬†: agent d'IA de productivit√© pour les t√¢ches, le calendrier, les e-mails et les d√©penses √† l'aide de MCP",
      "description_short_en": "Transform Telegram into an AI-powered assistant. Manage tasks, meetings, emails, and expenses in one hub. Easy setup‚Äîstreamline workflows today!",
      "description_short_fr": "Transformez Telegram en un assistant aliment√© par l'IA. G√©rez les t√¢ches, les r√©unions, les e-mails et les d√©penses dans un seul hub. Configuration facile¬†: rationalisez les flux de travail d√®s aujourd'hui¬†!",
      "description_full_en": "Jarvis: Productivity AI Agent for Tasks, Calendar, Email & Expense using MCPs\n1. Workflow Overview\nThis workflow, titled\nJarvis: Productivity AI Agent for Tasks, Calendar, Email & Expense using MCPs\n, is designed as a comprehensive AI-driven personal productivity assistant named \"Jarvis.\" It integrates multiple productivity domains including task management, calendar scheduling, email handling, contact management, and expense tracking. The workflow leverages n8n‚Äôs Langchain MCP (Model Context Protocol) tools, OpenAI GPT-4, Telegram as a user interface, and several Google services (Gmail, Calendar, Tasks, Contacts, Sheets) to provide a seamless and intelligent assistant experience.\nTarget Use Cases:\nManage daily tasks with Google Tasks: create, complete, delete, and retrieve tasks.\nHandle calendar events on Google Calendar: check availability, create, update, delete, and fetch events.\nManage emails via Gmail: send, reply, draft, label, and retrieve emails.\nTrack expenses with Google Sheets integration: add, retrieve, and delete expense records.\nAccess and retrieve Google Contacts for communication.\nProvide conversational AI assistance through Telegram, supporting both text and audio inputs with speech recognition and synthesis.\nLogical Blocks:\n1.1 Input Reception and User Authentication\nReceives user input from Telegram; filters authorized users; differentiates between text and audio input.\n1.2 AI Processing and Memory Management\nProcesses user input with Jarvis agent, backed by OpenAI GPT-4 and a simple memory buffer keyed by Telegram username.\n1.3 Email Management (Gmail MCP)\nFull Gmail integration for sending, replying, drafting, labeling, and searching emails, via MCP protocol.\n1.4 Calendar Management (Calendar MCP)\nGoogle Calendar operations: availability checks, event creation, retrieval, rescheduling, and deletion through MCP.\n1.5 Task Management (Google Tasks MCP)\nGoogle Tasks operations: create, get, update (complete), delete tasks managed via MCP.\n1.6 Finance Tracking (Finance Manager MCP)\nExpense tracking using Google Sheets to add, retrieve, and delete expense data.\n1.7 Contact Management (Google Contacts MCP)\nFetch and manage Google Contacts to facilitate communication.\n1.8 Audio Processing (Speech to Text and Text to Speech)\nHandles audio input transcription and audio response generation via ElevenLabs API.\n1.9 Output Delivery\nSends back text or audio responses to Telegram users.\n2. Block-by-Block Analysis\n1.1 Input Reception and User Authentication\nOverview:\nThis block receives user messages from Telegram, checks if the sender is authorized, and routes the input based on whether it's text or audio.\nNodes Involved:\nTelegram Trigger\nOnly allow me (Filter)\nSwitch (Check Text or Audio)\nSwitch (inside Only allow me for text/audio existence check)\nGet a file (for audio inputs)\nNode Details:\nTelegram Trigger\nType: Telegram Trigger\nRole: Entry point capturing all incoming Telegram messages (text/audio).\nConfiguration: Listens for \"message\" updates; uses Telegram Bot credentials.\nOutputs: Raw Telegram message JSON.\nFailure cases: Telegram API downtime, invalid webhook.\nOnly allow me (Filter)\nType: Filter\nRole: Authorizes only user with username \"jackman8\" to proceed.\nConfiguration: Checks if\nmessage.chat.username\nequals \"jackman8\".\nOutput: Routes authorized users to Switch node; blocks others.\nEdge cases: Unauthorized users get no response; consider adding rejection message.\nSwitch (Check Text or Audio)\nType: Switch\nRole: Differentiates between text and audio inputs by checking if\nmessage.text\nexists.\nConfiguration: Routes text messages to Jarvis AI, audio messages to \"Get a file\".\nEdge cases: Messages without text or audio might be dropped silently.\nGet a file\nType: Telegram Node\nRole: Retrieves the audio file from Telegram for transcription.\nConfiguration: Uses\nmessage.voice.file_id\nfrom Telegram message.\nOutput: Passes file data to transcription node.\nFailure: Missing or expired file IDs, Telegram file API errors.\n1.2 AI Processing and Memory Management\nOverview:\nUses a Langchain agent named Jarvis empowered by GPT-4, supported by a simple memory buffer that maintains session context per Telegram username.\nNodes Involved:\nSimple Memory\nOpenAI Chat Model\nJarvis (Langchain Agent)\nThink (Tool Think)\nSet Reply Message\nNode Details:\nSimple Memory\nType: Memory Buffer Window (Langchain)\nRole: Maintains conversation history keyed by Telegram username.\nConfiguration: Session key as username from Telegram message; custom session ID type.\nEdge cases: Memory overflow or reset, user switching.\nOpenAI Chat Model\nType: Langchain OpenAI Chat Model\nRole: Provides GPT-4.1-mini model for language generation.\nConfiguration: Model set to GPT-4.1-mini; credentials for OpenAI API provided.\nFailures: API key quota exceeded, rate limits, network errors.\nJarvis\nType: Langchain Agent\nRole: Main AI agent that interprets user requests, decides tool usage, and composes responses.\nConfiguration: System prompt defines Jarvis‚Äôs identity, capabilities, operational rules, and tone.\nUses memory and OpenAI Chat Model nodes.\nOnError: Continue regular output to avoid halting on errors.\nEdge cases: Incorrect or ambiguous inputs, missing parameters, API failures.\nThink\nType: Langchain Tool Think\nRole: Internal thinking step for the agent to process multi-tool decisions.\nConfiguration: Default.\nConnected to Jarvis for enhanced reasoning.\nSet Reply Message\nType: Set\nRole: Prepares the final text message output from Jarvis‚Äôs response or error messages.\nConfiguration: Assigns\nmessage\nfield from Jarvis output or error.\nOutputs: Feeds into output delivery nodes.\n1.3 Email Management (Gmail MCP)\nOverview:\nFull Gmail integration through MCP enables sending, replying, drafting, labeling, and fetching emails.\nNodes Involved:\nGmail MCP (MCP Client Tool)\nGmail MCP Server (MCP Trigger)\nSend Email\nReply to an Email\nDraft Email\nDraft Email Reply\nGet Emails\nAdd Label to Email\nGet Labels\nNode Details:\nGmail MCP Server\nType: MCP Trigger\nRole: Entry point for AI requests related to Gmail operations.\nConfiguration: Webhook with a unique path.\nEdge cases: Webhook downtime, invalid requests.\nGmail MCP\nType: MCP Client Tool\nRole: Client tool to communicate with Gmail MCP Server via SSE endpoint.\nConfiguration: Endpoint URL specified.\nUsed by Jarvis to perform email operations.\nSend Email\nType: Gmail Tool\nRole: Sends new emails.\nConfiguration: Uses AI-provided To, Subject, Message fields; disables attribution.\nCredentials: Gmail OAuth2.\nEdge cases: Invalid email addresses, quota exhaustion.\nReply to an Email\nType: Gmail Tool\nRole: Replies to existing emails with optional CC, BCC, attachments.\nConfiguration: Uses AI variables for message content, message ID, recipients.\nEdge cases: Missing message ID, attachment errors.\nDraft Email\nType: Gmail Tool\nRole: Creates email drafts with HTML content and recipients.\nConfiguration: Uses AI-provided Subject, Message, CC, BCC, To fields.\nEdge cases: Missing subject/message.\nDraft Email Reply\nType: Gmail Tool\nRole: Drafts replies linked to a thread ID.\nConfiguration: Uses AI variables for message, thread ID, recipients.\nEdge cases: Invalid thread ID.\nGet Emails\nType: Gmail Tool\nRole: Retrieves emails based on AI-supplied filters (search query, date range).\nConfiguration: Returns all or limited emails per AI input.\nEdge cases: Large data volume, malformed queries.\nAdd Label to Email\nType: Gmail Tool\nRole: Adds labels to specific emails.\nConfiguration: Uses message ID and comma-separated labels.\nEdge cases: Invalid label names/IDs.\nGet Labels\nType: Gmail Tool\nRole: Fetches list of labels in Gmail account.\nConfiguration: Optionally returns all labels.\nEdge cases: API failures.\n1.4 Calendar Management (Calendar MCP)\nOverview:\nManages Google Calendar events: checks availability, creates, updates, reschedules, retrieves, and deletes events.\nNodes Involved:\nCalendar MCP Server (MCP Trigger)\nCalendar MCP (MCP Client Tool)\nCheck Availability\nGet all Events\nCreate an event\nGet Event\nReschedule Event\nDelete Calendar Event\nNode Details:\nCalendar MCP Server\nType: MCP Trigger\nRole: Receives AI requests for calendar operations.\nConfiguration: Unique webhook path.\nEdge cases: Downtime, malformed requests.\nCalendar MCP\nType: MCP Client Tool\nRole: Sends AI requests to calendar MCP server.\nConfiguration: SSE endpoint URL specified.\nCheck Availability\nType: Google Calendar Tool\nRole: Checks if a time slot is free on the calendar.\nConfiguration: Uses AI inputs for start/end times, calendar selection, timezone.\nEdge cases: Invalid dates, timezone mismatches.\nGet all Events\nType: Google Calendar Tool\nRole: Retrieves all calendar events within a time window.\nConfiguration: Uses AI inputs for date filters; expands recurring events.\nEdge cases: Large event sets, API limits.\nCreate an event\nType: Google Calendar Tool\nRole: Creates a new calendar event with optional summary and description.\nConfiguration: Accepts start/end times, summary, description, reminders, calendar ID.\nEdge cases: Past dates, invalid attendees.\nGet Event\nType: Google Calendar Tool\nRole: Retrieves details of a single event by event ID.\nEdge cases: Nonexistent event ID.\nReschedule Event\nType: Google Calendar Tool\nRole: Updates event timing and attendees.\nConfiguration: Uses AI inputs for new start/end times and attendees.\nEdge cases: Conflicting schedules.\nDelete Calendar Event\nType: Google Calendar Tool\nRole: Deletes an event by ID.\nEdge cases: Invalid or already deleted events.\n1.5 Task Management (Google Tasks MCP)\nOverview:\nManages Google Tasks including creating, retrieving, updating (completing), and deleting tasks.\nNodes Involved:\nTask Manager MCP (MCP Trigger)\nGoogle Tasks MCP (MCP Client Tool)\nCreate a Task\nGet a Task\nGet many Tasks\nComplete a Task\nDelete a Task\nNode Details:\nTask Manager MCP\nType: MCP Trigger\nRole: Entry point for AI task management commands.\nConfiguration: Webhook path.\nEdge cases: Request validation.\nGoogle Tasks MCP\nType: MCP Client Tool\nRole: Connects to task MCP server endpoint.\nConfiguration: SSE endpoint URL.\nCreate a Task\nType: Google Tasks Tool\nRole: Creates a new task with title, notes, and due date.\nEdge cases: Past due dates, invalid formats.\nGet a Task\nRetrieves a specific task by ID.\nGet many Tasks\nRetrieves multiple tasks with filtering options like showing completed tasks.\nComplete a Task\nMarks a task as completed with a completion date.\nDelete a Task\nDeletes a task by ID.\n1.6 Finance Tracking (Finance Manager MCP)\nOverview:\nTracks expenses using Google Sheets: adding new expenses, retrieving all expenses, and deleting expense entries.\nNodes Involved:\nFinance Manager MCP Server (MCP Trigger)\nFinance Tracker (MCP Client Tool)\nGet all Expenses\nCreate Expense\nDelete Expense\nNode Details:\nFinance Manager MCP Server\nMCP Trigger receiving AI requests for finance operations.\nIncludes a sticky note describing its capabilities and features.\nFinance Tracker\nMCP Client Tool communicating with the Finance Manager MCP server via SSE.\nGet all Expenses\nReads rows from a specified Google Sheets document and sheet (Expense Tracker).\nAI-configurable parameters: Document ID, sheet name, range.\nCreate Expense\nAppends new expense entries to the sheet with columns Date, Amount, Category, Description.\nDelete Expense\nClears specified rows from the expense sheet.\nEdge cases: Data loss risk, invalid row numbers.\n1.7 Contact Management (Google Contacts MCP)\nOverview:\nProvides access to Google Contacts to fetch contact details for communication purposes.\nNodes Involved:\nGoogle Contacts MCP (MCP Trigger)\nGoogle Contacts (MCP Client Tool)\nGet Contacts\nNode Details:\nGoogle Contacts MCP\nMCP Trigger for contact-related AI requests.\nGoogle Contacts\nMCP Client Tool connected to contacts MCP server via SSE.\nGet Contacts\nRetrieves contacts matching AI query parameters, with fields like names and email addresses.\nEdge cases: Permission restrictions, large contact lists.\n1.8 Audio Processing (Speech to Text and Text to Speech)\nOverview:\nHandles conversion of audio messages from Telegram into text for AI processing, and converts AI text responses into audio files to send back.\nNodes Involved:\nTranscribe audio or video (ElevenLabs speech-to-text)\nConvert text to speech (ElevenLabs text-to-speech)\nSend an audio file (Telegram)\nSend a text message (Telegram)\nNode Details:\nTranscribe audio or video\nConverts Telegram audio file into transcribed text for Jarvis.\nUses ElevenLabs API.\nFailures: Noisy audio, transcription errors.\nConvert text to speech\nSynthesizes Jarvis‚Äôs response text into audio.\nVoice preset: \"Devi - Clear Hindi pronunciation\".\nFailures: API quota, text length limits.\nSend an audio file\nSends synthesized audio back to user's Telegram chat with caption from reply message.\nEnsures special characters in caption are escaped for MarkdownV2.\nSend a text message\nSends plain text reply messages via Telegram with MarkdownV2 formatting.\n1.9 Output Delivery\nOverview:\nDepending on input type (text or audio), delivers Jarvis‚Äôs response back to the user via Telegram either as text or as an audio file.\nNodes Involved:\nSend a text message\nConvert text to speech\nSend an audio file\nNode Details:\nText inputs ‚Üí Send a text message directly.\nAudio inputs ‚Üí Convert text to speech ‚Üí Send audio file.\nProper escaping in captions for MarkdownV2 compliance.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nEntry point for Telegram messages\n-\nOnly allow me\nOnly allow me\nFilter\nAuthorizes only user \"jackman8\"\nTelegram Trigger\nSwitch\nSwitch (text/audio)\nSwitch\nRoutes based on message text presence\nOnly allow me\nJarvis, Get a file\nGet a file\nTelegram\nRetrieves audio file from Telegram\nSwitch\nTranscribe audio or video\nTranscribe audio or video\nElevenLabs Speech-to-Text\nConverts audio to text\nGet a file\nJarvis\nJarvis\nLangchain Agent\nAI assistant core processing\nSwitch, Transcribe audio...\nSet Reply Message\nSimple Memory\nLangchain Memory Buffer\nMaintains session memory keyed by username\nTelegram Trigger\nJarvis\nOpenAI Chat Model\nLangchain OpenAI Model\nGPT-4 language model\nJarvis\nJarvis\nThink\nLangchain Tool Think\nInternal agent reasoning\nJarvis\nJarvis\nSet Reply Message\nSet\nPrepares reply message for output\nJarvis\nCheck Text or Audio\nCheck Text or Audio\nSwitch\nRoutes output to text or audio response\nSet Reply Message\nSend a text message, Convert text to speech\nSend a text message\nTelegram\nSends reply as text message\nCheck Text or Audio\n-\nConvert text to speech\nElevenLabs Text-to-Speech\nConverts text reply to audio\nCheck Text or Audio\nSend an audio file\nSend an audio file\nTelegram\nSends audio reply to Telegram\nConvert text to speech\n-\nGmail MCP Server\nMCP Trigger\nEntry for Gmail-based AI email operations\nGet Emails, Send Email, ...\n-\nGmail MCP üìß Full email management. Send & draft messages, reply, label, fetch emails\nGmail MCP\nMCP Client Tool\nClient for Gmail MCP Server\nJarvis\nJarvis\nGmail MCP üìß Full email management. Send & draft messages, reply, label, fetch emails\nSend Email\nGmail Tool\nSends email\nGmail MCP\nGmail MCP Server\nReply to an Email\nGmail Tool\nReplies to email\nGmail MCP\nGmail MCP Server\nDraft Email\nGmail Tool\nCreates email drafts\nGmail MCP\nGmail MCP Server\nDraft Email Reply\nGmail Tool\nDrafts email replies\nGmail MCP\nGmail MCP Server\nGet Emails\nGmail Tool\nRetrieves emails\nGmail MCP\nGmail MCP Server\nAdd Label to Email\nGmail Tool\nAdds labels to emails\nGmail MCP\nGmail MCP Server\nGet Labels\nGmail Tool\nRetrieves email labels\nGmail MCP\nGmail MCP Server\nCalendar MCP Server\nMCP Trigger\nEntry point for calendar AI operations\nGet Event, Create an event...\n-\nCalendar MCP üìÖ Your scheduling hub. Check availability, create, reschedule, delete events\nCalendar MCP\nMCP Client Tool\nClient to calendar MCP Server\nJarvis\nJarvis\nCalendar MCP üìÖ Your scheduling hub. Check availability, create, reschedule, delete events\nCheck Availability\nGoogle Calendar Tool\nChecks free/busy slots\nCalendar MCP\nCalendar MCP Server\nGet all Events\nGoogle Calendar Tool\nRetrieves calendar events\nCalendar MCP\nCalendar MCP Server\nCreate an event\nGoogle Calendar Tool\nCreates new calendar event\nCalendar MCP\nCalendar MCP Server\nGet Event\nGoogle Calendar Tool\nRetrieves specific event\nCalendar MCP\nCalendar MCP Server\nReschedule Event\nGoogle Calendar Tool\nUpdates event timing and attendees\nCalendar MCP\nCalendar MCP Server\nDelete Calendar Event\nGoogle Calendar Tool\nDeletes event by ID\nCalendar MCP\nCalendar MCP Server\nTask Manager MCP\nMCP Trigger\nEntry point for task AI operations\nGet a Task, Create a Task...\n-\nTask Manager MCP ‚úÖ Manages to-dos with ease: create, complete, delete, retrieve tasks\nGoogle Tasks MCP\nMCP Client Tool\nClient for task MCP Server\nJarvis\nJarvis\nTask Manager MCP ‚úÖ Manages to-dos with ease: create, complete, delete, retrieve tasks\nCreate a Task\nGoogle Tasks Tool\nCreates a new task\nGoogle Tasks MCP\nTask Manager MCP\nGet a Task\nGoogle Tasks Tool\nRetrieves a task by ID\nGoogle Tasks MCP\nTask Manager MCP\nGet many Tasks\nGoogle Tasks Tool\nRetrieves multiple tasks\nGoogle Tasks MCP\nTask Manager MCP\nComplete a Task\nGoogle Tasks Tool\nMarks task as completed\nGoogle Tasks MCP\nTask Manager MCP\nDelete a Task\nGoogle Tasks Tool\nDeletes a task\nGoogle Tasks MCP\nTask Manager MCP\nFinance Manager MCP Server\nMCP Trigger\nEntry for finance AI operations\nGet all Expenses, Create Expense, Delete Expense\n-\nFinance Manager MCP üíµ Track expenses: create, get, delete entries\nFinance Tracker\nMCP Client Tool\nClient for finance MCP server\nJarvis\nJarvis\nFinance Manager MCP üíµ Track expenses: create, get, delete entries\nGet all Expenses\nGoogle Sheets Tool\nReads expense data from sheet\nFinance Manager MCP Server\nFinance Manager MCP Server\nCreate Expense\nGoogle Sheets Tool\nAppends new expense data\nFinance Manager MCP Server\nFinance Manager MCP Server\nDelete Expense\nGoogle Sheets Tool\nDeletes expense data rows\nFinance Manager MCP Server\nFinance Manager MCP Server\nGoogle Contacts MCP\nMCP Trigger\nEntry for contacts AI operations\nGet Contacts\n-\nGoogle Contacts MCP üë• Access and manage contacts\nGoogle Contacts\nMCP Client Tool\nClient for contacts MCP server\nJarvis\nJarvis\nGoogle Contacts MCP üë• Access and manage contacts\nGet Contacts\nGoogle Contacts Tool\nRetrieves contacts matching query\nGoogle Contacts MCP\nGoogle Contacts MCP\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger node:\nType: Telegram Trigger\nConfigure webhook to listen for \"message\" updates.\nSet credentials with your Telegram Bot token.\nCreate Filter node \"Only allow me\":\nType: Filter\nCondition: Allow only if message.chat.username equals \"jackman8\".\nConnect its input from Telegram Trigger.\nCreate Switch node \"Switch\" for text/audio detection:\nType: Switch\nRule \"Text\": Exists check on\nmessage.text\n.\nRule \"Audio\": Not exists check on\nmessage.text\n.\nConnect \"Only allow me\" output to this node.\nFor audio path:\nAdd \"Get a file\" Telegram node to retrieve voice file by\nmessage.voice.file_id\n.\nConnect \"Switch\" Audio output to \"Get a file\".\nAdd \"Transcribe audio or video\" node:\nType: ElevenLabs Speech-to-Text.\nUse ElevenLabs credentials.\nConnect input from \"Get a file\".\nAdd \"Jarvis\" Langchain Agent node:\nType: Langchain Agent.\nConfigure prompt text to include user message and memory context.\nSet system prompt defining Jarvis‚Äôs identity, capabilities, and instructions (copy from given system message).\nUse OpenAI Chat Model node (GPT-4.1-mini) for language model.\nConnect inputs from \"Switch\" Text output and from \"Transcribe audio or video\" output.\nConnect \"Simple Memory\" node (Langchain Memory Buffer) keyed on Telegram username as AI memory input.\nAdd \"Simple Memory\" node:\nType: Langchain Memory Buffer Window.\nUse Telegram username as session key.\nConnect input from Telegram Trigger.\nConnect output to Jarvis AI memory input.\nAdd \"OpenAI Chat Model\":\nType: Langchain OpenAI Chat Model.\nSet model to \"gpt-4.1-mini\".\nUse OpenAI API credentials.\nConnect output to Jarvis AI language model input.\nAdd \"Think\" node:\nType: Langchain Tool Think.\nConnect input and output to Jarvis for internal reasoning.\nAdd \"Set Reply Message\" node:\nType: Set.\nAssign\nmessage\nfield from Jarvis‚Äôs\noutput\nor\nerror\n.\nConnect input from Jarvis.\nAdd \"Check Text or Audio\" Switch node:\nType: Switch.\nRule \"Text\": Check if Telegram Trigger message has text.\nRule \"Audio\": Otherwise.\nConnect input from \"Set Reply Message\".\nAdd \"Send a text message\" Telegram node:\nUse Telegram Bot credentials.\nSet chatId from Telegram Trigger message chat.id.\nText from \"Set Reply Message\" message.\nConnect input from Switch Text output.\nAdd \"Convert text to speech\" ElevenLabs node:\nUse ElevenLabs API credentials.\nVoice: \"Devi - Clear Hindi pronunciation\".\nText from \"Set Reply Message\" message.\nConnect input from Switch Audio output.\nAdd \"Send an audio file\" Telegram node:\nUse Telegram Bot credentials.\nSet chatId from Telegram Trigger message chat.id.\nSend audio binary data from ElevenLabs output.\nCaption from escaped \"Set Reply Message\" message.\nConnect input from \"Convert text to speech\".\nSet up Gmail MCP Server trigger:\nType: MCP Trigger.\nCreate webhook for Gmail MCP operations.\nSet up Gmail MCP client tool:\nConnect to Gmail MCP Server SSE endpoint.\nConfigure Gmail nodes:\nSend Email, Reply to Email, Draft Email, Draft Email Reply, Get Emails, Add Label to Email, Get Labels.\nUse Gmail OAuth2 credentials.\nConnect outputs to Gmail MCP Server as AI tool.\nSet up Calendar MCP Server trigger and client tool:\nConfigure webhook and SSE endpoint for calendar operations.\nConfigure Google Calendar Tool nodes:\nCheck Availability, Get all Events, Create an event, Get Event, Reschedule Event, Delete Calendar Event.\nUse Google Calendar OAuth2 credentials.\nSet up Task Manager MCP trigger and client tool:\nConfigure webhook and SSE endpoint for tasks.\nConfigure Google Tasks Tool nodes:\nCreate a Task, Get a Task, Get many Tasks, Complete a Task, Delete a Task.\nUse Google Tasks OAuth2 credentials.\nSet up Finance Manager MCP Server trigger and client tool:\nConfigure webhook and SSE endpoint for finance management.\nConfigure Google Sheets Tool nodes:\nGet all Expenses, Create Expense, Delete Expense.\nUse Google Sheets OAuth2 credentials.\nSet Document ID and Sheet Name referencing Expense Tracker spreadsheet.\nSet up Google Contacts MCP trigger and client tool:\nConfigure webhook and SSE endpoint for contacts.\nConfigure Google Contacts Tool node:\nGet Contacts node to retrieve contact info.\nUse Google Contacts OAuth2 credentials.\nAdd Sticky Notes:\nAdd notes summarizing the blocks for usability and maintenance.\n5. General Notes & Resources\nNote Content\nContext or Link\n\"Jarvis ü§ñ: Your AI-powered personal assistant orchestrating tasks, calendar, emails, contacts & expenses using MCPs.\"\nGeneral project description in Sticky Note1.\nGmail MCP üìß: Full email management including send, draft, reply, label, and fetch emails.\nSticky Note4 in the email management section.\nCalendar MCP üìÖ: Scheduling hub for checking availability, creating, rescheduling, and deleting events.\nSticky Note3 in the calendar management block.\nTask Manager MCP ‚úÖ: Manages to-dos with create, complete, delete, retrieve functionality.\nSticky Note2 in the task management area.\nFinance Manager MCP üíµ: Tracks personal/business expenses with create, retrieve, delete operations.\nSticky Note5 in the finance tracking block.\nGoogle Contacts MCP üë•: Access and manage contact list for quick communication.\nSticky Note6 in the contacts management block.\nTelegram Bot used as primary user interface for conversational input and output including audio support.\nTelegram Trigger and related Telegram nodes.\nElevenLabs API used for speech-to-text and text-to-speech conversion to support audio interactions.\nNodes: Transcribe audio or video, Convert text to speech.\nOpenAI GPT-4.1-mini model powers AI reasoning and natural language processing.\nOpenAI Chat Model node with credentials.\nThis detailed documentation enables understanding, modification, and full reconstruction of the Jarvis productivity assistant workflow in n8n. It covers all nodes, configurations, integration points, potential failure modes, and logical flow, supporting both human users and AI agents in advanced usage scenarios.\nCopied to clipboard",
      "description_full_fr": "Jarvis: Productivity AI Agent for Tasks, Calendar, Email & Expense using MCPs\n1. Workflow Overview\nThis workflow, titled\nJarvis: Productivity AI Agent for Tasks, Calendar, Email & Expense using MCPs\n, is designed as a comprehensive AI-driven personal productivity assistant named \"Jarvis.\" It integrates multiple productivity domains including task management, calendar scheduling, email handling, contact management, and expense tracking. The workflow leverages n8n‚Äôs Langchain MCP (Model Context Protocol) tools, OpenAI GPT-4, Telegram as a user interface, and several Google services (Gmail, Calendar, Tasks, Contacts, Sheets) to provide a seamless and intelligent assistant experience.\nTarget Use Cases:\nManage daily tasks with Google Tasks: create, complete, delete, and retrieve tasks.\nHandle calendar events on Google Calendar: check availability, create, update, delete, and fetch events.\nManage emails via Gmail: send, reply, draft, label, and retrieve emails.\nTrack expenses with Google Sheets integration: add, retrieve, and delete expense records.\nAccess and retrieve Google Contacts for communication.\nProvide conversational AI assistance through Telegram, supporting both text and audio inputs with speech recognition and synthesis.\nLogical Blocks:\n1.1 Input Reception and User Authentication\nReceives user input from Telegram; filters authorized users; differentiates between text and audio input.\n1.2 AI Processing and Memory Management\nProcesses user input with Jarvis agent, backed by OpenAI GPT-4 and a simple memory buffer keyed by Telegram username.\n1.3 Email Management (Gmail MCP)\nFull Gmail integration for sending, replying, drafting, labeling, and searching emails, via MCP protocol.\n1.4 Calendar Management (Calendar MCP)\nGoogle Calendar operations: availability checks, event creation, retrieval, rescheduling, and deletion through MCP.\n1.5 Task Management (Google Tasks MCP)\nGoogle Tasks operations: create, get, update (complete), delete tasks managed via MCP.\n1.6 Finance Tracking (Finance Manager MCP)\nExpense tracking using Google Sheets to add, retrieve, and delete expense data.\n1.7 Contact Management (Google Contacts MCP)\nFetch and manage Google Contacts to facilitate communication.\n1.8 Audio Processing (Speech to Text and Text to Speech)\nHandles audio input transcription and audio response generation via ElevenLabs API.\n1.9 Output Delivery\nSends back text or audio responses to Telegram users.\n2. Block-by-Block Analysis\n1.1 Input Reception and User Authentication\nOverview:\nThis block receives user messages from Telegram, checks if the sender is authorized, and routes the input based on whether it's text or audio.\nNodes Involved:\nTelegram Trigger\nOnly allow me (Filter)\nSwitch (Check Text or Audio)\nSwitch (inside Only allow me for text/audio existence check)\nGet a file (for audio inputs)\nNode Details:\nTelegram Trigger\nType: Telegram Trigger\nRole: Entry point capturing all incoming Telegram messages (text/audio).\nConfiguration: Listens for \"message\" updates; uses Telegram Bot credentials.\nOutputs: Raw Telegram message JSON.\nFailure cases: Telegram API downtime, invalid webhook.\nOnly allow me (Filter)\nType: Filter\nRole: Authorizes only user with username \"jackman8\" to proceed.\nConfiguration: Checks if\nmessage.chat.username\nequals \"jackman8\".\nOutput: Routes authorized users to Switch node; blocks others.\nEdge cases: Unauthorized users get no response; consider adding rejection message.\nSwitch (Check Text or Audio)\nType: Switch\nRole: Differentiates between text and audio inputs by checking if\nmessage.text\nexists.\nConfiguration: Routes text messages to Jarvis AI, audio messages to \"Get a file\".\nEdge cases: Messages without text or audio might be dropped silently.\nGet a file\nType: Telegram Node\nRole: Retrieves the audio file from Telegram for transcription.\nConfiguration: Uses\nmessage.voice.file_id\nfrom Telegram message.\nOutput: Passes file data to transcription node.\nFailure: Missing or expired file IDs, Telegram file API errors.\n1.2 AI Processing and Memory Management\nOverview:\nUses a Langchain agent named Jarvis empowered by GPT-4, supported by a simple memory buffer that maintains session context per Telegram username.\nNodes Involved:\nSimple Memory\nOpenAI Chat Model\nJarvis (Langchain Agent)\nThink (Tool Think)\nSet Reply Message\nNode Details:\nSimple Memory\nType: Memory Buffer Window (Langchain)\nRole: Maintains conversation history keyed by Telegram username.\nConfiguration: Session key as username from Telegram message; custom session ID type.\nEdge cases: Memory overflow or reset, user switching.\nOpenAI Chat Model\nType: Langchain OpenAI Chat Model\nRole: Provides GPT-4.1-mini model for language generation.\nConfiguration: Model set to GPT-4.1-mini; credentials for OpenAI API provided.\nFailures: API key quota exceeded, rate limits, network errors.\nJarvis\nType: Langchain Agent\nRole: Main AI agent that interprets user requests, decides tool usage, and composes responses.\nConfiguration: System prompt defines Jarvis‚Äôs identity, capabilities, operational rules, and tone.\nUses memory and OpenAI Chat Model nodes.\nOnError: Continue regular output to avoid halting on errors.\nEdge cases: Incorrect or ambiguous inputs, missing parameters, API failures.\nThink\nType: Langchain Tool Think\nRole: Internal thinking step for the agent to process multi-tool decisions.\nConfiguration: Default.\nConnected to Jarvis for enhanced reasoning.\nSet Reply Message\nType: Set\nRole: Prepares the final text message output from Jarvis‚Äôs response or error messages.\nConfiguration: Assigns\nmessage\nfield from Jarvis output or error.\nOutputs: Feeds into output delivery nodes.\n1.3 Email Management (Gmail MCP)\nOverview:\nFull Gmail integration through MCP enables sending, replying, drafting, labeling, and fetching emails.\nNodes Involved:\nGmail MCP (MCP Client Tool)\nGmail MCP Server (MCP Trigger)\nSend Email\nReply to an Email\nDraft Email\nDraft Email Reply\nGet Emails\nAdd Label to Email\nGet Labels\nNode Details:\nGmail MCP Server\nType: MCP Trigger\nRole: Entry point for AI requests related to Gmail operations.\nConfiguration: Webhook with a unique path.\nEdge cases: Webhook downtime, invalid requests.\nGmail MCP\nType: MCP Client Tool\nRole: Client tool to communicate with Gmail MCP Server via SSE endpoint.\nConfiguration: Endpoint URL specified.\nUsed by Jarvis to perform email operations.\nSend Email\nType: Gmail Tool\nRole: Sends new emails.\nConfiguration: Uses AI-provided To, Subject, Message fields; disables attribution.\nCredentials: Gmail OAuth2.\nEdge cases: Invalid email addresses, quota exhaustion.\nReply to an Email\nType: Gmail Tool\nRole: Replies to existing emails with optional CC, BCC, attachments.\nConfiguration: Uses AI variables for message content, message ID, recipients.\nEdge cases: Missing message ID, attachment errors.\nDraft Email\nType: Gmail Tool\nRole: Creates email drafts with HTML content and recipients.\nConfiguration: Uses AI-provided Subject, Message, CC, BCC, To fields.\nEdge cases: Missing subject/message.\nDraft Email Reply\nType: Gmail Tool\nRole: Drafts replies linked to a thread ID.\nConfiguration: Uses AI variables for message, thread ID, recipients.\nEdge cases: Invalid thread ID.\nGet Emails\nType: Gmail Tool\nRole: Retrieves emails based on AI-supplied filters (search query, date range).\nConfiguration: Returns all or limited emails per AI input.\nEdge cases: Large data volume, malformed queries.\nAdd Label to Email\nType: Gmail Tool\nRole: Adds labels to specific emails.\nConfiguration: Uses message ID and comma-separated labels.\nEdge cases: Invalid label names/IDs.\nGet Labels\nType: Gmail Tool\nRole: Fetches list of labels in Gmail account.\nConfiguration: Optionally returns all labels.\nEdge cases: API failures.\n1.4 Calendar Management (Calendar MCP)\nOverview:\nManages Google Calendar events: checks availability, creates, updates, reschedules, retrieves, and deletes events.\nNodes Involved:\nCalendar MCP Server (MCP Trigger)\nCalendar MCP (MCP Client Tool)\nCheck Availability\nGet all Events\nCreate an event\nGet Event\nReschedule Event\nDelete Calendar Event\nNode Details:\nCalendar MCP Server\nType: MCP Trigger\nRole: Receives AI requests for calendar operations.\nConfiguration: Unique webhook path.\nEdge cases: Downtime, malformed requests.\nCalendar MCP\nType: MCP Client Tool\nRole: Sends AI requests to calendar MCP server.\nConfiguration: SSE endpoint URL specified.\nCheck Availability\nType: Google Calendar Tool\nRole: Checks if a time slot is free on the calendar.\nConfiguration: Uses AI inputs for start/end times, calendar selection, timezone.\nEdge cases: Invalid dates, timezone mismatches.\nGet all Events\nType: Google Calendar Tool\nRole: Retrieves all calendar events within a time window.\nConfiguration: Uses AI inputs for date filters; expands recurring events.\nEdge cases: Large event sets, API limits.\nCreate an event\nType: Google Calendar Tool\nRole: Creates a new calendar event with optional summary and description.\nConfiguration: Accepts start/end times, summary, description, reminders, calendar ID.\nEdge cases: Past dates, invalid attendees.\nGet Event\nType: Google Calendar Tool\nRole: Retrieves details of a single event by event ID.\nEdge cases: Nonexistent event ID.\nReschedule Event\nType: Google Calendar Tool\nRole: Updates event timing and attendees.\nConfiguration: Uses AI inputs for new start/end times and attendees.\nEdge cases: Conflicting schedules.\nDelete Calendar Event\nType: Google Calendar Tool\nRole: Deletes an event by ID.\nEdge cases: Invalid or already deleted events.\n1.5 Task Management (Google Tasks MCP)\nOverview:\nManages Google Tasks including creating, retrieving, updating (completing), and deleting tasks.\nNodes Involved:\nTask Manager MCP (MCP Trigger)\nGoogle Tasks MCP (MCP Client Tool)\nCreate a Task\nGet a Task\nGet many Tasks\nComplete a Task\nDelete a Task\nNode Details:\nTask Manager MCP\nType: MCP Trigger\nRole: Entry point for AI task management commands.\nConfiguration: Webhook path.\nEdge cases: Request validation.\nGoogle Tasks MCP\nType: MCP Client Tool\nRole: Connects to task MCP server endpoint.\nConfiguration: SSE endpoint URL.\nCreate a Task\nType: Google Tasks Tool\nRole: Creates a new task with title, notes, and due date.\nEdge cases: Past due dates, invalid formats.\nGet a Task\nRetrieves a specific task by ID.\nGet many Tasks\nRetrieves multiple tasks with filtering options like showing completed tasks.\nComplete a Task\nMarks a task as completed with a completion date.\nDelete a Task\nDeletes a task by ID.\n1.6 Finance Tracking (Finance Manager MCP)\nOverview:\nTracks expenses using Google Sheets: adding new expenses, retrieving all expenses, and deleting expense entries.\nNodes Involved:\nFinance Manager MCP Server (MCP Trigger)\nFinance Tracker (MCP Client Tool)\nGet all Expenses\nCreate Expense\nDelete Expense\nNode Details:\nFinance Manager MCP Server\nMCP Trigger receiving AI requests for finance operations.\nIncludes a sticky note describing its capabilities and features.\nFinance Tracker\nMCP Client Tool communicating with the Finance Manager MCP server via SSE.\nGet all Expenses\nReads rows from a specified Google Sheets document and sheet (Expense Tracker).\nAI-configurable parameters: Document ID, sheet name, range.\nCreate Expense\nAppends new expense entries to the sheet with columns Date, Amount, Category, Description.\nDelete Expense\nClears specified rows from the expense sheet.\nEdge cases: Data loss risk, invalid row numbers.\n1.7 Contact Management (Google Contacts MCP)\nOverview:\nProvides access to Google Contacts to fetch contact details for communication purposes.\nNodes Involved:\nGoogle Contacts MCP (MCP Trigger)\nGoogle Contacts (MCP Client Tool)\nGet Contacts\nNode Details:\nGoogle Contacts MCP\nMCP Trigger for contact-related AI requests.\nGoogle Contacts\nMCP Client Tool connected to contacts MCP server via SSE.\nGet Contacts\nRetrieves contacts matching AI query parameters, with fields like names and email addresses.\nEdge cases: Permission restrictions, large contact lists.\n1.8 Audio Processing (Speech to Text and Text to Speech)\nOverview:\nHandles conversion of audio messages from Telegram into text for AI processing, and converts AI text responses into audio files to send back.\nNodes Involved:\nTranscribe audio or video (ElevenLabs speech-to-text)\nConvert text to speech (ElevenLabs text-to-speech)\nSend an audio file (Telegram)\nSend a text message (Telegram)\nNode Details:\nTranscribe audio or video\nConverts Telegram audio file into transcribed text for Jarvis.\nUses ElevenLabs API.\nFailures: Noisy audio, transcription errors.\nConvert text to speech\nSynthesizes Jarvis‚Äôs response text into audio.\nVoice preset: \"Devi - Clear Hindi pronunciation\".\nFailures: API quota, text length limits.\nSend an audio file\nSends synthesized audio back to user's Telegram chat with caption from reply message.\nEnsures special characters in caption are escaped for MarkdownV2.\nSend a text message\nSends plain text reply messages via Telegram with MarkdownV2 formatting.\n1.9 Output Delivery\nOverview:\nDepending on input type (text or audio), delivers Jarvis‚Äôs response back to the user via Telegram either as text or as an audio file.\nNodes Involved:\nSend a text message\nConvert text to speech\nSend an audio file\nNode Details:\nText inputs ‚Üí Send a text message directly.\nAudio inputs ‚Üí Convert text to speech ‚Üí Send audio file.\nProper escaping in captions for MarkdownV2 compliance.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger\nTelegram Trigger\nEntry point for Telegram messages\n-\nOnly allow me\nOnly allow me\nFilter\nAuthorizes only user \"jackman8\"\nTelegram Trigger\nSwitch\nSwitch (text/audio)\nSwitch\nRoutes based on message text presence\nOnly allow me\nJarvis, Get a file\nGet a file\nTelegram\nRetrieves audio file from Telegram\nSwitch\nTranscribe audio or video\nTranscribe audio or video\nElevenLabs Speech-to-Text\nConverts audio to text\nGet a file\nJarvis\nJarvis\nLangchain Agent\nAI assistant core processing\nSwitch, Transcribe audio...\nSet Reply Message\nSimple Memory\nLangchain Memory Buffer\nMaintains session memory keyed by username\nTelegram Trigger\nJarvis\nOpenAI Chat Model\nLangchain OpenAI Model\nGPT-4 language model\nJarvis\nJarvis\nThink\nLangchain Tool Think\nInternal agent reasoning\nJarvis\nJarvis\nSet Reply Message\nSet\nPrepares reply message for output\nJarvis\nCheck Text or Audio\nCheck Text or Audio\nSwitch\nRoutes output to text or audio response\nSet Reply Message\nSend a text message, Convert text to speech\nSend a text message\nTelegram\nSends reply as text message\nCheck Text or Audio\n-\nConvert text to speech\nElevenLabs Text-to-Speech\nConverts text reply to audio\nCheck Text or Audio\nSend an audio file\nSend an audio file\nTelegram\nSends audio reply to Telegram\nConvert text to speech\n-\nGmail MCP Server\nMCP Trigger\nEntry for Gmail-based AI email operations\nGet Emails, Send Email, ...\n-\nGmail MCP üìß Full email management. Send & draft messages, reply, label, fetch emails\nGmail MCP\nMCP Client Tool\nClient for Gmail MCP Server\nJarvis\nJarvis\nGmail MCP üìß Full email management. Send & draft messages, reply, label, fetch emails\nSend Email\nGmail Tool\nSends email\nGmail MCP\nGmail MCP Server\nReply to an Email\nGmail Tool\nReplies to email\nGmail MCP\nGmail MCP Server\nDraft Email\nGmail Tool\nCreates email drafts\nGmail MCP\nGmail MCP Server\nDraft Email Reply\nGmail Tool\nDrafts email replies\nGmail MCP\nGmail MCP Server\nGet Emails\nGmail Tool\nRetrieves emails\nGmail MCP\nGmail MCP Server\nAdd Label to Email\nGmail Tool\nAdds labels to emails\nGmail MCP\nGmail MCP Server\nGet Labels\nGmail Tool\nRetrieves email labels\nGmail MCP\nGmail MCP Server\nCalendar MCP Server\nMCP Trigger\nEntry point for calendar AI operations\nGet Event, Create an event...\n-\nCalendar MCP üìÖ Your scheduling hub. Check availability, create, reschedule, delete events\nCalendar MCP\nMCP Client Tool\nClient to calendar MCP Server\nJarvis\nJarvis\nCalendar MCP üìÖ Your scheduling hub. Check availability, create, reschedule, delete events\nCheck Availability\nGoogle Calendar Tool\nChecks free/busy slots\nCalendar MCP\nCalendar MCP Server\nGet all Events\nGoogle Calendar Tool\nRetrieves calendar events\nCalendar MCP\nCalendar MCP Server\nCreate an event\nGoogle Calendar Tool\nCreates new calendar event\nCalendar MCP\nCalendar MCP Server\nGet Event\nGoogle Calendar Tool\nRetrieves specific event\nCalendar MCP\nCalendar MCP Server\nReschedule Event\nGoogle Calendar Tool\nUpdates event timing and attendees\nCalendar MCP\nCalendar MCP Server\nDelete Calendar Event\nGoogle Calendar Tool\nDeletes event by ID\nCalendar MCP\nCalendar MCP Server\nTask Manager MCP\nMCP Trigger\nEntry point for task AI operations\nGet a Task, Create a Task...\n-\nTask Manager MCP ‚úÖ Manages to-dos with ease: create, complete, delete, retrieve tasks\nGoogle Tasks MCP\nMCP Client Tool\nClient for task MCP Server\nJarvis\nJarvis\nTask Manager MCP ‚úÖ Manages to-dos with ease: create, complete, delete, retrieve tasks\nCreate a Task\nGoogle Tasks Tool\nCreates a new task\nGoogle Tasks MCP\nTask Manager MCP\nGet a Task\nGoogle Tasks Tool\nRetrieves a task by ID\nGoogle Tasks MCP\nTask Manager MCP\nGet many Tasks\nGoogle Tasks Tool\nRetrieves multiple tasks\nGoogle Tasks MCP\nTask Manager MCP\nComplete a Task\nGoogle Tasks Tool\nMarks task as completed\nGoogle Tasks MCP\nTask Manager MCP\nDelete a Task\nGoogle Tasks Tool\nDeletes a task\nGoogle Tasks MCP\nTask Manager MCP\nFinance Manager MCP Server\nMCP Trigger\nEntry for finance AI operations\nGet all Expenses, Create Expense, Delete Expense\n-\nFinance Manager MCP üíµ Track expenses: create, get, delete entries\nFinance Tracker\nMCP Client Tool\nClient for finance MCP server\nJarvis\nJarvis\nFinance Manager MCP üíµ Track expenses: create, get, delete entries\nGet all Expenses\nGoogle Sheets Tool\nReads expense data from sheet\nFinance Manager MCP Server\nFinance Manager MCP Server\nCreate Expense\nGoogle Sheets Tool\nAppends new expense data\nFinance Manager MCP Server\nFinance Manager MCP Server\nDelete Expense\nGoogle Sheets Tool\nDeletes expense data rows\nFinance Manager MCP Server\nFinance Manager MCP Server\nGoogle Contacts MCP\nMCP Trigger\nEntry for contacts AI operations\nGet Contacts\n-\nGoogle Contacts MCP üë• Access and manage contacts\nGoogle Contacts\nMCP Client Tool\nClient for contacts MCP server\nJarvis\nJarvis\nGoogle Contacts MCP üë• Access and manage contacts\nGet Contacts\nGoogle Contacts Tool\nRetrieves contacts matching query\nGoogle Contacts MCP\nGoogle Contacts MCP\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger node:\nType: Telegram Trigger\nConfigure webhook to listen for \"message\" updates.\nSet credentials with your Telegram Bot token.\nCreate Filter node \"Only allow me\":\nType: Filter\nCondition: Allow only if message.chat.username equals \"jackman8\".\nConnect its input from Telegram Trigger.\nCreate Switch node \"Switch\" for text/audio detection:\nType: Switch\nRule \"Text\": Exists check on\nmessage.text\n.\nRule \"Audio\": Not exists check on\nmessage.text\n.\nConnect \"Only allow me\" output to this node.\nFor audio path:\nAdd \"Get a file\" Telegram node to retrieve voice file by\nmessage.voice.file_id\n.\nConnect \"Switch\" Audio output to \"Get a file\".\nAdd \"Transcribe audio or video\" node:\nType: ElevenLabs Speech-to-Text.\nUse ElevenLabs credentials.\nConnect input from \"Get a file\".\nAdd \"Jarvis\" Langchain Agent node:\nType: Langchain Agent.\nConfigure prompt text to include user message and memory context.\nSet system prompt defining Jarvis‚Äôs identity, capabilities, and instructions (copy from given system message).\nUse OpenAI Chat Model node (GPT-4.1-mini) for language model.\nConnect inputs from \"Switch\" Text output and from \"Transcribe audio or video\" output.\nConnect \"Simple Memory\" node (Langchain Memory Buffer) keyed on Telegram username as AI memory input.\nAdd \"Simple Memory\" node:\nType: Langchain Memory Buffer Window.\nUse Telegram username as session key.\nConnect input from Telegram Trigger.\nConnect output to Jarvis AI memory input.\nAdd \"OpenAI Chat Model\":\nType: Langchain OpenAI Chat Model.\nSet model to \"gpt-4.1-mini\".\nUse OpenAI API credentials.\nConnect output to Jarvis AI language model input.\nAdd \"Think\" node:\nType: Langchain Tool Think.\nConnect input and output to Jarvis for internal reasoning.\nAdd \"Set Reply Message\" node:\nType: Set.\nAssign\nmessage\nfield from Jarvis‚Äôs\noutput\nor\nerror\n.\nConnect input from Jarvis.\nAdd \"Check Text or Audio\" Switch node:\nType: Switch.\nRule \"Text\": Check if Telegram Trigger message has text.\nRule \"Audio\": Otherwise.\nConnect input from \"Set Reply Message\".\nAdd \"Send a text message\" Telegram node:\nUse Telegram Bot credentials.\nSet chatId from Telegram Trigger message chat.id.\nText from \"Set Reply Message\" message.\nConnect input from Switch Text output.\nAdd \"Convert text to speech\" ElevenLabs node:\nUse ElevenLabs API credentials.\nVoice: \"Devi - Clear Hindi pronunciation\".\nText from \"Set Reply Message\" message.\nConnect input from Switch Audio output.\nAdd \"Send an audio file\" Telegram node:\nUse Telegram Bot credentials.\nSet chatId from Telegram Trigger message chat.id.\nSend audio binary data from ElevenLabs output.\nCaption from escaped \"Set Reply Message\" message.\nConnect input from \"Convert text to speech\".\nSet up Gmail MCP Server trigger:\nType: MCP Trigger.\nCreate webhook for Gmail MCP operations.\nSet up Gmail MCP client tool:\nConnect to Gmail MCP Server SSE endpoint.\nConfigure Gmail nodes:\nSend Email, Reply to Email, Draft Email, Draft Email Reply, Get Emails, Add Label to Email, Get Labels.\nUse Gmail OAuth2 credentials.\nConnect outputs to Gmail MCP Server as AI tool.\nSet up Calendar MCP Server trigger and client tool:\nConfigure webhook and SSE endpoint for calendar operations.\nConfigure Google Calendar Tool nodes:\nCheck Availability, Get all Events, Create an event, Get Event, Reschedule Event, Delete Calendar Event.\nUse Google Calendar OAuth2 credentials.\nSet up Task Manager MCP trigger and client tool:\nConfigure webhook and SSE endpoint for tasks.\nConfigure Google Tasks Tool nodes:\nCreate a Task, Get a Task, Get many Tasks, Complete a Task, Delete a Task.\nUse Google Tasks OAuth2 credentials.\nSet up Finance Manager MCP Server trigger and client tool:\nConfigure webhook and SSE endpoint for finance management.\nConfigure Google Sheets Tool nodes:\nGet all Expenses, Create Expense, Delete Expense.\nUse Google Sheets OAuth2 credentials.\nSet Document ID and Sheet Name referencing Expense Tracker spreadsheet.\nSet up Google Contacts MCP trigger and client tool:\nConfigure webhook and SSE endpoint for contacts.\nConfigure Google Contacts Tool node:\nGet Contacts node to retrieve contact info.\nUse Google Contacts OAuth2 credentials.\nAdd Sticky Notes:\nAdd notes summarizing the blocks for usability and maintenance.\n5. General Notes & Resources\nNote Content\nContext or Link\n\"Jarvis ü§ñ: Your AI-powered personal assistant orchestrating tasks, calendar, emails, contacts & expenses using MCPs.\"\nGeneral project description in Sticky Note1.\nGmail MCP üìß: Full email management including send, draft, reply, label, and fetch emails.\nSticky Note4 in the email management section.\nCalendar MCP üìÖ: Scheduling hub for checking availability, creating, rescheduling, and deleting events.\nSticky Note3 in the calendar management block.\nTask Manager MCP ‚úÖ: Manages to-dos with create, complete, delete, retrieve functionality.\nSticky Note2 in the task management area.\nFinance Manager MCP üíµ: Tracks personal/business expenses with create, retrieve, delete operations.\nSticky Note5 in the finance tracking block.\nGoogle Contacts MCP üë•: Access and manage contact list for quick communication.\nSticky Note6 in the contacts management block.\nTelegram Bot used as primary user interface for conversational input and output including audio support.\nTelegram Trigger and related Telegram nodes.\nElevenLabs API used for speech-to-text and text-to-speech conversion to support audio interactions.\nNodes: Transcribe audio or video, Convert text to speech.\nOpenAI GPT-4.1-mini model powers AI reasoning and natural language processing.\nOpenAI Chat Model node with credentials.\nThis detailed documentation enables understanding, modification, and full reconstruction of the Jarvis productivity assistant workflow in n8n. It covers all nodes, configurations, integration points, potential failure modes, and logical flow, supporting both human users and AI agents in advanced usage scenarios.\nCopied to clipboard\n\n",
      "category": "CRM",
      "complexity": "Advanced",
      "tags_en": [],
      "tags_fr": [],
      "author": "Jitesh Dugar",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/jarvis-productivity-ai-agent-for-tasks-calendar-email-expense-using-mcps-8500",
      "nodes_count": 52
    },
    {
      "id": "012",
      "slug": "crez-des-vidos-virales-ia-laide-de-nanobanana-2-pro-et-veo31-et-publiez-les-via-blotato",
      "title_en": "Create AI Viral Videos using NanoBanana 2 PRO & VEO3.1 and Publish via Blotato",
      "title_fr": "Cr√©ez des vid√©os virales IA √† l'aide de NanoBanana 2 PRO et VEO3.1 et publiez-les via Blotato",
      "description_short_en": "Effortlessly turn a Telegram message into viral AI videos with NanoBanana 2 PRO, VEO3.1 & Blotato‚Äîfully automated, multi-platform, and customizable.",
      "description_short_fr": "Transformez sans effort un message Telegram en vid√©os virales d'IA avec NanoBanana 2 PRO, VEO3.1 et Blotato, enti√®rement automatis√©s, multiplateformes et personnalisables.",
      "description_full_en": "Create AI Viral Videos using NanoBanana 2 PRO & VEO3.1 and Publish via Blotato\n1. Workflow Overview\nThis workflow automates the creation and multi-platform publishing of AI-generated viral videos using NanoBanana 2 PRO and VEO3.1, triggered by a Telegram message containing a video idea and reference image. It proceeds through three main logical blocks:\n1.1 Input Reception and Preparation:\nReceives the video idea and reference image from Telegram, retrieves and analyzes the image, and sets up master prompts and tokens.\n1.2 AI Content Generation and Media Creation:\nGenerates structured video and image prompts using OpenAI models and LangChain agents, creates an edited image with NanoBanana 2 PRO, generates a video via VEO3.1 based on the prompts and image, and prepares the final video for delivery.\n1.3 Multi-Platform Publishing and Notification:\nUploads the produced video to Blotato and publishes it to multiple social media platforms (YouTube, TikTok, Instagram, LinkedIn, Facebook, Twitter/X), followed by sending confirmation messages via Telegram.\n2. Block-by-Block Analysis\n2.1 Input Reception and Preparation\nOverview:\nThis block listens for user input on Telegram, retrieves the submitted image, analyzes it with AI to extract descriptive metadata, and prepares master prompts and tokens to be used downstream.\nNodes Involved:\nTelegram Trigger: Receive Video Idea\nSet: Bot Token (Placeholder)\nTelegram API: Get File URL\nOpenAI Vision: Analyze Reference Image\nSet Master Prompt\nNode Details:\nTelegram Trigger: Receive Video Idea\nType: Telegram Webhook Trigger\nRole: Receives incoming messages (updates) from Telegram users, including video ideas with images and captions.\nConfig: Triggers on message updates only. Uses Telegram API credentials.\nInputs: External Telegram message event.\nOutputs: Message content including caption and photo array.\nEdge Cases: Input message without photo or caption may cause downstream failures. Telegram API rate limits or connectivity issues possible.\nSet: Bot Token (Placeholder)\nType: Set node\nRole: Stores placeholders for Telegram Bot Token, FAL API key, and caption extracted from Telegram message.\nConfig: Assigns\nYOUR_BOT_TOKEN\n,\nfal_api_key\n, and\nCAPTION\nvariables.\nCAPTION\ndynamically set from Telegram message caption.\nInputs: Telegram message JSON.\nOutputs: JSON with tokens and caption for further use.\nEdge Cases: Tokens must be replaced with actual credentials; missing tokens cause API request failures.\nTelegram API: Get File URL\nType: HTTP Request\nRole: Retrieves the direct file path URL for the last photo in the Telegram message.\nConfig: Uses Telegram Bot Token to call\ngetFile\nendpoint with the file_id of the last photo in array.\nInputs: JSON with\nYOUR_BOT_TOKEN\nand Telegram message photo array.\nOutputs: JSON containing the\nfile_path\nused to access the image.\nEdge Cases: Invalid token or file_id causes API error; missing photo array causes failure.\nOpenAI Vision: Analyze Reference Image\nType: LangChain OpenAI Image Analysis node\nRole: Analyzes the retrieved reference image and outputs a YAML description with details about product or character visible in the image.\nConfig: Uses GPT-4o model, outputs YAML only, no explanation text.\nInputs: Image URL constructed from Telegram file_path and Bot Token.\nOutputs: YAML string describing color schemes, brand, outfit style, and visual description.\nEdge Cases: Image URL invalid or inaccessible; OCR/vision model misinterpretation; rate limits or timeouts.\nSet Master Prompt\nType: Set node\nRole: Defines a detailed JSON schema template called\njson_master\nfor structured video ad prompt generation.\nConfig: Contains rich schema with fields for description, style, camera, lighting, environment, motion, VFX, audio, ending, text, format, and keywords.\nInputs: Triggered after image download.\nOutputs: JSON variable\njson_master\npassed to AI prompt generator.\nEdge Cases: Misconfiguration or invalid JSON could cause parsing failures downstream.\n2.2 AI Content Generation and Media Creation\nOverview:\nThis block generates natural language prompts for image and video creation using AI agents; creates the edited image with NanoBanana 2 PRO; generates the video using VEO3.1; and prepares the outputs for publishing.\nNodes Involved:\nGenerate Image Prompt\nNanoBanana: Create Image\nWait for Image Edit\nDownload Edited Image\nAI Agent: Generate Video Script\nParse GPT Response\nOptimize Prompt for Veo\nPrepare Veo Request Body\nVeo Generation\nWait\nDownload Video\nLLM: OpenAI Chat\nLLM: Structured Output Parser\nNode Details:\nGenerate Image Prompt\nType: LangChain Agent node\nRole: Generates a concise, realistic UGC-style image prompt based on the user description (caption) and the analyzed reference image YAML.\nConfig: System prompt enforces JSON-only output with\nimage_prompt\nkey, tone casual and lifelike, max 120 words, includes camera cues and text accuracy.\nInputs: Caption from Telegram and YAML from image analysis.\nOutputs: JSON with\nimage_prompt\nstring.\nEdge Cases: AI model may misinterpret or output invalid JSON; missing inputs cause failure.\nNanoBanana: Create Image\nType: HTTP Request\nRole: Sends the generated image prompt and reference image URL to NanoBanana 2 PRO API to create an edited image (1K resolution, 9:16 aspect ratio).\nConfig: POST request with JSON body including escaped image prompt and image URLs; authorization header uses FAL API key.\nInputs: JSON from Generate Image Prompt.\nOutputs: JSON with response URL to edited image.\nEdge Cases: API downtime, invalid API key, malformed request, rate limit.\nWait for Image Edit\nType: Wait node\nRole: Pauses workflow 2 seconds to allow image processing to complete on NanoBanana server.\nConfig: Fixed 2 seconds delay.\nInputs: After NanoBanana image request.\nOutputs: Passes control downstream.\nEdge Cases: Delay may be insufficient if image processing takes longer; no error detection.\nDownload Edited Image\nType: HTTP Request\nRole: Downloads the edited image from the NanoBanana API using the response URL.\nConfig: GET request to the URL provided by NanoBanana.\nInputs: Response URL from NanoBanana.\nOutputs: JSON containing image URLs for video generation.\nEdge Cases: Network issues, invalid URL, timeout.\nAI Agent: Generate Video Script\nType: LangChain Agent node\nRole: Generates a structured JSON video prompt including\nprompt\n,\ncaption\n,\ntitle\n, and\nhashtags\nbased on the user description and image analysis content, following a detailed master schema.\nConfig: Uses GPT-4.1-mini model, with strict output constraints (valid JSON only, escaped strings).\nInputs: Master prompt JSON, user caption, and image analysis data.\nOutputs: JSON with video script content.\nEdge Cases: Model output not JSON, invalid formatting, API errors.\nParse GPT Response\nType: Code node\nRole: Parses and normalizes the AI-generated video script JSON to extract title, prompt, caption, and hashtags (array and string form), handling legacy and new formats.\nConfig: JavaScript code with robust parsing and fallback logic.\nInputs: AI Agent output JSON.\nOutputs: Clean JSON fields for downstream use.\nEdge Cases: Unexpected AI response format, JSON parse errors.\nOptimize Prompt for Veo\nType: Set node\nRole: Appends fixed cinematic style instructions and technical details (duration, aspect ratio, fps) to the video prompt for VEO3.1 compatibility.\nConfig: Adds \"consistent character throughout, photorealistic quality, professional cinematography, 8 seconds duration, 9:16 aspect ratio, 24fps\" to prompt string.\nInputs: Parsed prompt.\nOutputs:\nveo_prompt\nfield alongside other data.\nEdge Cases: Empty or invalid prompt causes issues downstream.\nPrepare Veo Request Body\nType: Code node\nRole: Constructs the JSON request body for VEO API, including the optimized prompt and the edited image URL from NanoBanana output.\nConfig: Validates presence and format of prompt and image URL before building request body with duration and aspect ratio.\nInputs:\nveo_prompt\nand edited image URL.\nOutputs: JSON with\nveo_request_body\n.\nEdge Cases: Missing prompt or image URL throws error, halting workflow.\nVeo Generation\nType: HTTP Request\nRole: Sends the video prompt and image URLs to VEO3.1 API to generate a vertical AI video (up to 8 seconds).\nConfig: POST JSON request with authorization header (FAL API key), 10-minute timeout.\nInputs: JSON\nveo_request_body\n.\nOutputs: JSON response with video URL and metadata.\nEdge Cases: API timeout, authorization error, invalid request.\nWait\nType: Wait node\nRole: Pauses 2 seconds post video generation request for processing time.\nConfig: Fixed delay.\nInputs: After video generation request.\nOutputs: Passes control downstream.\nEdge Cases: Fixed delay may not cover longer processing.\nDownload Video\nType: HTTP Request\nRole: Downloads the generated video file from the VEO response URL for local or downstream use.\nConfig: GET request, expects file response format.\nInputs: Video URL from VEO generation.\nOutputs: Binary video data and metadata.\nEdge Cases: Network issues, invalid video URL.\nLLM: OpenAI Chat\nType: LangChain OpenAI Chat node\nRole: Supports generation of intermediate text outputs (likely connected to image prompt generation).\nConfig: Uses GPT-4.1-mini model.\nInputs: Receives system message and user prompt from upstream.\nOutputs: Text response parsed by next node.\nEdge Cases: API limits, improper prompt.\nLLM: Structured Output Parser\nType: Output parser node for LangChain\nRole: Parses raw LLM output into structured JSON using example schema.\nConfig: Example schema for image prompt JSON with\nimage_prompt\nkey.\nInputs: Raw LLM chat output.\nOutputs: Parsed JSON object.\nEdge Cases: Parsing errors if output not in expected format.\n2.3 Multi-Platform Publishing and Notification\nOverview:\nThis block uploads the final AI-generated video to Blotato and publishes it automatically across multiple social platforms, followed by confirmation messages to the user on Telegram.\nNodes Involved:\nSend Video to Telegram\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nMerge1\nSend a text message\nSticky Notes (informative)\nNode Details:\nSend Video to Telegram\nType: Telegram node\nRole: Sends the generated video back to the Telegram chat with a caption including the video URL.\nConfig: Uses Telegram credentials, sends video as binary data, dynamic chat ID from trigger.\nInputs: Binary video data from Download Video node.\nOutputs: Telegram message confirmation JSON.\nEdge Cases: Telegram API limits, video size constraints.\nUpload Video to BLOTATO\nType: Blotato node (media resource)\nRole: Uploads the downloaded video to Blotato platform for social publishing.\nConfig: Uses Blotato API credentials, mediaUrl set from downloaded video URL.\nInputs: Video URL from Download Video.\nOutputs: Media upload response with URLs.\nEdge Cases: API key invalid, upload failure, network issues.\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\nType: Blotato nodes, each for a social platform\nRole: Publishes the uploaded video media with text captions to respective platforms.\nConfig: Each node configured with platform-specific account ID, post text from parsed GPT caption, media URLs from Blotato upload, and platform-specific options (e.g., YouTube privacy set to private).\nInputs: Media URLs and captions from Upload Video to BLOTATO and Parse GPT Response nodes.\nOutputs: Posting confirmation JSON.\nEdge Cases: Platform API limits, authentication errors, content policy restrictions.\nMerge1\nType: Merge node with chooseBranch mode\nRole: Collects outputs from all social media publishing nodes to synchronize downstream confirmation.\nConfig: Awaits all 6 inputs before continuing.\nInputs: Outputs from all social platform nodes.\nOutputs: Merged data for notification.\nEdge Cases: One platform failing blocks confirmation.\nSend a text message\nType: Telegram node\nRole: Sends a simple \"Published\" confirmation message to the original Telegram chat.\nConfig: Dynamic chat ID, static text message.\nInputs: Merged node output indicating all posts done.\nOutputs: Confirmation message JSON.\nEdge Cases: Telegram API failure.\nSticky Notes\nProvide contextual labels for each major step:\nStep 1: Image creation with NanoBanana 2 PRO\nStep 2: Video generation with VEO3.1\nStep 3: Multi-platform publishing with Blotato\nOne sticky note includes documentation links and branding info.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger: Receive Video Idea\nTelegram Trigger\nInput reception from Telegram\n‚Äî\nSet: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Create Image with NanoBanana 2 PRO\nSet: Bot Token (Placeholder)\nSet\nSet API tokens and caption variable\nTelegram Trigger: Receive Video Idea\nTelegram API: Get File URL\nTelegram API: Get File URL\nHTTP Request\nGet Telegram image file URL\nSet: Bot Token (Placeholder)\nOpenAI Vision: Analyze Reference Image\nOpenAI Vision: Analyze Reference Image\nLangChain OpenAI Vision\nAnalyze image content to YAML description\nTelegram API: Get File URL\nGenerate Image Prompt\nGenerate Image Prompt\nLangChain Agent\nGenerate realistic UGC image prompt\nOpenAI Vision: Analyze Reference Image\nNanoBanana: Create Image\nNanoBanana: Create Image\nHTTP Request\nCreate edited image with NanoBanana 2 PRO\nGenerate Image Prompt\nWait for Image Edit\nWait for Image Edit\nWait\nPause for image processing\nNanoBanana: Create Image\nDownload Edited Image\nDownload Edited Image\nHTTP Request\nDownload edited image from NanoBanana\nWait for Image Edit\nSet Master Prompt\nSet Master Prompt\nSet\nDefine master prompt JSON schema\nDownload Edited Image\nAI Agent: Generate Video Script\nOpenAI Chat Model\nLangChain OpenAI Chat\nLanguage model for video script generation\nSet Master Prompt\nThink\nThink\nLangChain Tool (Think)\nAI thinking tool for intermediate processing\nOpenAI Chat Model\nAI Agent: Generate Video Script\nStructured Output Parser\nLangChain Output Parser\nParse structured AI output\nThink\nAI Agent: Generate Video Script\nAI Agent: Generate Video Script\nLangChain Agent\nGenerate structured video prompt JSON\nStructured Output Parser, OpenAI Chat Model\nParse GPT Response\nParse GPT Response\nCode\nParse and normalize video script JSON\nAI Agent: Generate Video Script\nOptimize Prompt for Veo\nOptimize Prompt for Veo\nSet\nEnhance prompt with cinematic instructions\nParse GPT Response\nPrepare Veo Request Body\nPrepare Veo Request Body\nCode\nBuild VEO3.1 API request body\nOptimize Prompt for Veo\nVeo Generation\nVeo Generation\nHTTP Request\nGenerate video from prompt and image\nPrepare Veo Request Body\nWait\nWait\nWait\nPause for video generation processing\nVeo Generation\nDownload Video\nDownload Video\nHTTP Request\nDownload generated video file\nWait\nSend Video to Telegram\nSend Video to Telegram\nTelegram\nSend generated video back to Telegram user\nDownload Video\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato\nUpload video to Blotato platform\nSend Video to Telegram\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\n# üìë STEP 3 ‚Äî Publish with Blotato\nTiktok\nBlotato\nPublish video on TikTok\nUpload Video to BLOTATO\nMerge1\nLinkedin\nBlotato\nPublish video on LinkedIn\nUpload Video to BLOTATO\nMerge1\nFacebook\nBlotato\nPublish video on Facebook\nUpload Video to BLOTATO\nMerge1\nInstagram\nBlotato\nPublish video on Instagram\nUpload Video to BLOTATO\nMerge1\nTwitter (X)\nBlotato\nPublish video on Twitter (X)\nUpload Video to BLOTATO\nMerge1\nYoutube\nBlotato\nPublish video on YouTube\nUpload Video to BLOTATO\nMerge1\nMerge1\nMerge\nSynchronize multi-platform publishing output\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\nSend a text message\nSend a text message\nTelegram\nNotify Telegram user of publication completion\nMerge1\n‚Äî\nSticky Note\nSticky Note\nWorkflow step label and documentation links\n‚Äî\n‚Äî\n# üöÄ AI Viral Video Workflow ‚Äî NanoBanana 2 PRO √ó VEO3.1 √ó Blotato (By Dr. Firas)\\n\\n\n\\n\\n## üìò Documentation  \\nAccess detailed setup instructions, API config, platform connection guides, and workflow customization tips:\\n\\nüìé\nOpen the full documentation on Notion\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger: Receive Video Idea\nNode Type: Telegram Trigger\nConfig: Listen for\nmessage\nupdates only. Use Telegram API credentials.\nPurpose: Receive user message with photo and caption.\nCreate Set node: Set Bot Token (Placeholder)\nNode Type: Set\nAssign variables:\nYOUR_BOT_TOKEN\n: your Telegram bot token (string).\nfal_api_key\n: your FAL API key (string).\nCAPTION\n: expression\n={{ $('Telegram Trigger: Receive Video Idea').item.json.message.caption }}\n.\nCreate HTTP Request: Telegram API: Get File URL\nNode Type: HTTP Request\nMethod: GET\nURL:\nhttps://api.telegram.org/bot{{ $json.YOUR_BOT_TOKEN }}/getFile?file_id={{ $('Telegram Trigger: Receive Video Idea').item.json.message.photo[ $('Telegram Trigger: Receive Video Idea').item.json.message.photo.length - 1].file_id }}\nUse credentials from Step 2.\nPurpose: Retrieve file path for last photo.\nCreate OpenAI Vision: Analyze Reference Image\nNode Type: LangChain OpenAI\nModel:\nchatgpt-4o-latest\nInput: Image URL constructed as\nhttps://api.telegram.org/file/bot{{ $json.YOUR_BOT_TOKEN }}/{{ $json.result.file_path }}\nPrompt: YAML-only analysis as per detailed specifications (product and character analysis).\nUse OpenAI credentials.\nCreate LangChain Agent: Generate Image Prompt\nNode Type: LangChain Agent\nSystem prompt: UGC Image Prompt Builder with strict JSON output for\nimage_prompt\n.\nInputs: User caption and image analysis YAML.\nOutput parser: LangChain Structured Output Parser with schema\n{ \"image_prompt\": \"string\" }\n.\nCreate HTTP Request: NanoBanana: Create Image\nNode Type: HTTP Request\nMethod: POST\nURL:\nhttps://queue.fal.run/fal-ai/nano-banana-pro/edit\nHeaders:\nContent-Type: application/json\n,\nAuthorization: Key {{ $json.fal_api_key }}\nBody: JSON including escaped\nimage_prompt\n, Telegram image URL, resolution 1K, aspect ratio 9:16, output_format png.\nCreate Wait node: Wait for Image Edit\nNode Type: Wait\nDuration: 2 seconds\nPurpose: Allow NanoBanana image processing time.\nCreate HTTP Request: Download Edited Image\nNode Type: HTTP Request\nURL: Use\nresponse_url\nfrom NanoBanana create image response.\nMethod: GET\nCreate Set node: Set Master Prompt\nNode Type: Set\nAssign variable\njson_master\nwith detailed video prompt schema JSON for video generation.\nCreate LangChain OpenAI Chat node: OpenAI Chat Model\nModel:\ngpt-4.1-mini\nPurpose: Support AI video script generation.\nCreate LangChain Tool Think node: Think\nPurpose: Intermediate AI tool step.\nCreate LangChain Output Parser: Structured Output Parser\nSchema example JSON for video prompt\n{ prompt, caption, title, hashtags }\n.\nCreate LangChain Agent: AI Agent: Generate Video Script\nUses previous nodes for input and output parsing.\nSystem prompt enforces structured video prompt generation with strict JSON output.\nCreate Code node: Parse GPT Response\nJavaScript to parse AI response to normalized fields:\ntitle\n,\nprompt\n,\ncaption\n,\nhashtags\n(array and string).\nCreate Set node: Optimize Prompt for Veo\nAppend cinematic style, duration, aspect ratio, fps to prompt string as\nveo_prompt\n.\nCreate Code node: Prepare Veo Request Body\nValidate\nveo_prompt\nand edited image URL, create JSON body for VEO API with prompt, image URLs, duration (8s), aspect ratio (9:16).\nCreate HTTP Request: Veo Generation\nMethod: POST\nURL:\nhttps://fal.run/fal-ai/veo3.1/reference-to-video\nHeaders: Authorization with FAL API key, Content-Type application/json\nBody:\nveo_request_body\nJSON\nTimeout: 600 seconds\nCreate Wait node: Wait\nDuration: 2 seconds\nPurpose: Wait for video generation processing.\nCreate HTTP Request: Download Video\nMethod: GET\nURL: Video URL from VEO response\nResponse format: file (binary)\nCreate Telegram node: Send Video to Telegram\nOperation: sendVideo\nChat ID: from original Telegram trigger message\nCaption: \"Your video is ready! üé• {{video url}}\"\nSend video as binary data.\nCreate Blotato node: Upload Video to BLOTATO\nMedia URL: from downloaded video URL\nUse Blotato API credentials.\nCreate Blotato nodes for each social platform\nPlatforms: TikTok, LinkedIn, Facebook, Instagram, Twitter (X), YouTube\nConfigure each with account IDs, post text (caption from Parse GPT Response), media URLs from upload node\nYouTube post privacy set to private, no subscriber notifications.\nCreate Merge node: Merge1\nMode: chooseBranch\nNumber inputs: 6 (one per social platform)\nPurpose: Synchronize publishing completion.\nCreate Telegram node: Send a text message\nText: \"Published\"\nChat ID: from Telegram trigger message\nTriggered after Merge1 node.\nAdd Sticky Notes\nAdd descriptive sticky notes for Steps 1, 2, 3 with color coding and documentation link as in original workflow.\n5. General Notes & Resources\nNote Content\nContext or Link\nAI Viral Video Workflow ‚Äî NanoBanana 2 PRO √ó VEO3.1 √ó Blotato by Dr. Firas\nBranding and workflow origin\nPreview video and documentation:\nYouTube Preview\nVideo preview of workflow in action\nFull setup and documentation:\nNotion Documentation\nDetailed instructions, API setup, and customization tips\nBlotato account required with Pro plan and API key\nhttps://blotato.com/?ref=firas\nEnsure ‚ÄúVerified Community Nodes‚Äù are enabled in n8n admin settings for Blotato nodes\nn8n platform configuration\nUse valid OpenAI API and Telegram Bot credentials\nAPI credentials management\nDisclaimer:\nThe provided text originates exclusively from an n8n automated workflow. It complies fully with all applicable content policies and contains no illegal, offensive, or protected content. All data handled is legal and public.\nCopied to clipboard",
      "description_full_fr": "Create AI Viral Videos using NanoBanana 2 PRO & VEO3.1 and Publish via Blotato\n1. Workflow Overview\nThis workflow automates the creation and multi-platform publishing of AI-generated viral videos using NanoBanana 2 PRO and VEO3.1, triggered by a Telegram message containing a video idea and reference image. It proceeds through three main logical blocks:\n1.1 Input Reception and Preparation:\nReceives the video idea and reference image from Telegram, retrieves and analyzes the image, and sets up master prompts and tokens.\n1.2 AI Content Generation and Media Creation:\nGenerates structured video and image prompts using OpenAI models and LangChain agents, creates an edited image with NanoBanana 2 PRO, generates a video via VEO3.1 based on the prompts and image, and prepares the final video for delivery.\n1.3 Multi-Platform Publishing and Notification:\nUploads the produced video to Blotato and publishes it to multiple social media platforms (YouTube, TikTok, Instagram, LinkedIn, Facebook, Twitter/X), followed by sending confirmation messages via Telegram.\n2. Block-by-Block Analysis\n2.1 Input Reception and Preparation\nOverview:\nThis block listens for user input on Telegram, retrieves the submitted image, analyzes it with AI to extract descriptive metadata, and prepares master prompts and tokens to be used downstream.\nNodes Involved:\nTelegram Trigger: Receive Video Idea\nSet: Bot Token (Placeholder)\nTelegram API: Get File URL\nOpenAI Vision: Analyze Reference Image\nSet Master Prompt\nNode Details:\nTelegram Trigger: Receive Video Idea\nType: Telegram Webhook Trigger\nRole: Receives incoming messages (updates) from Telegram users, including video ideas with images and captions.\nConfig: Triggers on message updates only. Uses Telegram API credentials.\nInputs: External Telegram message event.\nOutputs: Message content including caption and photo array.\nEdge Cases: Input message without photo or caption may cause downstream failures. Telegram API rate limits or connectivity issues possible.\nSet: Bot Token (Placeholder)\nType: Set node\nRole: Stores placeholders for Telegram Bot Token, FAL API key, and caption extracted from Telegram message.\nConfig: Assigns\nYOUR_BOT_TOKEN\n,\nfal_api_key\n, and\nCAPTION\nvariables.\nCAPTION\ndynamically set from Telegram message caption.\nInputs: Telegram message JSON.\nOutputs: JSON with tokens and caption for further use.\nEdge Cases: Tokens must be replaced with actual credentials; missing tokens cause API request failures.\nTelegram API: Get File URL\nType: HTTP Request\nRole: Retrieves the direct file path URL for the last photo in the Telegram message.\nConfig: Uses Telegram Bot Token to call\ngetFile\nendpoint with the file_id of the last photo in array.\nInputs: JSON with\nYOUR_BOT_TOKEN\nand Telegram message photo array.\nOutputs: JSON containing the\nfile_path\nused to access the image.\nEdge Cases: Invalid token or file_id causes API error; missing photo array causes failure.\nOpenAI Vision: Analyze Reference Image\nType: LangChain OpenAI Image Analysis node\nRole: Analyzes the retrieved reference image and outputs a YAML description with details about product or character visible in the image.\nConfig: Uses GPT-4o model, outputs YAML only, no explanation text.\nInputs: Image URL constructed from Telegram file_path and Bot Token.\nOutputs: YAML string describing color schemes, brand, outfit style, and visual description.\nEdge Cases: Image URL invalid or inaccessible; OCR/vision model misinterpretation; rate limits or timeouts.\nSet Master Prompt\nType: Set node\nRole: Defines a detailed JSON schema template called\njson_master\nfor structured video ad prompt generation.\nConfig: Contains rich schema with fields for description, style, camera, lighting, environment, motion, VFX, audio, ending, text, format, and keywords.\nInputs: Triggered after image download.\nOutputs: JSON variable\njson_master\npassed to AI prompt generator.\nEdge Cases: Misconfiguration or invalid JSON could cause parsing failures downstream.\n2.2 AI Content Generation and Media Creation\nOverview:\nThis block generates natural language prompts for image and video creation using AI agents; creates the edited image with NanoBanana 2 PRO; generates the video using VEO3.1; and prepares the outputs for publishing.\nNodes Involved:\nGenerate Image Prompt\nNanoBanana: Create Image\nWait for Image Edit\nDownload Edited Image\nAI Agent: Generate Video Script\nParse GPT Response\nOptimize Prompt for Veo\nPrepare Veo Request Body\nVeo Generation\nWait\nDownload Video\nLLM: OpenAI Chat\nLLM: Structured Output Parser\nNode Details:\nGenerate Image Prompt\nType: LangChain Agent node\nRole: Generates a concise, realistic UGC-style image prompt based on the user description (caption) and the analyzed reference image YAML.\nConfig: System prompt enforces JSON-only output with\nimage_prompt\nkey, tone casual and lifelike, max 120 words, includes camera cues and text accuracy.\nInputs: Caption from Telegram and YAML from image analysis.\nOutputs: JSON with\nimage_prompt\nstring.\nEdge Cases: AI model may misinterpret or output invalid JSON; missing inputs cause failure.\nNanoBanana: Create Image\nType: HTTP Request\nRole: Sends the generated image prompt and reference image URL to NanoBanana 2 PRO API to create an edited image (1K resolution, 9:16 aspect ratio).\nConfig: POST request with JSON body including escaped image prompt and image URLs; authorization header uses FAL API key.\nInputs: JSON from Generate Image Prompt.\nOutputs: JSON with response URL to edited image.\nEdge Cases: API downtime, invalid API key, malformed request, rate limit.\nWait for Image Edit\nType: Wait node\nRole: Pauses workflow 2 seconds to allow image processing to complete on NanoBanana server.\nConfig: Fixed 2 seconds delay.\nInputs: After NanoBanana image request.\nOutputs: Passes control downstream.\nEdge Cases: Delay may be insufficient if image processing takes longer; no error detection.\nDownload Edited Image\nType: HTTP Request\nRole: Downloads the edited image from the NanoBanana API using the response URL.\nConfig: GET request to the URL provided by NanoBanana.\nInputs: Response URL from NanoBanana.\nOutputs: JSON containing image URLs for video generation.\nEdge Cases: Network issues, invalid URL, timeout.\nAI Agent: Generate Video Script\nType: LangChain Agent node\nRole: Generates a structured JSON video prompt including\nprompt\n,\ncaption\n,\ntitle\n, and\nhashtags\nbased on the user description and image analysis content, following a detailed master schema.\nConfig: Uses GPT-4.1-mini model, with strict output constraints (valid JSON only, escaped strings).\nInputs: Master prompt JSON, user caption, and image analysis data.\nOutputs: JSON with video script content.\nEdge Cases: Model output not JSON, invalid formatting, API errors.\nParse GPT Response\nType: Code node\nRole: Parses and normalizes the AI-generated video script JSON to extract title, prompt, caption, and hashtags (array and string form), handling legacy and new formats.\nConfig: JavaScript code with robust parsing and fallback logic.\nInputs: AI Agent output JSON.\nOutputs: Clean JSON fields for downstream use.\nEdge Cases: Unexpected AI response format, JSON parse errors.\nOptimize Prompt for Veo\nType: Set node\nRole: Appends fixed cinematic style instructions and technical details (duration, aspect ratio, fps) to the video prompt for VEO3.1 compatibility.\nConfig: Adds \"consistent character throughout, photorealistic quality, professional cinematography, 8 seconds duration, 9:16 aspect ratio, 24fps\" to prompt string.\nInputs: Parsed prompt.\nOutputs:\nveo_prompt\nfield alongside other data.\nEdge Cases: Empty or invalid prompt causes issues downstream.\nPrepare Veo Request Body\nType: Code node\nRole: Constructs the JSON request body for VEO API, including the optimized prompt and the edited image URL from NanoBanana output.\nConfig: Validates presence and format of prompt and image URL before building request body with duration and aspect ratio.\nInputs:\nveo_prompt\nand edited image URL.\nOutputs: JSON with\nveo_request_body\n.\nEdge Cases: Missing prompt or image URL throws error, halting workflow.\nVeo Generation\nType: HTTP Request\nRole: Sends the video prompt and image URLs to VEO3.1 API to generate a vertical AI video (up to 8 seconds).\nConfig: POST JSON request with authorization header (FAL API key), 10-minute timeout.\nInputs: JSON\nveo_request_body\n.\nOutputs: JSON response with video URL and metadata.\nEdge Cases: API timeout, authorization error, invalid request.\nWait\nType: Wait node\nRole: Pauses 2 seconds post video generation request for processing time.\nConfig: Fixed delay.\nInputs: After video generation request.\nOutputs: Passes control downstream.\nEdge Cases: Fixed delay may not cover longer processing.\nDownload Video\nType: HTTP Request\nRole: Downloads the generated video file from the VEO response URL for local or downstream use.\nConfig: GET request, expects file response format.\nInputs: Video URL from VEO generation.\nOutputs: Binary video data and metadata.\nEdge Cases: Network issues, invalid video URL.\nLLM: OpenAI Chat\nType: LangChain OpenAI Chat node\nRole: Supports generation of intermediate text outputs (likely connected to image prompt generation).\nConfig: Uses GPT-4.1-mini model.\nInputs: Receives system message and user prompt from upstream.\nOutputs: Text response parsed by next node.\nEdge Cases: API limits, improper prompt.\nLLM: Structured Output Parser\nType: Output parser node for LangChain\nRole: Parses raw LLM output into structured JSON using example schema.\nConfig: Example schema for image prompt JSON with\nimage_prompt\nkey.\nInputs: Raw LLM chat output.\nOutputs: Parsed JSON object.\nEdge Cases: Parsing errors if output not in expected format.\n2.3 Multi-Platform Publishing and Notification\nOverview:\nThis block uploads the final AI-generated video to Blotato and publishes it automatically across multiple social platforms, followed by confirmation messages to the user on Telegram.\nNodes Involved:\nSend Video to Telegram\nUpload Video to BLOTATO\nTiktok\nLinkedin\nFacebook\nInstagram\nTwitter (X)\nYoutube\nMerge1\nSend a text message\nSticky Notes (informative)\nNode Details:\nSend Video to Telegram\nType: Telegram node\nRole: Sends the generated video back to the Telegram chat with a caption including the video URL.\nConfig: Uses Telegram credentials, sends video as binary data, dynamic chat ID from trigger.\nInputs: Binary video data from Download Video node.\nOutputs: Telegram message confirmation JSON.\nEdge Cases: Telegram API limits, video size constraints.\nUpload Video to BLOTATO\nType: Blotato node (media resource)\nRole: Uploads the downloaded video to Blotato platform for social publishing.\nConfig: Uses Blotato API credentials, mediaUrl set from downloaded video URL.\nInputs: Video URL from Download Video.\nOutputs: Media upload response with URLs.\nEdge Cases: API key invalid, upload failure, network issues.\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\nType: Blotato nodes, each for a social platform\nRole: Publishes the uploaded video media with text captions to respective platforms.\nConfig: Each node configured with platform-specific account ID, post text from parsed GPT caption, media URLs from Blotato upload, and platform-specific options (e.g., YouTube privacy set to private).\nInputs: Media URLs and captions from Upload Video to BLOTATO and Parse GPT Response nodes.\nOutputs: Posting confirmation JSON.\nEdge Cases: Platform API limits, authentication errors, content policy restrictions.\nMerge1\nType: Merge node with chooseBranch mode\nRole: Collects outputs from all social media publishing nodes to synchronize downstream confirmation.\nConfig: Awaits all 6 inputs before continuing.\nInputs: Outputs from all social platform nodes.\nOutputs: Merged data for notification.\nEdge Cases: One platform failing blocks confirmation.\nSend a text message\nType: Telegram node\nRole: Sends a simple \"Published\" confirmation message to the original Telegram chat.\nConfig: Dynamic chat ID, static text message.\nInputs: Merged node output indicating all posts done.\nOutputs: Confirmation message JSON.\nEdge Cases: Telegram API failure.\nSticky Notes\nProvide contextual labels for each major step:\nStep 1: Image creation with NanoBanana 2 PRO\nStep 2: Video generation with VEO3.1\nStep 3: Multi-platform publishing with Blotato\nOne sticky note includes documentation links and branding info.\n3. Summary Table\nNode Name\nNode Type\nFunctional Role\nInput Node(s)\nOutput Node(s)\nSticky Note\nTelegram Trigger: Receive Video Idea\nTelegram Trigger\nInput reception from Telegram\n‚Äî\nSet: Bot Token (Placeholder)\n# üìë STEP 1 ‚Äî Create Image with NanoBanana 2 PRO\nSet: Bot Token (Placeholder)\nSet\nSet API tokens and caption variable\nTelegram Trigger: Receive Video Idea\nTelegram API: Get File URL\nTelegram API: Get File URL\nHTTP Request\nGet Telegram image file URL\nSet: Bot Token (Placeholder)\nOpenAI Vision: Analyze Reference Image\nOpenAI Vision: Analyze Reference Image\nLangChain OpenAI Vision\nAnalyze image content to YAML description\nTelegram API: Get File URL\nGenerate Image Prompt\nGenerate Image Prompt\nLangChain Agent\nGenerate realistic UGC image prompt\nOpenAI Vision: Analyze Reference Image\nNanoBanana: Create Image\nNanoBanana: Create Image\nHTTP Request\nCreate edited image with NanoBanana 2 PRO\nGenerate Image Prompt\nWait for Image Edit\nWait for Image Edit\nWait\nPause for image processing\nNanoBanana: Create Image\nDownload Edited Image\nDownload Edited Image\nHTTP Request\nDownload edited image from NanoBanana\nWait for Image Edit\nSet Master Prompt\nSet Master Prompt\nSet\nDefine master prompt JSON schema\nDownload Edited Image\nAI Agent: Generate Video Script\nOpenAI Chat Model\nLangChain OpenAI Chat\nLanguage model for video script generation\nSet Master Prompt\nThink\nThink\nLangChain Tool (Think)\nAI thinking tool for intermediate processing\nOpenAI Chat Model\nAI Agent: Generate Video Script\nStructured Output Parser\nLangChain Output Parser\nParse structured AI output\nThink\nAI Agent: Generate Video Script\nAI Agent: Generate Video Script\nLangChain Agent\nGenerate structured video prompt JSON\nStructured Output Parser, OpenAI Chat Model\nParse GPT Response\nParse GPT Response\nCode\nParse and normalize video script JSON\nAI Agent: Generate Video Script\nOptimize Prompt for Veo\nOptimize Prompt for Veo\nSet\nEnhance prompt with cinematic instructions\nParse GPT Response\nPrepare Veo Request Body\nPrepare Veo Request Body\nCode\nBuild VEO3.1 API request body\nOptimize Prompt for Veo\nVeo Generation\nVeo Generation\nHTTP Request\nGenerate video from prompt and image\nPrepare Veo Request Body\nWait\nWait\nWait\nPause for video generation processing\nVeo Generation\nDownload Video\nDownload Video\nHTTP Request\nDownload generated video file\nWait\nSend Video to Telegram\nSend Video to Telegram\nTelegram\nSend generated video back to Telegram user\nDownload Video\nUpload Video to BLOTATO\nUpload Video to BLOTATO\nBlotato\nUpload video to Blotato platform\nSend Video to Telegram\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\n# üìë STEP 3 ‚Äî Publish with Blotato\nTiktok\nBlotato\nPublish video on TikTok\nUpload Video to BLOTATO\nMerge1\nLinkedin\nBlotato\nPublish video on LinkedIn\nUpload Video to BLOTATO\nMerge1\nFacebook\nBlotato\nPublish video on Facebook\nUpload Video to BLOTATO\nMerge1\nInstagram\nBlotato\nPublish video on Instagram\nUpload Video to BLOTATO\nMerge1\nTwitter (X)\nBlotato\nPublish video on Twitter (X)\nUpload Video to BLOTATO\nMerge1\nYoutube\nBlotato\nPublish video on YouTube\nUpload Video to BLOTATO\nMerge1\nMerge1\nMerge\nSynchronize multi-platform publishing output\nTiktok, Linkedin, Facebook, Instagram, Twitter (X), Youtube\nSend a text message\nSend a text message\nTelegram\nNotify Telegram user of publication completion\nMerge1\n‚Äî\nSticky Note\nSticky Note\nWorkflow step label and documentation links\n‚Äî\n‚Äî\n# üöÄ AI Viral Video Workflow ‚Äî NanoBanana 2 PRO √ó VEO3.1 √ó Blotato (By Dr. Firas)\\n\\n\n\\n\\n## üìò Documentation  \\nAccess detailed setup instructions, API config, platform connection guides, and workflow customization tips:\\n\\nüìé\nOpen the full documentation on Notion\n4. Reproducing the Workflow from Scratch\nCreate Telegram Trigger: Receive Video Idea\nNode Type: Telegram Trigger\nConfig: Listen for\nmessage\nupdates only. Use Telegram API credentials.\nPurpose: Receive user message with photo and caption.\nCreate Set node: Set Bot Token (Placeholder)\nNode Type: Set\nAssign variables:\nYOUR_BOT_TOKEN\n: your Telegram bot token (string).\nfal_api_key\n: your FAL API key (string).\nCAPTION\n: expression\n={{ $('Telegram Trigger: Receive Video Idea').item.json.message.caption }}\n.\nCreate HTTP Request: Telegram API: Get File URL\nNode Type: HTTP Request\nMethod: GET\nURL:\nhttps://api.telegram.org/bot{{ $json.YOUR_BOT_TOKEN }}/getFile?file_id={{ $('Telegram Trigger: Receive Video Idea').item.json.message.photo[ $('Telegram Trigger: Receive Video Idea').item.json.message.photo.length - 1].file_id }}\nUse credentials from Step 2.\nPurpose: Retrieve file path for last photo.\nCreate OpenAI Vision: Analyze Reference Image\nNode Type: LangChain OpenAI\nModel:\nchatgpt-4o-latest\nInput: Image URL constructed as\nhttps://api.telegram.org/file/bot{{ $json.YOUR_BOT_TOKEN }}/{{ $json.result.file_path }}\nPrompt: YAML-only analysis as per detailed specifications (product and character analysis).\nUse OpenAI credentials.\nCreate LangChain Agent: Generate Image Prompt\nNode Type: LangChain Agent\nSystem prompt: UGC Image Prompt Builder with strict JSON output for\nimage_prompt\n.\nInputs: User caption and image analysis YAML.\nOutput parser: LangChain Structured Output Parser with schema\n{ \"image_prompt\": \"string\" }\n.\nCreate HTTP Request: NanoBanana: Create Image\nNode Type: HTTP Request\nMethod: POST\nURL:\nhttps://queue.fal.run/fal-ai/nano-banana-pro/edit\nHeaders:\nContent-Type: application/json\n,\nAuthorization: Key {{ $json.fal_api_key }}\nBody: JSON including escaped\nimage_prompt\n, Telegram image URL, resolution 1K, aspect ratio 9:16, output_format png.\nCreate Wait node: Wait for Image Edit\nNode Type: Wait\nDuration: 2 seconds\nPurpose: Allow NanoBanana image processing time.\nCreate HTTP Request: Download Edited Image\nNode Type: HTTP Request\nURL: Use\nresponse_url\nfrom NanoBanana create image response.\nMethod: GET\nCreate Set node: Set Master Prompt\nNode Type: Set\nAssign variable\njson_master\nwith detailed video prompt schema JSON for video generation.\nCreate LangChain OpenAI Chat node: OpenAI Chat Model\nModel:\ngpt-4.1-mini\nPurpose: Support AI video script generation.\nCreate LangChain Tool Think node: Think\nPurpose: Intermediate AI tool step.\nCreate LangChain Output Parser: Structured Output Parser\nSchema example JSON for video prompt\n{ prompt, caption, title, hashtags }\n.\nCreate LangChain Agent: AI Agent: Generate Video Script\nUses previous nodes for input and output parsing.\nSystem prompt enforces structured video prompt generation with strict JSON output.\nCreate Code node: Parse GPT Response\nJavaScript to parse AI response to normalized fields:\ntitle\n,\nprompt\n,\ncaption\n,\nhashtags\n(array and string).\nCreate Set node: Optimize Prompt for Veo\nAppend cinematic style, duration, aspect ratio, fps to prompt string as\nveo_prompt\n.\nCreate Code node: Prepare Veo Request Body\nValidate\nveo_prompt\nand edited image URL, create JSON body for VEO API with prompt, image URLs, duration (8s), aspect ratio (9:16).\nCreate HTTP Request: Veo Generation\nMethod: POST\nURL:\nhttps://fal.run/fal-ai/veo3.1/reference-to-video\nHeaders: Authorization with FAL API key, Content-Type application/json\nBody:\nveo_request_body\nJSON\nTimeout: 600 seconds\nCreate Wait node: Wait\nDuration: 2 seconds\nPurpose: Wait for video generation processing.\nCreate HTTP Request: Download Video\nMethod: GET\nURL: Video URL from VEO response\nResponse format: file (binary)\nCreate Telegram node: Send Video to Telegram\nOperation: sendVideo\nChat ID: from original Telegram trigger message\nCaption: \"Your video is ready! üé• {{video url}}\"\nSend video as binary data.\nCreate Blotato node: Upload Video to BLOTATO\nMedia URL: from downloaded video URL\nUse Blotato API credentials.\nCreate Blotato nodes for each social platform\nPlatforms: TikTok, LinkedIn, Facebook, Instagram, Twitter (X), YouTube\nConfigure each with account IDs, post text (caption from Parse GPT Response), media URLs from upload node\nYouTube post privacy set to private, no subscriber notifications.\nCreate Merge node: Merge1\nMode: chooseBranch\nNumber inputs: 6 (one per social platform)\nPurpose: Synchronize publishing completion.\nCreate Telegram node: Send a text message\nText: \"Published\"\nChat ID: from Telegram trigger message\nTriggered after Merge1 node.\nAdd Sticky Notes\nAdd descriptive sticky notes for Steps 1, 2, 3 with color coding and documentation link as in original workflow.\n5. General Notes & Resources\nNote Content\nContext or Link\nAI Viral Video Workflow ‚Äî NanoBanana 2 PRO √ó VEO3.1 √ó Blotato by Dr. Firas\nBranding and workflow origin\nPreview video and documentation:\nYouTube Preview\nVideo preview of workflow in action\nFull setup and documentation:\nNotion Documentation\nDetailed instructions, API setup, and customization tips\nBlotato account required with Pro plan and API key\nhttps://blotato.com/?ref=firas\nEnsure ‚ÄúVerified Community Nodes‚Äù are enabled in n8n admin settings for Blotato nodes\nn8n platform configuration\nUse valid OpenAI API and Telegram Bot credentials\nAPI credentials management\nDisclaimer:\nThe provided text originates exclusively from an n8n automated workflow. It complies fully with all applicable content policies and contains no illegal, offensive, or protected content. All data handled is legal and public.\nCopied to clipboard\n\n",
      "category": "AI",
      "complexity": "Intermediate",
      "tags_en": [],
      "tags_fr": [],
      "author": "Dr. Firas",
      "date": "Unknown",
      "url_original": "https://n8nworkflows.xyz/workflows/create-ai-viral-videos-using-nanobanana-2-pro-veo31-and-publish-via-blotato-11204",
      "nodes_count": 35
    }
  ],
  "last_updated": "2026-02-03T10:38:48.409Z"
}